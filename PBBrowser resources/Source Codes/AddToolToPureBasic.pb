;;***********************************************************;;              --  Add Tool to PureBasic --;       This set of functions by Zapman (Oct. 2024);       is intended to be used by PBBrower to add or;       remove a tool from PureBasic preference file.;;***********************************************************;Structure AT_ShortCutsNumAndString  ShortcutNum.i  ShortCutString$EndStructure;NewList ShortCutsKeys.AT_ShortCutsNumAndString();Restore AT_NumShortRepeat  Read.i NData.i  If NData    AddElement(ShortCutsKeys())    ShortCutsKeys()\ShortcutNum = NData  EndIfUntil NData = 0;Restore AT_StringShortForEach ShortCutsKeys()  Read.s ShortCutsKeys()\ShortCutString$Next;For VK = #VK_F1 To #VK_F24  AddElement(ShortCutsKeys())  ShortCutsKeys()\ShortcutNum = VK  ShortCutsKeys()\ShortCutString$ = "F" + Str(VK - #VK_F1 + 1)Next;For VK = #VK_NUMPAD0 To #VK_NUMPAD9  AddElement(ShortCutsKeys())  ShortCutsKeys()\ShortcutNum = VK  ShortCutsKeys()\ShortCutString$ = "NUMPAD" + Str(VK - #VK_NUMPAD0 + 1)Next;For VK = 48 To 90  AddElement(ShortCutsKeys())  ShortCutsKeys()\ShortcutNum = VK  ShortCutsKeys()\ShortCutString$ = Chr(VK)Next;Declare.s GetPureBasicPrefAdresse();Procedure IsToolAllreadyInstalled(toolName$)  Protected configFile$ = GetPathPart(GetPureBasicPrefAdresse()) + "Tools.prefs"  Protected configLine$  Protected Result = 0 ; Return value.  ; Read the content of the configuration file  If ReadFile(0, configFile$)    While Eof(0) = 0      configLine$ + ReadString(0) + #CRLF$      If FindString(configLine$, "MenuItemName = " + toolName$)        Result = 1        Break      EndIf    Wend    CloseFile(0)  EndIf  ProcedureReturn ResultEndProcedure;Procedure.s ComputeShortcutString(value.i)  ; Procedure to get the string representing the key combination  ; from a decimal value.  ;  Shared ShortCutsKeys()  Protected keyComb$ = ""  Protected ct, ListSize  ListSize = ListSize(ShortCutsKeys())   For ct = 0 To ListSize - 1        SelectElement(ShortCutsKeys(), ct)    ;    ; Special keys CTRL, SHIFT, ALT, and CMD    If ct <= 3 And value & ShortCutsKeys()\ShortcutNum      keyComb$ + ShortCutsKeys()\ShortCutString$ + " + "      value & ~ ShortCutsKeys()\ShortcutNum    ;    ; Other keys    ElseIf value = ShortCutsKeys()\ShortcutNum      ProcedureReturn keyComb$ + ShortCutsKeys()\ShortCutString$    EndIf  Next  ;  If value    Debug "not decoded: " + Str(value)  EndIfEndProcedure;Procedure.i ComputeShortcutValue(keyComb$)  ;  ; Procedure to get the decimal value of a key combination  ;  Shared ShortCutsKeys()  Protected value.i = 0  Protected part.s  Protected i.i = 1  ; Traverse each part of the key combination  Repeat    part = StringField(keyComb$, i, " + ")    ForEach ShortCutsKeys()      If part = ShortCutsKeys()\ShortCutString$        value | ShortCutsKeys()\ShortcutNum      EndIf    Next    i + 1  Until part = ""    ProcedureReturn valueEndProcedure;Structure CSCTitleAndButtons  CaptureShortCutsTitle$  UsedShortCutsTitle$  Explanation$  EraseTitle$  CancelButtonTitle$  OKButtonTitle$  IsAllreadyUsed$  DefaultShortCut$EndStructure;Procedure CaptureShortCut(UsedShortCutsList$ = "", *GadgetTitles.CSCTitleAndButtons = 0)  ;  ; Opens a window and prompts the user to choose a keyboard shortcut.  ;  ; The button titles and explanatory text provided to the user  ; must be filled in the CSCTitleAndButtons structure. Otherwise, they  ; will be completed automatically in English.  ;  ; ShortCutsKeys() is a list having the structure 'AT_ShortCutsNumAndString',  ; which must have been initialized to include the list of possible keyboard shortcuts  ; and their names.  ;  ; UsedShortCutsList$ must be filled with the list of already assigned shortcuts.  ;   ;  Shared ShortCutsKeys()  ;  Static GadgetTitles.CSCTitleAndButtons  ;  Protected WWidth, WHeight ; Window dimensions  Protected WShortCut, TShortCut, LShortCut, BOK, LShift, BErase, BCancel ; Gadgets  Protected Event, KeyComb$, mKeyComb$, PTime, somekey ; Event handling  Protected Result                                     ; Return value.  ;  If *GadgetTitles = 0    *GadgetTitles = @GadgetTitles  Else    GadgetTitles\CaptureShortCutsTitle$ = *GadgetTitles\CaptureShortCutsTitle$    GadgetTitles\UsedShortCutsTitle$    = *GadgetTitles\UsedShortCutsTitle$    GadgetTitles\Explanation$           = *GadgetTitles\Explanation$    GadgetTitles\EraseTitle$            = *GadgetTitles\EraseTitle$    GadgetTitles\IsAllreadyUsed$        = *GadgetTitles\IsAllreadyUsed$    GadgetTitles\DefaultShortCut$       = *GadgetTitles\DefaultShortCut$    GadgetTitles\CancelButtonTitle$     = *GadgetTitles\CancelButtonTitle$  EndIf  ;  If GadgetTitles\CaptureShortCutsTitle$ = "" : GadgetTitles\CaptureShortCutsTitle$ = "Choose your shortcut"                  : EndIf  If GadgetTitles\UsedShortCutsTitle$ = ""    : GadgetTitles\UsedShortCutsTitle$ = "List of keyboard shortcuts already used:" : EndIf  If GadgetTitles\Explanation$ = ""           : GadgetTitles\Explanation$ = "By pressing the keys on your keyboard, choose the keyboard shortcut you want to use." : EndIf  If GadgetTitles\EraseTitle$ = ""            : GadgetTitles\EraseTitle$ = "Erase" : EndIf  If GadgetTitles\CancelButtonTitle$ = ""     : GadgetTitles\CancelButtonTitle$ =  "Cancel"       : EndIf  If GadgetTitles\OKButtonTitle$ = ""         : GadgetTitles\OKButtonTitle$ =  "OK"               : EndIf  If GadgetTitles\IsAllreadyUsed$ = ""        : GadgetTitles\IsAllreadyUsed$ = "is allready used" : EndIf  If GadgetTitles\DefaultShortCut$ = ""       : GadgetTitles\DefaultShortCut$ = "CTRL + Q"        : EndIf  ;  If UsedShortCutsList$    WWidth = 530    WHeight = 400  Else    WWidth = 320    WHeight = 200  EndIf  WShortCut = OpenWindow(#PB_Any, 0, 0, WWidth, WHeight, GadgetTitles\CaptureShortCutsTitle$, #PB_Window_SystemMenu | #PB_Window_ScreenCentered)  If WShortCut    StickyWindow(WShortCut, 1)    If UsedShortCutsList$      LShift = 270      FrameGadget(#PB_Any, LShift, 0, 1, WindowHeight(WShortCut), "", #PB_Frame_Single)      TextGadget(#PB_Any, 5, 7, LShift - 10, 20, GadgetTitles\UsedShortCutsTitle$, #PB_Text_Center)      LShortCut = EditorGadget(#PB_Any, 5, 30, LShift - 10, WindowHeight(WShortCut) - 37, #PB_Text_Right)      SendMessage_(GadgetID(LShortCut), #EM_SETTARGETDEVICE, #Null, 0)      SetGadgetText(LShortCut, UsedShortCutsList$)      LoadFont(0, "Consolas", 9)      SetGadgetFont(LShortCut, FontID(0))    EndIf    TextGadget(#PB_Any, LShift + 10, WHeight / 5 - 20, WindowWidth(WShortCut) - LShift - 20, 70, GadgetTitles\Explanation$, #PB_Text_Center)    TShortcut = TextGadget(#PB_Any, LShift + 30, WindowHeight(WShortCut) / 2 - 10, WindowWidth(WShortCut) - LShift - 60, 25, "", #PB_Text_Center | #PB_Text_Border)    SetGadgetColor(TShortcut, #PB_Gadget_BackColor, RGB(230, 230, 230))    If FindString(UsedShortCutsList$, "= " + GadgetTitles\DefaultShortCut$ + Chr(13)) = 0      SetGadgetText(TShortcut, GadgetTitles\DefaultShortCut$)    EndIf    BErase = ButtonGadget(#PB_Any, LShift + (WindowWidth(WShortCut) - LShift - 100) / 2, WindowHeight(WShortCut) / 2 - 10 + 25 + 10, 100, 25, GadgetTitles\EraseTitle$)    BOK = ButtonGadget(#PB_Any, WindowWidth(WShortCut) - 110, WindowHeight(WShortCut) - 35, 100, 25, GadgetTitles\OKButtonTitle$)    BCancel = ButtonGadget(#PB_Any, LShift + 10, WindowHeight(WShortCut) - 35, 130, 25, GadgetTitles\CancelButtonTitle$)    ;    ; Clears the keyboard buffer    ClearKeyboardBuffer(WShortCut)    ;    Repeat      Event = WaitWindowEvent()      If EventWindow() <> WShortCut        SetActiveWindow(WShortCut)      EndIf      If GetActiveGadget() = LShortCut        ; A simple way to disable the blinking cursor in the 'read-only' gadget.        SetActiveGadget(TShortcut)      EndIf      Select Event        Case #PB_Event_Gadget          Select EventGadget()            Case BOK              Break            Case BErase              KeyComb$ = ""              mKeyComb$ = ""              SetGadgetText(TShortcut, "")            Case BCancel ; Cancel button              CloseWindow(WShortCut)              ProcedureReturn - 1          EndSelect                  Case #PB_Event_CloseWindow          CloseWindow(WShortCut)          ProcedureReturn - 1      EndSelect            KeyComb$ = ""            If GetAsyncKeyState_(#VK_CONTROL) & $8000 Or  GetAsyncKeyState_(#VK_LCONTROL) & $8000 Or  GetAsyncKeyState_(#VK_RCONTROL) & $8000 : KeyComb$ + "CTRL + " : EndIf      If GetAsyncKeyState_(#VK_SHIFT) & $8000 Or GetAsyncKeyState_(#VK_LSHIFT) & $8000 Or GetAsyncKeyState_(#VK_RSHIFT) & $8000 : KeyComb$ + "SHIFT + " : EndIf      If GetAsyncKeyState_(#VK_MENU) & $8000 Or GetAsyncKeyState_(#VK_LMENU) & $8000 Or GetAsyncKeyState_(#VK_RMENU) & $8000 : KeyComb$ + "ALT + " : EndIf      If GetAsyncKeyState_(#VK_LWIN) & $8000 Or GetAsyncKeyState_(#VK_RWIN) & $8000    : KeyComb$ + "CMD + " : EndIf            ForEach ShortCutsKeys()        If ListIndex(ShortCutsKeys()) > 3 And GetAsyncKeyState_(ShortCutsKeys()\ShortcutNum) & $8000          KeyComb$ + ShortCutsKeys()\ShortCutString$ + " + "        EndIf      Next            If KeyComb$ And CountString(KeyComb$, " +") < CountString(mKeyComb$, " +")        KeyComb$ = mKeyComb$      Else        mKeyComb$ = KeyComb$      EndIf            If KeyComb$        KeyComb$ = Left(KeyComb$, Len(KeyComb$) - 3) ; Remove last " + "        SetGadgetText(TShortcut, KeyComb$)      EndIf            If UsedShortCutsList$ And KeyComb$ And FindString("= " + UsedShortCutsList$ + Chr(13), "= " + KeyComb$ + Chr(13))        PlaySound_("SystemExclamation", 0, #SND_ALIAS | #SND_ASYNC)        SetGadgetText(TShortcut, GetGadgetText(TShortcut) + " " + GadgetTitles\IsAllreadyUsed$ + ".")        PTime = ElapsedMilliseconds()        ; Wait for the user to release the keys.        Repeat          somekey = 0          ForEach ShortCutsKeys()            If GetAsyncKeyState_(ShortCutsKeys()\ShortcutNum) & $8000              somekey = 1            EndIf          Next          WindowEvent()          Delay(10)        Until somekey = 0        While ElapsedMilliseconds() - PTime < 1000          ; Ensure that the message remains visible for at least one second.          Delay(100)        Wend        SetGadgetText(TShortcut, "")        KeyComb$ = ""        mKeyComb$ = ""      EndIf    ForEver    Result = ComputeShortcutValue(GetGadgetText(TShortcut))    CloseWindow(WShortCut)  EndIf  ClearKeyboardBuffer()  ProcedureReturn ResultEndProcedure;Procedure InitButtonsNamesForCaptureSC(*NameList.CSCTitleAndButtons)    *NameList\CaptureShortCutsTitle$ = GetTextFromCatalogPB("CaptureShortCutsTitle")  *NameList\UsedShortCutsTitle$    = GetTextFromCatalogPB("UsedShortCutsTitle")  *NameList\Explanation$           = GetTextFromCatalogPB("AT_Explanations")  *NameList\EraseTitle$            = GetTextFromCatalogPB("Erase")  *NameList\CancelButtonTitle$     = GetTextFromCatalogPB("Cancel")  *NameList\OKButtonTitle$         = GetTextFromCatalogPB("OK")  *NameList\IsAllreadyUsed$        = GetTextFromCatalogPB("IsAllreadyUsed")  *NameList\DefaultShortCut$       = "CTRL + Q"  ;EndProcedure;Procedure.s ComputeBackupFileName(PBPrefAdr$)  ; Calculate the backup file name:  Protected NoVersion = 0, nnum = 0  Protected backupFile$, ct  ;  Repeat    NoVersion + 1    backupFile$ = GetPathPart(PBPrefAdr$) + "ToolsBak" + Str(NoVersion) + ".prefs"  Until FileSize(backupFile$) < 2  ;  If NoVersion > 5    ; Too many backup files, cleaning up is required    For ct = 1 To NoVersion - 5      backupFile$ = GetPathPart(PBPrefAdr$) + "ToolsBak" + Str(ct) + ".prefs"      DeleteFile(backupFile$)    Next    ;    For ct = NoVersion - 4 To NoVersion - 1      backupFile$ = GetPathPart(PBPrefAdr$) + "ToolsBak" + Str(ct) + ".prefs"      nnum + 1      RenameFile(backupFile$, GetPathPart(PBPrefAdr$) + "ToolsBak" + Str(nnum) + ".prefs")    Next    backupFile$ = GetPathPart(PBPrefAdr$) + "ToolsBak" + Str(nnum + 1) + ".prefs"  EndIf  ProcedureReturn backupFile$EndProcedure;Enumeration ReturnValuesForAddToolToToolsPrefs  #AT_ToolInstallationAborted  #AT_ToolAllreadyInstalled  #AT_ToolInstalledSuccessfully  #AT_ToolExeNotFound  #AT_UnableToFindPBPref  #AT_UnableToCreateToolsConfigFile  #AT_UnableToReadToolsConfigFile  #AT_UnableToBackUpToolsConfigFile  #AT_UnableToOpenPBPref  #AT_UnableToModifyToolsConfigFileEndEnumeration;Declare RemoveToolToToolsPrefs(toolName$);Procedure AddToolToToolsPrefs(toolName$, toolExe$, PortableMode)  ;  Protected line$, currentSection$, value$  Protected PBPrefAdr$, configFile$, backupFile$, configContent$, newTool$  Protected MenuItemName$, NewToolAdress$, SrcPath$  Protected p, pf, ct, ListSize  Protected *ActualElement, *PreviousElement, lprevious, ln, Change    Protected Shortcut$, FunctionName$, UsedShortCutsList$, CSGadgetNames.CSCTitleAndButtons  Protected toolTrigger$, toolCount  Protected toolArguments$, toolWorkDir$, toolShortcut$  ;  ;  If IsToolAllreadyInstalled(toolName$)    RemoveToolToToolsPrefs("PB Browser")  EndIf  If #PB_Compiler_Debugger    ; We are not in 'StandAlone' mode: the PBBrowser application    ; has been launched from the 'Compiler/Run' menu of PureBasic.    ; We need to check if the application has already been compiled as 'PBBrowser.exe',    ; because otherwise, we won't have an executable address to save in    ; the tool parameters.    ;    ; We check in the source folder to see if we can find the executable:    ;    SrcPath$ = GetPathPart(#PB_Compiler_File)    If SrcPath$      Protected TryUp = 0      Repeat        TryUp + 1        NewToolAdress$ = SrcPath$ + toolExe$        If FileSize(NewToolAdress$) < 2          ; If nothing is found, we look in the parent folder:          SrcPath$ = GetParentFolder(SrcPath$)        EndIf      Until TryUp > 3 Or FileSize(NewToolAdress$) > 1      If FileSize(NewToolAdress$) < 2        Alert(GetTextFromCatalogPB("UnableToFindPBBrowser"))        NewToolAdress$ = OpenFileRequester(GetTextFromCatalogPB("ShowPBBrowserPath"), GetSystemFolder(#CSIDL_PROGRAM_FILES) + "\" + toolExe$, toolExe$, 0)      EndIf      If FileSize(NewToolAdress$) < 2        ProcedureReturn #AT_ToolExeNotFound      EndIf    Else      ProcedureReturn #AT_ToolExeNotFound    EndIf  Else    NewToolAdress$ = ProgramFilename()  EndIf  ;  ; Set the path for the Tools.prefs file and the backup file.  PBPrefAdr$ = GetPureBasicPrefAdresse()  If PBPrefAdr$ = ""    ProcedureReturn #AT_UnableToFindPBPref  EndIf  configFile$ = GetPathPart(PBPrefAdr$) + "Tools.prefs"  ;  ; Calculate the backup file name:  backupFile$ = ComputeBackupFileName(PBPrefAdr$)  ;  ; Check if the tools configuration file already exists  If FileSize(configFile$) = -1    ;    ; Create a new configuration file with the base format    configContent$ = #CRLF$ + ";  PureBasic IDE ToolsMenu Configuration" + #CRLF$ + ";" + #CRLF$ + "[ToolsInfo]" + #CRLF$ + "ToolCount = 0" + #CRLF$ + ";" + #CRLF$ + ";" + #CRLF$        ; Create the file and write the initial content    If CreateFile(0, configFile$)      WriteString(0, configContent$)      CloseFile(0)    Else      ProcedureReturn #AT_UnableToCreateToolsConfigFile    EndIf  Else    ; Read the content of the configuration file    If ReadFile(0, configFile$)      configContent$ = ""      While Eof(0) = 0        configContent$ + ReadString(0) + #CRLF$      Wend      CloseFile(0)    Else      ProcedureReturn #AT_UnableToReadToolsConfigFile    EndIf  EndIf  ;  ; Save the configuration file  If CreateFile(0, backupFile$)    WriteString(0, configContent$)    CloseFile(0)  Else    ProcedureReturn #AT_UnableToBackUpToolsConfigFile  EndIf  ;  ; List the keyboard shortcuts already used by other tools  ;  Structure AT_ShortCutsAssociation ; Structure for the ExistingShortCuts list    FunctionName$    ShortCut$  EndStructure    Protected NewList ExistingShortCuts.AT_ShortCutsAssociation()  ;  p = 0  Repeat    p = FindString(configContent$, "MenuItemName = ", p + 1)    If p      p + Len("MenuItemName = ")      pf = FindString(configContent$, Chr(13), p + 1)      If pf        MenuItemName$ = Trim(Mid(configContent$, p, pf - p))        p = FindString(configContent$, "Shortcut = ", p + 1)        If p          p + Len("Shortcut = ")          pf = FindString(configContent$, Chr(13), p + 1)          If pf            Shortcut$ = Trim(Mid(configContent$, p, pf - p))            If Val(Shortcut$) <> 0              AddElement(ExistingShortCuts())              ExistingShortCuts()\FunctionName$ = MenuItemName$              ExistingShortCuts()\ShortCut$ = ComputeShortcutString(Val(Shortcut$))            EndIf          EndIf        EndIf      EndIf    EndIf  Until p = 0  ;  ; List non-null shortcuts from PureBasic preferences file  ;  currentSection$ = ""  If ReadFile(0, PBPrefAdr$)    While Eof(0) = 0      line$ = Trim(ReadString(0))      If Left(line$, 1) = "[" And Right(line$, 1) = "]"        currentSection$ = Mid(line$, 2, Len(line$) - 2)      ElseIf currentSection$ = "Shortcuts" And line$ <> ""        FunctionName$ = StringField(line$, 1, " =")        value$ = Trim(StringField(line$, 2, "="))        If Val(value$) <> 0          AddElement(ExistingShortCuts())          ExistingShortCuts()\FunctionName$ = FunctionName$          ExistingShortCuts()\ShortCut$ = ComputeShortcutString(Val(value$))        EndIf      EndIf    Wend    CloseFile(0)  Else    ProcedureReturn #AT_UnableToOpenPBPref  EndIf  ;  ForEach ExistingShortCuts()    ; Temporarily transform the values of ShortCut$ to get    ; an optimal sorting of the values.    ExistingShortCuts()\ShortCut$ = ReplaceString(ExistingShortCuts()\ShortCut$, "CTRL", "_" + Chr(1))    ExistingShortCuts()\ShortCut$ = ReplaceString(ExistingShortCuts()\ShortCut$, "SHIFT", Chr(2))    ExistingShortCuts()\ShortCut$ = ReplaceString(ExistingShortCuts()\ShortCut$, "ALT", Chr(3))    ExistingShortCuts()\ShortCut$ = ReplaceString(ExistingShortCuts()\ShortCut$, "ESC", "ZZE")    ExistingShortCuts()\ShortCut$ = ReplaceString(ExistingShortCuts()\ShortCut$, "TAB", "ZZT")    ExistingShortCuts()\ShortCut$ = ReplaceString(ExistingShortCuts()\ShortCut$, "SPACE", Chr(7))  Next  ;  SortStructuredList(ExistingShortCuts(), #PB_Sort_Ascending, OffsetOf(AT_ShortCutsAssociation\ShortCut$), TypeOf(AT_ShortCutsAssociation\ShortCut$))  ;  ; Sort the list by keyboard shortcut length  ;  ListSize = ListSize(ExistingShortCuts())   Repeat    Change = 0    For ct = 0 To ListSize - 1      If ct = 0        *ActualElement = SelectElement(ExistingShortCuts(), ct)        ln = Len(ExistingShortCuts()\ShortCut$)      Else        lprevious = ln        *PreviousElement = *ActualElement        *ActualElement = SelectElement(ExistingShortCuts(), ct)        ln = Len(ExistingShortCuts()\ShortCut$)        If lprevious > ln          SwapElements(ExistingShortCuts(), *ActualElement, *PreviousElement)          Change = 1        EndIf      EndIf    Next  Until Change = 0  ;  UsedShortCutsList$ = ""  ForEach ExistingShortCuts()    ; Restore the normal values of ShortCut$    ExistingShortCuts()\ShortCut$ = ReplaceString(ExistingShortCuts()\ShortCut$, "_" + Chr(1), "CTRL")    ExistingShortCuts()\ShortCut$ = ReplaceString(ExistingShortCuts()\ShortCut$, Chr(2), "SHIFT")    ExistingShortCuts()\ShortCut$ = ReplaceString(ExistingShortCuts()\ShortCut$, Chr(3), "ALT")    ExistingShortCuts()\ShortCut$ = ReplaceString(ExistingShortCuts()\ShortCut$, "ZZE", "ESC")    ExistingShortCuts()\ShortCut$ = ReplaceString(ExistingShortCuts()\ShortCut$, "ZZT", "TAB")    ExistingShortCuts()\ShortCut$ = ReplaceString(ExistingShortCuts()\ShortCut$, Chr(7), "SPACE")    UsedShortCutsList$ + ExistingShortCuts()\FunctionName$ + " = " + ExistingShortCuts()\ShortCut$ + Chr(13)  Next  ;  ; Define the tool parameters  InitButtonsNamesForCaptureSC(CSGadgetNames.CSCTitleAndButtons)  CSGadgetNames\CancelButtonTitle$ = GetTextFromCatalogPB("AT_DontInstall")  CSGadgetNames\CaptureShortCutsTitle$ = GetTextFromCatalogPB("PBCaptureTitle")  CSGadgetNames\Explanation$ = GetTextFromCatalogPB("PBSC_Explanations")    toolArguments$ = Chr(34) + "%HOME" + Chr(34) + " " + Chr(34) + "%WORD" + Chr(34) + " " + Chr(34) + "%SELECTION" + Chr(34) + " " + Chr(34) + "%CURSOR" + Chr(34) + " " + Chr(34) + "%FILE" + Chr(34) + " " + Chr(34) + "%TEMPFILE" + Chr(34)  If PortableMode    toolArguments$ = "\PORTABLE " + toolArguments$  EndIf  toolWorkDir$ = GetPathPart(NewToolAdress$)  toolShortcut$ = Str(CaptureShortCut(UsedShortCutsList$, CSGadgetNames))    If toolShortcut$ = "-1"    ProcedureReturn #AT_ToolInstallationAborted  EndIf    toolTrigger$ = "0" ; Menu or shortcut    ; Extract the current ToolCount  p = FindString(configContent$, "ToolCount = ")  pf = FindString(configContent$, #CRLF$, p)  toolCount = Val(StringField(Trim(Mid(configContent$, p, pf - p)), 2, "ToolCount = "))    ; Build the new tool to add  newTool$ = "[Tool_" + Str(toolCount) + "]" + #CRLF$  newTool$ + "Command = " + NewToolAdress$ + #CRLF$  newTool$ + "Arguments = " + toolArguments$ + #CRLF$  newTool$ + "WorkingDir = " + toolWorkDir$ + #CRLF$  newTool$ + "MenuItemName = " + toolName$ + #CRLF$  newTool$ + "Shortcut = " + toolShortcut$ + #CRLF$  newTool$ + "ConfigLine = " + #CRLF$  newTool$ + "Trigger = " + toolTrigger$ + #CRLF$  newTool$ + "Flags = 0" + #CRLF$  newTool$ + "ReloadSource = 0" + #CRLF$  newTool$ + "HideEditor = 0" + #CRLF$  newTool$ + "HideFromMenu = 0" + #CRLF$  newTool$ + "SourceSpecific = 0" + #CRLF$  newTool$ + "Deactivate = 0" + #CRLF$    ; Update ToolCount  configContent$ = ReplaceString(configContent$, "ToolCount = " + Str(toolCount), "ToolCount = " + Str(toolCount + 1))    ; Add the new tool to the existing content  configContent$ + newTool$    ; Write the modified content to the configuration file  If CreateFile(0, configFile$)    WriteString(0, configContent$)    CloseFile(0)    ProcedureReturn #AT_ToolInstalledSuccessfully  Else    ProcedureReturn #AT_UnableToModifyToolsConfigFile  EndIfEndProcedure;Enumeration ReturnValuesForRemoveToolToToolsPrefs  #ATR_ToolNotInstalled  #ATR_ToolRemovedSuccessfully  #ATR_UnableToFindPBPref  #ATR_UnableToReadToolsConfigFile  #ATR_UnableToBackUpToolsConfigFile  #ATR_UnableToModifyToolsConfigFileEndEnumeration;Procedure RemoveToolToToolsPrefs(toolName$)  ;  Protected PBPrefAdr$, configFile$, backupFile$  Protected configContent$, toolCount  Protected p, pf, GetOut  ;  ; Define the path of the Tools.prefs file and the backup file.  PBPrefAdr$ = GetPureBasicPrefAdresse()  If PBPrefAdr$ = ""    ProcedureReturn #ATR_UnableToFindPBPref  EndIf  configFile$ = GetPathPart(PBPrefAdr$) + "Tools.prefs"  ;  If Not (IsToolAllreadyInstalled(toolName$))    ProcedureReturn #ATR_ToolNotInstalled  EndIf  ;  ; Calculate the backup file name:  backupFile$ = ComputeBackupFileName(PBPrefAdr$)  ;  ; Read the content of the configuration file  If ReadFile(0, configFile$)    configContent$ = ""    While Eof(0) = 0      configContent$ + ReadString(0) + #CRLF$    Wend    CloseFile(0)  Else    ProcedureReturn #ATR_UnableToReadToolsConfigFile  EndIf  ;  ; Backup the configuration file  If CreateFile(0, backupFile$)    WriteString(0, configContent$)    CloseFile(0)  Else    ProcedureReturn #ATR_UnableToBackUpToolsConfigFile  EndIf  ;  ; Extract the current ToolCount  p = FindString(configContent$, "ToolCount = ")  pf = FindString(configContent$, #CRLF$, p)    toolCount = Val(StringField(Trim(Mid(configContent$, p, pf - p)), 2, "ToolCount = "))  ;  ; Update ToolCount  configContent$ = ReplaceString(configContent$, "ToolCount = " + Str(toolCount), "ToolCount = " + Str(toolCount - 1))  ;  ; Remove the tool from configContent$  GetOut = 0  p = FindString(configContent$, "MenuItemName = " + toolName$)  If p    pf = p    While p And Mid(configContent$, p, 5) <> "[Tool" : p - 1 : Wend    If Mid(configContent$, p, 5) = "[Tool"      pf = FindString(configContent$, "[Tool", pf)      If pf = 0 : pf = Len(configContent$) + 1 : EndIf      configContent$ = Left(configContent$, p - 1) + Mid(configContent$, pf)      GetOut = 1    EndIf  EndIf  If GetOut = 0    ProcedureReturn #ATR_UnableToModifyToolsConfigFile  EndIf  ;  ; Write the modified content to the configuration file  If CreateFile(0, configFile$)    WriteString(0, configContent$)    CloseFile(0)    ProcedureReturn #ATR_ToolRemovedSuccessfully  Else    ProcedureReturn #ATR_UnableToModifyToolsConfigFile  EndIfEndProcedure;Procedure InstallPBBrowserAndPrintResult(PortableMode)  Protected Result = AddToolToToolsPrefs("PB Browser", "PBBrowser.exe", PortableMode)  ;  Protected Msg$ = ""  If Result = #AT_ToolInstalledSuccessfully    Msg$ = GetTextFromCatalogPB("ToolInstalledSuccessfully")  ElseIf Result = #AT_ToolAllreadyInstalled    Msg$ = GetTextFromCatalogPB("ToolAllreadyInstalled")  ElseIf Result = #AT_ToolExeNotFound    Msg$ = GetTextFromCatalogPB("ToolExeNotFound")  ElseIf Result = #AT_UnableToFindPBPref    Msg$ = GetTextFromCatalogPB("UnableToFindPBPref")  ElseIf Result = #AT_UnableToCreateToolsConfigFile    Msg$ = GetTextFromCatalogPB("UnableToCreateToolsConfigFile")  ElseIf Result = #AT_UnableToReadToolsConfigFile    Msg$ = GetTextFromCatalogPB("UnableToReadToolsConfigFile")  ElseIf Result = #AT_UnableToBackUpToolsConfigFile    Msg$ = GetTextFromCatalogPB("UnableToBackUpToolsConfigFile")  ElseIf Result = #AT_UnableToOpenPBPref    Msg$ = GetTextFromCatalogPB("UnableToOpenPBPref")  ElseIf Result = #AT_UnableToModifyToolsConfigFile    Msg$ = GetTextFromCatalogPB("UnableToModifyToolsConfigFile")  EndIf  If Msg$    alert(Msg$, 1)  EndIf  ProcedureReturn ResultEndProcedure;Procedure UnInstallPBBrowserAndPrintResult(Silence = 0)  Protected Result = RemoveToolToToolsPrefs("PB Browser")  ;  Protected Msg$ = ""  If Result = #ATR_ToolRemovedSuccessfully    Msg$ = GetTextFromCatalogPB("ToolRemovedSuccessfully")  ElseIf Result = #ATR_ToolNotInstalled    Msg$ = GetTextFromCatalogPB("ToolNotInstalled")  ElseIf Result = #ATR_UnableToFindPBPref    Msg$ = GetTextFromCatalogPB("UnableToFindPBPref")  ElseIf Result = #ATR_UnableToReadToolsConfigFile    Msg$ = GetTextFromCatalogPB("UnableToReadToolsConfigFile")  ElseIf Result = #ATR_UnableToBackUpToolsConfigFile    Msg$ = GetTextFromCatalogPB("UnableToBackUpToolsConfigFile")  ElseIf Result = #ATR_UnableToModifyToolsConfigFile    Msg$ = GetTextFromCatalogPB("UnableToModifyToolsConfigFile")  EndIf  If Msg$ And Silence = 0    alert(Msg$, 1)  EndIf  ProcedureReturn ResultEndProcedure;DataSection  AT_NumShort:   Data.i #PB_Shortcut_Control, #PB_Shortcut_Shift, #PB_Shortcut_Alt, #PB_Shortcut_Command  ;  Data.i #VK_BACK, #VK_TAB, #VK_CLEAR, #VK_RETURN, #VK_PAUSE, #VK_ESCAPE, #VK_SPACE  ;Data.i #VK_LBUTTON  Data.i #VK_RBUTTON, #VK_MBUTTON  Data.i #VK_PRIOR, #VK_NEXT, #VK_END, #VK_HOME, #VK_UP, #VK_DOWN, #VK_LEFT, #VK_RIGHT  Data.i #VK_SELECT, #VK_PRINT, #VK_EXECUTE, #VK_SNAPSHOT, #VK_INSERT, #VK_DELETE, #VK_HELP  ;  Data.i #VK_APPS, #VK_SLEEP  Data.i #VK_MULTIPLY, #VK_ADD, #VK_SEPARATOR, #VK_SUBTRACT, #VK_DECIMAL, #VK_DIVIDE  ;  Data.i #VK_LAUNCH_APP1, #VK_LAUNCH_APP2  ;  Data.i #VK_OEM_MINUS, #VK_OEM_PLUS, #VK_OEM_COMMA, #VK_OEM_PERIOD  Data.i #VK_OEM_1, #VK_OEM_2, #VK_OEM_3, #VK_OEM_4, #VK_OEM_5, #VK_OEM_6, #VK_OEM_7, #VK_OEM_8  ;  Data.i #VK_ATTN, #VK_CRSEL, #VK_EXSEL, #VK_EREOF, #VK_PLAY, #VK_ZOOM, #VK_NONAME, #VK_PA1, #VK_OEM_CLEAR  ;  Data.i #VK_CAPITAL, #VK_NUMLOCK, #VK_SCROLL    Data.i 0  ;  ;  AT_StringShort:   Data.s "CTRL", "SHIFT", "ALT", "CMD"  ;  Data.s "BACK", "TAB", "CLEAR", "RET", "PAUSE", "ESC", "SPACE"  ;Data.s "LBUTTON"  Data.s "RBUTTON", "MBUTTON"  Data.s "PAGEUP", "PAGEDOWN", "END", "HOME", "UP", "DOWN", "LEFT", "RIGHT"  Data.s "SELECT", "PRINT", "EXECUTE", "SNAPSHOT", "INSERT", "DEL", "HELP"  ;  Data.s "APPS", "SLEEP"  Data.s "MULT", "ADD", "SEP", "SUB", "DEC", "DIV"  ;  Data.s "LAUNCH1", "LAUNCH2"  ;  Data.s "-", "'+'", ",", "."  ;  Data.s "OEM_1", "OEM_2", "OEM_3", "OEM_4", "OEM_5", "OEM_6", "OEM_7", "OEM_8"  ;  Data.s "ATTN", "CRSEL", "EXSEL", "EREOF", "PLAY", "ZOOM", "NONAME", "PA1", "OEMCLEAR"  ;  Data.s "CAPSLOCK", "NUMLOCK", "SCROLLLOCK"  ;    Data.s "End"EndDataSection; IDE Options = PureBasic 6.12 LTS (Windows - x86); CursorPosition = 717; FirstLine = 96; Folding = Aw; EnableXP; DPIAware; UseMainFile = ..\..\PBBrowser.pb; Executable = AddToolToPureBasic.exe