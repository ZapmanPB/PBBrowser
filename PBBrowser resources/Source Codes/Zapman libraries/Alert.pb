;; ********************************************************************;;                           'Alert' library;;          An alternative to PureBasic's 'MessageRequester'.;                For Windows only - Zapman, aug. 2024.;;        Examples usages can be found at the end of this file.;; ********************************************************************;XIncludeFile "RichEdit_BasicLibrary.pb";Global PBBAllGadgetsFontIf PBBAllGadgetsFont = 0  PBBAllGadgetsFont = FontID(LoadFont(#PB_Any, "Segoe UI", 9))EndIf;Procedure.i IsMemoryValid(*ptr)  Protected result.i = #False  Protected mbi.MEMORY_BASIC_INFORMATION    If VirtualQuery_(*ptr, @mbi, SizeOf(MEMORY_BASIC_INFORMATION))    If mbi\State = #MEM_COMMIT And (mbi\Protect & (#PAGE_NOACCESS | #PAGE_GUARD)) = 0      result = #True    EndIf  EndIf    ProcedureReturn resultEndProcedure;Procedure ClearKeyboardBuffer(WindowID = 0)  If IsWindow(WindowID)    While WindowEvent() : Wend  EndIf  Protected msg.MSG  ; Boucle pour traiter tous les messages clavier en attente  While PeekMessage_(@msg, 0, #WM_KEYFIRST, #WM_KEYLAST, #PM_REMOVE)    ; On ne fait rien, on vide simplement les messages clavier du buffer  Wend  ;  Protected Dim keystate.b(256)  Protected i  ; Récupérer l'état actuel du clavier  GetKeyboardState_(@keystate())    ; Boucle pour vérifier toutes les touches  For i = 0 To 255    If keystate(i) & $80      ; Lire l'état de chaque touche pour vider le buffer      While GetAsyncKeyState_(i) & $8000      Wend    EndIf  Next iEndProcedure;Procedure.l GetTextSurfPix(gadget, Text$, *Width.Double, *Height.Double)  ; Renvoie les dimensions en pixels d'un texte quand on l'affiche dans le gadget "gadget"  If IsGadget(gadget)    Protected Font = GetGadgetFont(Gadget)    Protected Image = CreateImage(#PB_Any, 200, 200)    If Image And StartDrawing(ImageOutput(Image))      DrawingFont(Font)      *Width\d  = DesktopUnscaledX(TextWidth(Text$))      *Height\d = DesktopUnscaledY(TextHeight(Text$))      StopDrawing()      FreeImage(Image)    EndIf  EndIfEndProcedure;Procedure.l GetTextWidthPix(gadget, Text$)  Protected TWidth.d, THeight.d  GetTextSurfPix(gadget, Text$, @TWidth.d, @THeight.d)  ProcedureReturn TWidthEndProcedure;Procedure.f GetMonitorDPI(Window.i = 0)  ; Récupère l'échelle d'affichage sur le moniteur  ProcedureReturn (DesktopResolutionX() + DesktopResolutionY()) / 2EndProcedure;Procedure ApplyFontToGadgetList(GadgetList$)  Protected PosInGadgetList = 0, Gadget  ;  Repeat    PosInGadgetList + 1    Gadget = Val(StringField(GadgetList$, PosInGadgetList, ","))    If IsGadget(Gadget)      SetGadgetFont(Gadget, PBBAllGadgetsFont)    EndIf  Until StringField(GadgetList$, PosInGadgetList, ",") = ""EndProcedure;Procedure RE_SearchString(Gadget, SearchString$, MATCHCASE = 0, WHOLEWORD = 0, UP = 0, startPos = -2)  ; By Zapman  ;  ; Will search the string 'SearchString$' into the content of the RichEditGadget 'Gadget'  ; If the Gadget has a selected range of text, the search will be done after the position of the selection  ; (of before, if 'UP' is set to 1).  ; If a value different from '-2' is attributed to 'startpos", the search will be done after the startpos  ; (of before, if 'UP' is set to 1).  ;  ; Returned value is:  ; Position of SearchString$ into the content of the Gadget if string is found;  ; -2 if string is not found, but search have'nt been done on whole the Gadget content;  ; -1 if SearchString$ can't be found into the gagdet content.  ;  ;  If SearchString$ is found, the selection of the Gadget is changed to the position of found text  ;  Protected McpMin, McpMax, NUP, flg, Res  Protected text.FINDTEXT\lpstrText = @SearchString$  ;  If startPos <> -2 ; A start position is given for the search    text\chrg\cpMin = startPos    text\chrg\cpMax = startPos    SendMessage_(GadgetID(Gadget), #EM_EXSETSEL, 0, @text\chrg) ; set the cursor at the given position  EndIf  SendMessage_(GadgetID(Gadget), #EM_EXGETSEL, 0, @text\chrg) ; get the range of the selected text  If (text\chrg\cpMin <> text\chrg\cpMax)    ; Selected text range found, search from the end of it (or from the start, if UP = 1)    If UP = 0      text\chrg\cpMin = text\chrg\cpMax    Else      text\chrg\cpMax = text\chrg\cpMin    EndIf  EndIf  McpMin = text\chrg\cpMin   McpMax = text\chrg\cpMax  text\chrg\cpMax = -1 ; This must be set in all case for a successful search  ;set the search flags  If UP : NUP = 0 : Else : NUP = 1 : EndIf  flg = (MATCHCASE * #FR_MATCHCASE) | (WHOLEWORD * #FR_WHOLEWORD) | (NUP * #FR_DOWN)  Res = SendMessage_(GadgetID(Gadget), #EM_FINDTEXT, flg, @text)  If Res > -1 ; the searched text has been found!!    SendMessage_(GadgetID(Gadget), #EM_SETSEL, Res, Res + Len(SearchString$)) ; select found string into the Gadget  Else    ; If not found, is it possible to extend the search range?    ; If yes, return value will be -2    If UP = 0 And McpMin > 0 : Res = -2 : EndIf    If UP And McpMax <> -1 ; if McpMax was -1, we've yet search from end      text\chrg\cpMin = -1      text\chrg\cpMax = -1      SendMessage_(GadgetID(Gadget), #EM_EXSETSEL, 0, @text\chrg) ; go to the end      SendMessage_(GadgetID(Gadget), #EM_EXGETSEL, 0, @text\chrg) ; get end pos      If McpMax <> text\chrg\cpMax : Res = -2 : EndIf ; compare with last search pos      text\chrg\cpMin = McpMin       text\chrg\cpMax = McpMax      SendMessage_(GadgetID(Gadget), #EM_EXSETSEL, 0, @text\chrg) ; restore first selection    EndIf  EndIf  ProcedureReturn ResEndProcedure;Structure REFR_GadgetsTitles  WTitle$  Search$  ReplaceTitle$  Replace$  ReplaceAll$  Quit$  CaseSensitive$  WholeWord$  InAllDocument$  UnableToFind$  ReplacementMade$  SearchFromStart$  SearchFromEnd$EndStructure: Enumeration REFR_ShortCuts  #REFRShortCut_Quit  #REFRShortCut_Search  #REFRShortCut_TabEndEnumeration;Procedure RE_FindReplace(Gadget, Replace = 0, *TitlesPtr = 0)  ;  ; by Zapman  ;  ; Open a dialog allowing the user to find or replace a string into the content of a RichEdit Gadget  ; If parameter 'Replace' is omitted or set to zero, only find is possible  ;  Protected GTitles.REFR_GadgetsTitles  ;  Protected flags, WHeight ; Window format  Protected FRWindow, SearchStringGadget, BPrevious, BNext, VPos, ReplaceStringGadget ; Gadgets  Protected BReplace, BReplaceAll, BQuit, chk1, chk2, chk3                            ; Gadgets  Protected SelectedText$, DoSearch, Event, find.s, RewindSearch  Protected Pos, StartPos, FirstSearch, NbReplace, msg.s  Protected txtrange.CHARRANGE, repl.s  ;  If *TitlesPtr    CopyStructure(*TitlesPtr, @GTitles, REFR_GadgetsTitles)  Else    GTitles\WTitle$          = "Rechercher"    GTitles\Search$          = "Chercher :"    GTitles\ReplaceTitle$    = "Remplacer par :"    GTitles\Replace$         = "Remplacer"    GTitles\ReplaceAll$      = "Tout remplacer"    GTitles\Quit$            = "Quitter"    GTitles\CaseSensitive$   = "Respecter la casse"    GTitles\WholeWord$       = "Mot entier"    GTitles\InAllDocument$   = "Dans tout le document"    GTitles\UnableToFind$    = "Impossible de trouver"    GTitles\ReplacementMade$ = "remplacement(s) effectué(s)."    GTitles\SearchFromStart$ = "Rechercher depuis la fin ?"    GTitles\SearchFromEnd$   = "Rechercher depuis le début ?"  EndIf  flags = #PB_Window_Invisible | #PB_Window_SystemMenu | #PB_Window_ScreenCentered  If Replace    WHeight = 160  Else    WHeight = 120  EndIf  ;  FRWindow = OpenWindow(#PB_Any, 0, 0, 510, WHeight, GTitles\WTitle$, flags)  If FRWindow    CompilerIf Defined(ApplyDarkModeToWindow, #PB_Procedure)      ApplyDarkModeToWindow(FRWindow)    CompilerEndIf    StickyWindow(FRWindow, #True)    TG1 = TextGadget(#PB_Any, 10, 20, 100, 22, GTitles\Search$)    GadgetList$ + Str(TG1) + ","    SearchStringGadget = StringGadget(#PB_Any, 100, 15, 300, 25, "")    GadgetList$ + Str(SearchStringGadget) + ","    BPrevious = ButtonGadget(#PB_Any, 410, 15, 35, 26, "<<", #PB_Button_Default)    GadgetList$ + Str(BPrevious) + ","    BNext = ButtonGadget(#PB_Any, 465, 15, 35, 26, ">>", #PB_Button_Default)    GadgetList$ + Str(BNext) + ","    DisableGadget(BNext, #True)    If Replace      VPos = 55      TG2 = TextGadget(#PB_Any, 10, VPos, 100, 22, GTitles\ReplaceTitle$)      GadgetList$ + Str(TG2) + ","      ReplaceStringGadget = StringGadget(#PB_Any, 100, VPos - 5, 300, 25, "")      GadgetList$ + Str(ReplaceStringGadget) + ","      BReplace = ButtonGadget(#PB_Any, 410, VPos - 5, 90, 26, GTitles\Replace$)      GadgetList$ + Str(BReplace) + ","      DisableGadget(BReplace, #True)         BReplaceAll = ButtonGadget(#PB_Any, 410, VPos + 30, 90, 26, GTitles\ReplaceAll$)      GadgetList$ + Str(BReplaceAll) + ","      DisableGadget(BReplaceAll, #True)    EndIf    BQuit = ButtonGadget(#PB_Any, 410, (WindowHeight(FRWindow) - 33), 90, 26, GTitles\Quit$)    GadgetList$ + Str(BQuit) + ","    VPos = 85    If Replace = 0      VPos - 40    EndIf    chk1 = CheckBoxGadget(#PB_Any, 10, VPos, 135, 26, GTitles\CaseSensitive$)    GadgetList$ + Str(chk1) + ","    chk2 = CheckBoxGadget(#PB_Any, 155, VPos, 100, 26, GTitles\WholeWord$)    GadgetList$ + Str(chk2) + ","    If Replace      chk3 = CheckBoxGadget(#PB_Any, 255, VPos, 190, 26, GTitles\InAllDocument$)      GadgetList$ + Str(chk3) + ","    EndIf    ;    SendMessage_(GadgetID(Gadget), #EM_HIDESELECTION, #False, 0)    ;    ;get any selected text in the richedit    SelectedText$ = RE_GetGadgetSelectedText(Gadget)    If Len(SelectedText$) < 128      SetGadgetText(SearchStringGadget, SelectedText$)      ;focus the replace input field      If IsGadget(ReplaceStringGadget) : SetActiveGadget(ReplaceStringGadget) : EndIf      ;enable the buttons      DisableGadget(BNext, #False)      If Replace        DisableGadget(BReplace, #False)        DisableGadget(BReplaceAll, #False)      EndIf    EndIf    ;focus the findstring input field    SetActiveGadget(SearchStringGadget)    ;    AddKeyboardShortcut(FRWindow, #PB_Shortcut_Return, #REFRShortCut_Search)    AddKeyboardShortcut(FRWindow, #PB_Shortcut_Escape, #REFRShortCut_Quit)    AddKeyboardShortcut(FRWindow, #PB_Shortcut_Tab, #REFRShortCut_Tab)    ;    ApplyFontToGadgetList(GadgetList$)    ;    ; ---------------------------------------------------    ; Apply color theme if it exists:    ;    CompilerIf Defined(SetGadgetsColorsFromTheme, #PB_Procedure)      ;      If ListSize(InterfaceColorPresets()) > 0        SetGadgetsColorsFromTheme(FRWindow, InterfaceColorPresets(), GadgetList$)      EndIf      ;    CompilerEndIf    ;    ; ---------------------------------------------------    ;    ; The window was invisible until now, because we created it with #PB_Window_Invisible.    ; We make it visible now.    HideWindow(FRWindow, #False)    ;    Repeat      event = WaitWindowEvent()      DoSearch = 0      If EventWindow() <> FRWindow        SetActiveWindow(FRWindow)      Else        If event = #PB_Event_Menu          If EventMenu() = #REFRShortCut_Tab            If GetActiveGadget() = SearchStringGadget              If IsGadget(ReplaceStringGadget)                While WindowEvent() : Wend                SetActiveGadget(ReplaceStringGadget)              EndIf            ElseIf IsGadget(ReplaceStringGadget) And GetActiveGadget() = ReplaceStringGadget              While WindowEvent() : Wend              SetActiveGadget(SearchStringGadget)            EndIf          ElseIf EventMenu() = #REFRShortCut_Search            DoSearch = 1            event = #PB_Event_Gadget          ElseIf EventMenu() = #REFRShortCut_Quit            Break          EndIf        ElseIf event = #PB_Event_CloseWindow          Break          EndIf        If event = #PB_Event_Gadget          If EventGadget() =  BNext            DoSearch = 1          EndIf          If EventGadget() = SearchStringGadget            ;find string            ;GadgetToolTip(SearchStringGadget, GetGadgetText(SearchStringGadget))            If Len(GetGadgetText(SearchStringGadget))              DisableGadget(BPrevious, #False)              DisableGadget(BNext, #False)              If Replace                DisableGadget(BReplace, #False)                DisableGadget(BReplaceAll, #False)              EndIf            Else              DisableGadget(BPrevious, #True)              DisableGadget(BNext, #True)              If Replace                DisableGadget(BReplace, #True)                DisableGadget(BReplaceAll, #True)              EndIf            EndIf          ElseIf Replace And EventGadget() =  ReplaceStringGadget            ;replace string            ;GadgetToolTip(ReplaceStringGadget, GetGadgetText(ReplaceStringGadget))          ElseIf DoSearch Or EventGadget() = BPrevious Or (Replace And EventGadget() =  BReplace Or EventGadget() =  BReplaceAll)            find.s = GetGadgetText(SearchStringGadget)            If Replace And (EventGadget() =  BReplace Or EventGadget() =  BReplaceAll) ; If replacing...              RE_GetSelection(Gadget, @txtrange.CHARRANGE)              If (txtrange\cpMin <> txtrange\cpMax) ; if there is a selection, go to the beginning of it                RE_SetSelection(Gadget, txtrange\cpMin, txtrange\cpMax)              EndIf            EndIf            ;            If EventGadget() = BPrevious : RewindSearch = 1 : Else : RewindSearch = 0 : EndIf            ;            StartPos = -2            If IsGadget(chk3) And GetGadgetState(chk3)              ;reset, search from the top (or from the end, if it's a << search)              SetGadgetState(chk3, 0)              If RewindSearch : StartPos = -1 : Else : StartPos = 0 : EndIf            EndIf            ;            FirstSearch = 0            NbReplace = 0            RE_RebootSearch:             FirstSearch + 1            Repeat              pos = RE_SearchString(Gadget, find, GetGadgetState(chk1), GetGadgetState(chk2), RewindSearch, StartPos)              If Replace And pos > -1 And (EventGadget() =  BReplace Or EventGadget() =  BReplaceAll)                repl.s = GetGadgetText(ReplaceStringGadget)                RE_ReplaceSelection(Gadget, repl)                RE_GetSelection(Gadget, @txtrange.CHARRANGE)                txtrange\cpMin = txtrange\cpMax - Len(repl)                If EventGadget() =  BReplaceAll Or (EventGadget() =  BReplace And FindString(repl, find, 0))                  txtrange\cpMin = txtrange\cpMax                EndIf                RE_SetSelection(Gadget, txtrange\cpMin, txtrange\cpMax)                NbReplace + 1              EndIf            Until EventGadget() <>  BReplaceAll Or pos < 0 Or Replace = 0            If pos = -2 ; String not found, but it is possible to extend the search range              If NbReplace = 0                msg.s = GTitles\UnableToFind$ + " " + find + Chr(13) + Chr(10)              Else                msg = ""                If EventGadget() =  BReplaceAll                  msg.s = Str(NbReplace) + " " + GTitles\ReplacementMade$ + Chr(13) + Chr(10)                EndIf              EndIf              If RewindSearch                msg + GTitles\SearchFromStart$                StartPos = -1              Else                msg + GTitles\SearchFromEnd$                StartPos = 0              EndIf              If MessageRequester(GTitles\WTitle$, msg, #PB_MessageRequester_YesNo) =  #PB_MessageRequester_Yes                Goto RE_RebootSearch                SetActiveGadget(Gadget)              EndIf            EndIf            ;            msg.s = ""            If Replace And EventGadget() =  BReplaceAll              msg.s = Str(NbReplace) + " " + GTitles\ReplacementMade$            ElseIf pos = -1              msg.s = GTitles\UnableToFind$ + " " + find            EndIf            If msg              MessageRequester(GTitles\WTitle$, msg, #PB_MessageRequester_Ok)              SetActiveGadget(Gadget)            EndIf          EndIf          If EventGadget() =  BQuit            Break          EndIf        EndIf        ;      EndIf      SetForegroundWindow_(WindowID(FRWindow))      SetActiveWindow(FRWindow)    ForEver    CloseWindow(FRWindow)  EndIfEndProcedure;Structure AlertWindowGList  WindowNum.i  Margins.i  BHeight.i  BWidth.i  ;  RE_gadget.i  YesNoCancel.i  BOK.i  BCancel.i  BYes.i  BNo.i  BSearch.i  BCopy.i  BSave.iEndStructure;Structure AlertWindowTitles  WTitle$  BOK$  BCopy$  BSave$  BSearch$  BYes$  BNo$  BCancel$  SaveAs$  TextFile$  SearchGadgets.REFR_GadgetsTitlesEndStructure;Enumeration AlertYesNoCancel  #AW_AlertOnly  #AW_YesOrNo_YesByDefault  #AW_YesOrNo_NoByDefault  #AW_OKOrCancel_OKByDefault  #AW_OKOrCancel_CancelByDefault  #AW_YesNoOrCancel_YesByDefault  #AW_YesNoOrCancel_NoByDefault  #AW_YesNoOrCancel_CancelByDefaultEndEnumeration;Procedure ResizeAlertWindow()  ;  Shared AlertGList.AlertWindowGList ; Pour le partage des numéros de gadgets.  ;  Protected WWidth, WHeight, Margins, LowBPos, YesNoCancel  ;  WWidth  = WindowWidth(AlertGList\WindowNum)  WHeight = WindowHeight(AlertGList\WindowNum)  Margins = AlertGList\Margins  LowBPos = WHeight - AlertGList\BHeight - Margins  YesNoCancel = AlertGList\YesNoCancel  ;  ResizeGadget(AlertGList\RE_gadget,  #PB_Ignore, #PB_Ignore, (WWidth - Margins * 2), (WHeight - AlertGList\BHeight - Margins * 3))  ;  ; Bouton occupant la position la plus à droite :  If IsGadget(AlertGList\BOK) And (YesNoCancel = #AW_AlertOnly Or YesNoCancel = #AW_OKOrCancel_OKByDefault)    ResizeGadget(AlertGList\BOK,        WWidth - AlertGList\BWidth - Margins,     LowBPos, #PB_Ignore, #PB_Ignore)  EndIf  If IsGadget(AlertGList\BYes) And (YesNoCancel = #AW_YesOrNo_YesByDefault Or YesNoCancel = #AW_YesNoOrCancel_YesByDefault)    ResizeGadget(AlertGList\BYes,       WWidth - AlertGList\BWidth - Margins,     LowBPos, #PB_Ignore, #PB_Ignore)  EndIf  If IsGadget(AlertGList\BNo) And (YesNoCancel = #AW_YesOrNo_NoByDefault Or YesNoCancel = #AW_YesNoOrCancel_NoByDefault)    ResizeGadget(AlertGList\BNo,        WWidth - AlertGList\BWidth - Margins,     LowBPos, #PB_Ignore, #PB_Ignore)  EndIf  If IsGadget(AlertGList\BCancel) And (YesNoCancel = #AW_OKOrCancel_CancelByDefault Or YesNoCancel = #AW_YesNoOrCancel_CancelByDefault)    ResizeGadget(AlertGList\BCancel,    WWidth - AlertGList\BWidth - Margins,     LowBPos, #PB_Ignore, #PB_Ignore)  EndIf  ;  ; Bouton occupant la deuxième position à partir de la droite  If IsGadget(AlertGList\BOK) And (YesNoCancel = #AW_OKOrCancel_CancelByDefault)    ResizeGadget(AlertGList\BOK,        WWidth - (AlertGList\BWidth + Margins) * 2, LowBPos, #PB_Ignore, #PB_Ignore)  EndIf  If IsGadget(AlertGList\BYes) And (YesNoCancel = #AW_YesOrNo_NoByDefault Or YesNoCancel = #AW_YesNoOrCancel_NoByDefault)    ResizeGadget(AlertGList\BYes,       WWidth - (AlertGList\BWidth + Margins) * 2, LowBPos, #PB_Ignore, #PB_Ignore)  EndIf  If IsGadget(AlertGList\BNo) And (YesNoCancel = #AW_YesOrNo_YesByDefault Or YesNoCancel = #AW_YesNoOrCancel_YesByDefault Or YesNoCancel = #AW_YesNoOrCancel_CancelByDefault)    ResizeGadget(AlertGList\BNo,        WWidth - (AlertGList\BWidth + Margins) * 2, LowBPos, #PB_Ignore, #PB_Ignore)  EndIf  If IsGadget(AlertGList\BCancel) And YesNoCancel = #AW_OKOrCancel_OKByDefault    ResizeGadget(AlertGList\BCancel,    WWidth - (AlertGList\BWidth + Margins) * 2, LowBPos, #PB_Ignore, #PB_Ignore)  EndIf  ;  ; Bouton occupant la troisième position à partir de la droite  If IsGadget(AlertGList\BYes) And YesNoCancel = #AW_YesNoOrCancel_CancelByDefault    ResizeGadget(AlertGList\BYes,       WWidth - (AlertGList\BWidth + Margins) * 3, LowBPos, #PB_Ignore, #PB_Ignore)  EndIf  If IsGadget(AlertGList\BCancel) And (YesNoCancel = #AW_YesNoOrCancel_YesByDefault Or YesNoCancel = #AW_YesNoOrCancel_NoByDefault)    ResizeGadget(AlertGList\BCancel,    WWidth - (AlertGList\BWidth + Margins) * 3, LowBPos, #PB_Ignore, #PB_Ignore)  EndIf  ;    If IsGadget(AlertGList\BCopy) And YesNoCancel = #AW_AlertOnly    ResizeGadget(AlertGList\BCopy,      WWidth - (AlertGList\BWidth + Margins) * 2, LowBPos, #PB_Ignore, #PB_Ignore)    ResizeGadget(AlertGList\BSave,      WWidth - (AlertGList\BWidth + Margins) * 3, LowBPos, #PB_Ignore, #PB_Ignore)    ResizeGadget(AlertGList\BSearch,    WWidth - (AlertGList\BWidth + Margins) * 4, LowBPos, #PB_Ignore, #PB_Ignore)    ;    If WWidth < (AlertGList\BWidth + Margins) * 3 + Margins      HideGadget(AlertGList\BCopy,   #True)      HideGadget(AlertGList\BSave,   #True)      HideGadget(AlertGList\BSearch, #True)    ElseIf WWidth < (AlertGList\BWidth + Margins) * 4 + Margins      HideGadget(AlertGList\BCopy,   #False)      HideGadget(AlertGList\BSave,   #False)      HideGadget(AlertGList\BSearch, #True)    Else      HideGadget(AlertGList\BCopy,   #False)      HideGadget(AlertGList\BSave,   #False)      ;      ; On décide arbitrairement que les textes dont la longeur est inférieure      ; à 160000 caractères n'ont pas besoin d'un outil de recherche.      If (GadgetWidth(AlertGList\RE_gadget) * GadgetHeight(AlertGList\RE_gadget)) < 160000        HideGadget(AlertGList\BSearch, #True)      Else        HideGadget(AlertGList\BSearch, #False)      EndIf    EndIf  EndIfEndProcedure;Enumeration AlertWShortcuts  #AW_Shortcut_Quit  #AW_Shortcut_DefButton  #AW_Shortcut_Search  #AW_Shortcut_SaveEndEnumeration;#RTF_Marker = 23675;Procedure THG(EventGadget, Gadget)  ; Test Hyphotetical GagdetEvent  If IsGadget(Gadget) And EventGadget = Gadget    ProcedureReturn #True  EndIfEndProcedure  ;Procedure Alert(Message$, *STextPointeur = 0, WSticky = 1, WhiteBackGround = 0, Txtleft = 0, FixedWidth = 0, TabList$ = "", YesNoCancel = #AW_AlertOnly)  ;  ; Displays the message 'Message$' in a window whose dimensions are optimized  ; according to the size of the message.  ;  ; The window also includes 'Copy All', 'Save', and for  ; large texts, a 'Search' button that allows searching  ; within the displayed text.  ;  ; *STextPointer normally points to a structure 'AlertWindowTitles' which contains the names  ; to be given to the buttons and the title to be assigned to the window.  ;  ; To simplify the use of this procedure, it is not mandatory to provide  ; this structure. '*STextPointer' can be omitted at the time of the call, or '*STextPointer'  ; can simply point to a string containing the title to be given to the window.  ;  ; If WhiteBackGround contains a non-zero value, the text background will be white instead of yellow.  ; If TxtLeft contains a non-zero value, the text will always be left-aligned.  ; If FixedWidth contains a non-zero value, the window width will conform to it.  ; TabList$ can contain a list of tab positions in the form "pos1,pos2,pos3"  ; YesNoCancel can contain one of the values from the 'AlertYesNoCancel' enumeration, in which case  ; the buttons 'Yes', 'No', or 'OK' and 'Cancel' will appear in the window.  ; You can also cheat and give different titles to these buttons by adjusting the values of *STextPointer.  ;  ; The return value can be #PB_MessageRequester_Yes, #PB_MessageRequester_No, or #PB_MessageRequester_Cancel  ;  Shared AlertGList.AlertWindowGList ; For sharing gadget numbers with the Resize procedure                                     ;  Static AlertText.AlertWindowTitles ; Stores the button texts and the window title  ;  Protected WWidth, WHeight, RTF  Protected TextSurf, TW.d, TH.d, ratio.f, SL  Protected WX, WY, scrollPos.Point  Protected EventID, QuitAll, NFile$  Protected *tabStops, PosInList, TabPos$  Protected *mem, BDefault  ;  Protected WindowTitle$ = ""  ;  If IsMemoryValid(*STextPointeur)    Protected *Test.AlertWindowTitles = *STextPointeur    If Not (IsMemoryValid(@*Test\WTitle$)) Or Not (IsMemoryValid(@*Test\BOK$)) Or Not (IsMemoryValid(@*Test\BSearch$)) Or Not (IsMemoryValid(@*Test\BCopy$)) Or Not (IsMemoryValid(@*Test\BSave$))      ; The memory addresses that should correspond to the fields of *Test.AlertWindowTitles are invalid.      ; This means that *STextPointeur does not point to an 'AlertWindowTitles' structure.      ; Since *STextPointeur is still a valid pointer, we assume it points      ; to a simple string containing the title of the window.      ;      ; We assign the value of the string to 'WindowTitle$'      If IsMemoryValid(@*Test\WTitle$)        WindowTitle$ = *Test\WTitle$      EndIf    Else      ; *Test appears to be a valid pointer to an 'AlertWindowTitles' structure.      ; However, we will not modify the values of this structure. We simply      ; copy them, provided they are populated.      ; Thus, if the user only wants to change one value, they can      ; leave the others empty.      If *Test\WTitle$  : AlertText\WTitle$   = *Test\WTitle$  : EndIf      If *Test\BOK$     : AlertText\BOK$      = *Test\BOK$     : EndIf      If *Test\BCancel$ : AlertText\BCancel$  = *Test\BCancel$ : EndIf      If *Test\BYes$    : AlertText\BYes$     = *Test\BYes$    : EndIf      If *Test\BNo$     : AlertText\BNo$      = *Test\BNo$     : EndIf      If *Test\BCopy$   : AlertText\BCopy$    = *Test\BCopy$   : EndIf      If *Test\BSave$   : AlertText\BSave$    = *Test\BSave$   : EndIf      If *Test\BSearch$ : AlertText\BSearch$  = *Test\BSearch$ : EndIf      If *Test\SaveAs$  : AlertText\SaveAs$   = *Test\SaveAs$  : EndIf      If *Test\TextFile$: AlertText\TextFile$ = *Test\TextFile$: EndIf      If *Test\SearchGadgets        CopyStructure(@*Test\SearchGadgets, @AlertText\SearchGadgets, REFR_GadgetsTitles)      EndIf    EndIf  EndIf  ;  ; The French version is preferred for the default values, because I use this procedure extensively  ; in all my programs, including those that are not intended to be translatable  ; into other languages.  ;  If AlertText\WTitle$ = ""  : AlertText\WTitle$ = "Attention"  : EndIf  If AlertText\BOK$ = ""     : AlertText\BOK$ = "OK"            : EndIf  If AlertText\BCancel$ = "" : AlertText\BCancel$ = "Cancel"   : EndIf  If AlertText\BYes$ = ""    : AlertText\BYes$ = "Yes"          : EndIf  If AlertText\BNo$ = ""     : AlertText\BNo$ = "No"           : EndIf  If AlertText\BCopy$ = ""   : AlertText\BCopy$ = "Copy All" : EndIf  If AlertText\BSave$ = ""   : AlertText\BSave$ = "Save" : EndIf  If AlertText\BSearch$ = "" : AlertText\BSearch$ = "Search"  : EndIf  If AlertText\SaveAs$ = ""  : AlertText\SaveAs$  = "Save as..."   : EndIf  If AlertText\TextFile$ = "" : AlertText\TextFile$ = "Text Files|*.txt" : EndIf  ;  ; AlertText now contains either the values passed or the default values.  ; We preserve the window title that might have been passed in *STextPointeur.  If WindowTitle$ = "" : WindowTitle$ = AlertText\WTitle$ : EndIf  ;  If Message$    WWidth = 300    If FixedWidth      WWidth = FixedWidth    EndIf    WHeight = 120    ;    If PeekC(@Message$) = #RTF_Marker      ; The text to be displayed comes from a saved RTF file.      RTF = 1    ElseIf Left(Message$, 5) = "{\rtf" Or Left(Message$, 6) = "{\urtf"      ; The text to be displayed is encoded in RTF.      RTF = 2    Else      RTF = 0    EndIf        AlertGList\WindowNum = OpenWindow(#PB_Any, 0, 0, WWidth, WHeight, WindowTitle$, #PB_Window_Invisible | #PB_Window_MinimizeGadget | #PB_Window_MaximizeGadget | #PB_Window_SystemMenu | #PB_Window_SizeGadget | #PB_Window_TitleBar | #PB_Window_ScreenCentered)    ;        If IsWindow(AlertGList\WindowNum)      WindowBounds(AlertGList\WindowNum, WWidth, WHeight, #PB_Ignore, #PB_Ignore)      CompilerIf Defined(ApplyDarkModeToWindow, #PB_Procedure)        ApplyDarkModeToWindow(AlertGList\WindowNum)      CompilerEndIf      ;      If WSticky        StickyWindow(AlertGList\WindowNum, 1)      EndIf      AlertGList\BHeight = 24      AlertGList\BWidth = 90      AlertGList\Margins = 8      AlertGList\YesNoCancel = YesNoCancel      ;      AlertGList\RE_gadget = EditorGadget(#PB_Any, AlertGList\Margins, AlertGList\Margins, 1, 1)      SendMessage_(GadgetID(AlertGList\RE_gadget), #EM_SETTARGETDEVICE, #Null, 0); <<--- automatic line break      SendMessage_(GadgetID(AlertGList\RE_gadget), #EM_LIMITTEXT, -1, 0)         ; set unlimited content size      SendMessage_(GadgetID(AlertGList\RE_gadget), #EM_SETTEXTMODE, #TM_RICHTEXT, 0) ; enable rich text mode for EditorGadget      If TabList$        RE_SetSelection(AlertGList\RE_gadget, 0, -1)        ; The 'TabList$' parameter contains the list of tab positions to place in the REgadget:        ; This list must have the form "pos1,pos2,pos3".        ; We will convert this list format into a series of WORD values,        ; stored in a memory area, in order to use it in a SendMessage_().        ;        ; We count the number of commas, adding 1, then multiply by 4        ; because the size of a WORD is 4 bytes:        *tabStops = AllocateMemory((CountString(TabList$, ",") + 1) * 4)        ;        PosInList = 0        Repeat          PosInList + 1          TabPos$ = StringField(TabList$, PosInList, ",")          If TabPos$            PokeW(*tabStops + 4 * (PosInList - 1), Val(TabPos$))          EndIf        Until TabPos$ = ""        SendMessage_(GadgetID(AlertGList\RE_gadget), #EM_SETTABSTOPS, CountString(TabList$, ",") + 1, *tabStops)        FreeMemory(*tabStops)      EndIf      ;      If RTF = 2        *mem = AllocateMemory(StringByteLength(Message$, #PB_UTF8) + 1)        PokeS(*mem, Message$, -1, #PB_UTF8) ; write the string in UTF8        ; then we read the string in Unicode and insert it into the Gadget        SendMessage_(GadgetID(AlertGList\RE_gadget), #EM_REPLACESEL, 0, PeekS(*mem, -1, #PB_Unicode))        FreeMemory(*mem)      Else        SendMessage_(GadgetID(AlertGList\RE_gadget), #EM_REPLACESEL, 0, @Message$)      EndIf      SendMessage_(GadgetID(AlertGList\RE_gadget), #EM_SETREADONLY, #True, 0)      ;      If YesNoCancel = #AW_AlertOnly Or YesNoCancel = #AW_OKOrCancel_OKByDefault Or YesNoCancel = #AW_OKOrCancel_CancelByDefault        If YesNoCancel = #AW_AlertOnly Or YesNoCancel = #AW_OKOrCancel_OKByDefault          BDefault = 1        Else          BDefault = 0        EndIf        AlertGList\BOK = ButtonGadget(#PB_Any, 1, 1, AlertGList\BWidth, AlertGList\BHeight, AlertText\BOK$, #PB_Button_Default * BDefault)      EndIf      If YesNoCancel = #AW_OKOrCancel_OKByDefault Or YesNoCancel = #AW_OKOrCancel_CancelByDefault Or YesNoCancel = #AW_YesNoOrCancel_YesByDefault Or YesNoCancel = #AW_YesNoOrCancel_NoByDefault Or YesNoCancel = #AW_YesNoOrCancel_CancelByDefault        If YesNoCancel = #AW_OKOrCancel_CancelByDefault Or YesNoCancel = #AW_YesNoOrCancel_CancelByDefault          BDefault = 1        Else          BDefault = 0        EndIf        AlertGList\BCancel = ButtonGadget(#PB_Any, 1, 1, AlertGList\BWidth, AlertGList\BHeight, AlertText\BCancel$, #PB_Button_Default * BDefault)      EndIf      If YesNoCancel = #AW_YesOrNo_YesByDefault Or YesNoCancel = #AW_YesOrNo_NoByDefault Or YesNoCancel = #AW_YesNoOrCancel_YesByDefault Or YesNoCancel = #AW_YesNoOrCancel_NoByDefault Or YesNoCancel = #AW_YesNoOrCancel_CancelByDefault        If YesNoCancel = #AW_YesOrNo_YesByDefault Or YesNoCancel = #AW_YesNoOrCancel_YesByDefault          BDefault = 1        Else          BDefault = 0        EndIf        AlertGList\BYes = ButtonGadget(#PB_Any, 1, 1, AlertGList\BWidth, AlertGList\BHeight, AlertText\BYes$, #PB_Button_Default * BDefault)        ;        If YesNoCancel = #AW_YesOrNo_NoByDefault Or YesNoCancel = #AW_YesNoOrCancel_NoByDefault          BDefault = 1        Else          BDefault = 0        EndIf        AlertGList\BNo  = ButtonGadget(#PB_Any, 1, 1, AlertGList\BWidth, AlertGList\BHeight, AlertText\BNo$, #PB_Button_Default * BDefault)      EndIf      If YesNoCancel = #AW_AlertOnly        AlertGList\BCopy   = ButtonGadget(#PB_Any, 1, 1, AlertGList\BWidth, AlertGList\BHeight, AlertText\BCopy$)        AlertGList\BSave   = ButtonGadget(#PB_Any, 1, 1, AlertGList\BWidth, AlertGList\BHeight, AlertText\BSave$)        AlertGList\BSearch = ButtonGadget(#PB_Any, 1, 1, AlertGList\BWidth, AlertGList\BHeight, AlertText\BSearch$)      EndIf      ;      ; If the message was in RTF, we get its plain text equivalent.      Message$ = ReplaceString(GetGadgetText(AlertGList\RE_gadget), Chr(10), "")      ;      ; We will attempt to resize the window based on      ; the size of the text.      ;      ; We calculate the display area required based on      ; the length of the text:      ; We retrieve the text dimensions:      RE_SetSelection(AlertGList\RE_gadget, 0, -1)      GetTextSurfPix(AlertGList\RE_gadget, Message$, @TW, @TH)      ; We calculate the display area and inflate it slightly by      ; multiplying by 1.2. The result is approximate because line breaks      ; are counted as regular characters, whereas they actually reduce the display area.      ; Also, if the message was in RTF and contains images, each image is counted as a single      ; character, even though the image may take up a lot of space.      ; This gives us an approximation.      Protected MonitorDPI.f = GetMonitorDPI(AlertGList\WindowNum)      If MonitorDPI = 0 : MonitorDPI = 1 : EndIf      TextSurf = TW * TH * 1.2 / MonitorDPI      ;      ;      If RTF = 0        ; Slight formatting for non-RTF text:        ;        If TextSurf < 50000 And Txtleft = 0 And TabList$ = ""          ; If the text is short, we center it.          Protected paraFormat.PARAFORMAT2          paraFormat\cbSize = SizeOf(PARAFORMAT2)          paraFormat\dwMask = #PFM_ALIGNMENT          paraFormat\wAlignment = #PFA_CENTER          SendMessage_(GadgetID(AlertGList\RE_gadget), #EM_SETPARAFORMAT, #SCF_SELECTION, @paraFormat)        EndIf        ;        ; We add small margins on the left and right,        ; so the text is not glued to the edges.        Protected format.PARAFORMAT        format\cbSize = SizeOf(PARAFORMAT)        format\dwMask = #PFM_RIGHTINDENT | #PFM_OFFSETINDENT        format\dxStartIndent = 100        format\dxRightIndent = 100        SendMessage_(GadgetID(AlertGList\RE_gadget), #EM_SETPARAFORMAT, #SCF_SELECTION, @format)        ;      EndIf      ;      AW_ComputeWidthAndHeightFromSurf:       ;      If FixedWidth        WWidth = FixedWidth        SL = 0      Else        If TextSurf = 0          ; This can happen on older Windows systems          TextSurf = 400 * 500        EndIf        ; We recalculate the window dimensions:        ; Since TextSurf is an area, we extract its square root        ; to get an idea of its side length.        WWidth = Sqr(TextSurf)        ;        ; We will now decide on a width/height ratio based on        ; the idea that smaller windows should be wider than        ; they are tall, and larger ones, taller than wide.        ratio = 1 + (800 - WWidth) / 1600        If ratio < 1          WWidth = 800        Else          WWidth * ratio * 1.2        EndIf        ;        SL = 0        ; We compare the calculated width to the screen limits        ; and readability constraints. When a window is too wide,        ; the text it contains is hard to read.        If WWidth > 800 : WWidth = 800 : EndIf        ;        ExamineDesktops()        ;        If WWidth > (DesktopWidth(0) / MonitorDPI - 300)          WWidth = DesktopWidth(0) / MonitorDPI - 300          SL = 1        EndIf      EndIf      ;      ; Height is equal to the surface divided by the width:      WHeight = TextSurf / WWidth      If WHeight > (DesktopHeight(0) / MonitorDPI - 200)        WHeight = DesktopHeight(0) / MonitorDPI - 200        SL = 1      EndIf      ; We calculate the center of the current screen:      WX = DesktopX(0) + DesktopWidth(0)  / 2      WY = DesktopY(0) + DesktopHeight(0) / 2      ; We calculate the X and Y origins of the window so that      ; it is centered on the screen:      WX / MonitorDPI - WWidth / 2      WY / MonitorDPI - WHeight / 2      ;      ResizeWindow(AlertGList\WindowNum, WX, WY, WWidth, WHeight)      ; We resize the gadgets based on the new window size      ResizeAlertWindow()      ;      If SL = 0        ; The calculated dimensions have not exceeded the screen limits        ; and we still have the possibility to enlarge the window if necessary.        ; We will check if the window scrollbar has activated, which        ; would mean that the current dimensions are insufficient to        ; display all the text.        ;        ; We position at the end of the selection to position the scrollbar:        RE_SetSelection(AlertGList\RE_gadget, -1, -1)        SendMessage_(GadgetID(AlertGList\RE_gadget), #EM_GETSCROLLPOS, 0, @scrollPos)        If scrollPos\y          ; The scrollbar has been activated.          ; We enlarge the previously estimated surface          ; by adding a line height multiplied by the window width.          TextSurf + TH * WWidth          Goto AW_ComputeWidthAndHeightFromSurf        EndIf      EndIf      ;      ; The window size calculation is complete.      ;      ; Clear the selection:      RE_SetSelection(AlertGList\RE_gadget, 0, 0)      ;      *GadgetAdress = @AlertGList\RE_gadget      Repeat        GadgetList$ + Str(PeekI(*GadgetAdress)) + ","        *GadgetAdress + SizeOf(Integer)      Until *GadgetAdress > @AlertGList\BSave      ;      ApplyFontToGadgetList(GadgetList$)      ;      ; ---------------------------------------------------      ; Apply color theme if it exists:      ;      ;      CompilerIf Defined(SetGadgetsColorsFromTheme, #PB_Procedure)        ;        If ListSize(InterfaceColorPresets()) > 0          SetGadgetsColorsFromTheme(AlertGList\WindowNum, InterfaceColorPresets(), GadgetList$)          If InterfaceColorPresets()\BackgroundColor <> -1            WhiteBackGround = 1          EndIf        EndIf        ;      CompilerEndIf      ;      ; ---------------------------------------------------      ;      If WhiteBackGround = 0        SetGadgetColor(AlertGList\RE_gadget, #PB_Gadget_BackColor, $F0FDFD)      EndIf      ;      ; The window was invisible until now, because we created it with #PB_Window_Invisible.      ; We make it visible now.      HideWindow(AlertGList\WindowNum, #False)      ;      ; If despite all the effort we've put in, the user wants to resize      ; the window themselves, we give them the option:      BindEvent(#PB_Event_SizeWindow, @ResizeAlertWindow(), AlertGList\WindowNum)      ;      AddKeyboardShortcut(AlertGList\WindowNum, #PB_Shortcut_Return, #AW_Shortcut_DefButton)      AddKeyboardShortcut(AlertGList\WindowNum, #PB_Shortcut_Escape, #AW_Shortcut_Quit)      AddKeyboardShortcut(AlertGList\WindowNum, #PB_Shortcut_Control | #PB_Shortcut_F, #AW_Shortcut_Search)      AddKeyboardShortcut(AlertGList\WindowNum, #PB_Shortcut_Control | #PB_Shortcut_S, #AW_Shortcut_Save)      ;      ClearKeyboardBuffer(AlertGList\WindowNum)      ;      ;      Repeat        EventID = WaitWindowEvent()        If EventWindow() <> AlertGList\WindowNum And WSticky          SetActiveWindow(AlertGList\WindowNum)        Else          If EventID = #PB_Event_Gadget            EventGadget = EventGadget()          ElseIf EventID = #PB_Event_CloseWindow            QuitAll = #PB_MessageRequester_Cancel          ElseIf EventID = #PB_Event_Menu            If EventMenu() = #AW_Shortcut_Quit              QuitAll = #PB_MessageRequester_Cancel            ElseIf EventMenu() =   #AW_Shortcut_DefButton              If YesNoCancel = #AW_YesOrNo_YesByDefault Or YesNoCancel = #AW_YesNoOrCancel_YesByDefault Or YesNoCancel = #AW_OKOrCancel_OKByDefault                QuitAll = #PB_MessageRequester_Yes              ElseIf YesNoCancel = #AW_YesOrNo_NoByDefault Or YesNoCancel = #AW_YesNoOrCancel_NoByDefault                QuitAll = #PB_MessageRequester_No              Else                QuitAll = #PB_MessageRequester_Cancel              EndIf            ElseIf EventMenu() = #AW_Shortcut_Search              EventID = #PB_Event_Gadget              EventGadget = AlertGList\BSearch            ElseIf EventMenu() = #AW_Shortcut_Save              EventID = #PB_Event_Gadget              EventGadget = AlertGList\BSave            EndIf          EndIf          If EventID = #PB_Event_Gadget            If THG(EventGadget, AlertGList\BOK) Or THG(EventGadget, AlertGList\BYes)              QuitAll = #PB_MessageRequester_Yes            ElseIf THG(EventGadget, AlertGList\BCancel)              QuitAll = #PB_MessageRequester_Cancel            ElseIf THG(EventGadget, AlertGList\BNo)              QuitAll = #PB_MessageRequester_No            ElseIf THG(EventGadget, AlertGList\BSearch)              RE_FindReplace(AlertGList\RE_gadget, 0, AlertText\SearchGadgets)            ElseIf THG(EventGadget, AlertGList\BCopy)              SetClipboardText(RE_GetGadgetWholeText(AlertGList\RE_gadget))              RE_SetSelection(AlertGList\RE_gadget, 0, -1)            ElseIf THG(EventGadget, AlertGList\BSave)              NFile$ = SaveFileRequester(AlertText\SaveAs$, "", AlertText\TextFile$, 1)              If NFile$                If GetExtensionPart(NFile$) <> "txt" : NFile$ + ".txt" : EndIf                RE_SaveContent(AlertGList\RE_gadget, NFile$, 0)              EndIf            EndIf          EndIf        EndIf      Until QuitAll    EndIf    If IsWindow(AlertGList\WindowNum)      ClearKeyboardBuffer(AlertGList\WindowNum)      CloseWindow(AlertGList\WindowNum)    EndIf  EndIf  ProcedureReturn QuitAllEndProcedure; Procedure AlertWithTitle(Message$, Title$, WSticky = 1, WhiteBackGround = 0, Txtleft = 0, FixedWidth = 0, TabList$ = "", YesNoCancel = #AW_AlertOnly)  ; Appelle la procédure 'Alert()' en lui fournissant un titre de fenêtre.  ; Ce titre ne modifiera pas le titre pas défaut de la fenêtre Alert().  Protected Temp.AlertWindowTitles\WTitle$ = Title$  ProcedureReturn Alert(Message$, Temp, WSticky, WhiteBackGround, Txtleft, FixedWidth, TabList$, YesNoCancel)EndProcedure;Procedure AlertYesNoCancel(Message$, Title$ = "", Type = #AW_YesOrNo_YesByDefault)  ;  ; Type peut prendre l'une des valeurs suivantes :  ; #AW_AlertOnly  ; #AW_YesOrNo_YesByDefault  ; #AW_YesOrNo_NoByDefault  ; #AW_OKOrCancel_OKByDefault  ; #AW_OKOrCancel_CancelByDefault  ; #AW_YesNoOrCancel_YesByDefault  ; #AW_YesNoOrCancel_NoByDefault  ; #AW_YesNoOrCancel_CancelByDefault  ;  ; Les valeurs de retour possibles sont :  ; #PB_MessageRequester_Yes  ; #PB_MessageRequester_No  ; #PB_MessageRequester_Cancel  Protected Temp.AlertWindowTitles\WTitle$ = Title$  ProcedureReturn Alert(Message$, Temp, 1, 0, 0, 0, "", Type)EndProcedure;Procedure InitAlertTexts()  ;  ;         Pour avoir une version française des textes, il suffit de  ;              désactiver la ligne 'InitAlertTexts()' qui figure  ;                       juste après cette procédure.  ;  Protected AlertText.AlertWindowTitles  ;  ;         Initialization of button texts and window title  ;                   for the 'Alert()' procedure.  ;         By default, the button texts are in French. This  ;       procedure is intended to translate them into English.  ;  ;         To have a German version or another language  ;      simply translate the list of texts that appear below:  ;  AlertText\WTitle$  = "Attention"  AlertText\BOK$     = "OK"  AlertText\BCancel$ = "Cancel"  AlertText\BYes$    = "Yes"  AlertText\BNo$     = "No"  AlertText\BCopy$   = "Copy All"  AlertText\BSearch$ = "Search"  AlertText\BSave$   = "Save"  AlertText\SaveAs$  = "Save as"  AlertText\TextFile$ = "TextFile"  AlertText\SearchGadgets\WTitle$ =       "Search"  AlertText\SearchGadgets\Search$ =       "Search:"  AlertText\SearchGadgets\ReplaceTitle$ = "Replace with:"  AlertText\SearchGadgets\Replace$ =      "Replace"  AlertText\SearchGadgets\ReplaceAll$ =   "Replace all"  AlertText\SearchGadgets\Quit$ =         "Quit"  AlertText\SearchGadgets\CaseSensitive$ = "Case sensitive"  AlertText\SearchGadgets\WholeWord$ =    "Whole word"  AlertText\SearchGadgets\InAllDocument$ = "In the entire document"  AlertText\SearchGadgets\UnableToFind$ = "Unable to find"  AlertText\SearchGadgets\ReplacementMade$ = "replacement(s) made."  AlertText\SearchGadgets\SearchFromStart$ = "Search from the end?"  AlertText\SearchGadgets\SearchFromEnd$ =   "Search from the beginning?"  ;  Alert("", AlertText) ; Initialize the names to be used  ; Since no text was provided in the first argument, this call  ; will have no other effect.EndProcedure;InitAlertTexts();;; *************************************************************************************CompilerIf #PB_Compiler_IsMainFile  ; The following won't run when this file is used as 'Included'.  ;  Alert("This a simple message.")  ;  tx$ = "{\rtf1\ansi\ansicpg1252\deff0\nouicompat\deflang1036{\fonttbl{\f0\fnil\fcharset0 Bauhaus 93;}{\f1\fnil\fcharset0 Calibri;}}" + Chr(13)  tx$ + "{\colortbl ;\red192\green80\blue77;}" + Chr(13)  tx$ + "{\*\generator Riched20 10.0.19041}\viewkind4\uc1 " + Chr(13)  tx$ + "\pard\sa200\sl276\slmult1\f0\fs22\lang12 Demonstration \f1\fs28 text \fs22 in \cf1\b\fs28 RTF \cf0\b0\fs22 format.\par" + Chr(13)  tx$ + "}"  Alert(tx$)    ;  tx$ = "This example shows how the 'Alert()' function window is able to automatically resize itself so that it can display "  tx$ + "text of any length without the need to rewrite code each time you need to display a message of particular length." + Chr(13)  tx$ + "There is no limit to the size of the message you can include here." + Chr(13)  tx$ + "The size of the window will be increased as much as possible, then a scrollbar will appear to the right of the text box,"  tx$ + " if the message is too large to fit entirely in the window."  Alert(tx$)  ;  tx$ + Chr(13) + tx$ + Chr(13) + tx$ + Chr(13) + tx$ + Chr(13) + tx$ + Chr(13) + tx$ + Chr(13) + tx$ + Chr(13)  tx$ + Chr(13) + tx$ + Chr(13) + tx$ + Chr(13) + tx$ + Chr(13) + tx$ + Chr(13) + tx$ + Chr(13) + tx$ + Chr(13)  tx$ = "When the printed text is really large, a “search” button automatically appears to allow a search within the text."   + Chr(13) + Chr(13) + Chr(13) + Chr(13) + tx$  Alert(tx$)  ;  tx$ = "A variant of the Alert() function, named AlertYesNoCancel() is intended to replace MessageRequester() with the parameters #PB_MessageRequester_YesNo or #PB_MessageRequester_YesNoCancel." + Chr(13)  tx$ + "It offers exactly the same flexibility As the 'Alert()' function."  AlertYesNoCancel(tx$, "Demonstration")  ;  tx$ + Chr(13) + Chr(13) + "Possible parameters for this variant are:" + Chr(13)  tx$ + "  #AW_AlertOnly" + Chr(13)  tx$ + "  #AW_YesOrNo_YesByDefault" + Chr(13)  tx$ + "  #AW_YesOrNo_NoByDefault" + Chr(13)  tx$ + "  #AW_OKOrCancel_OKByDefault" + Chr(13)  tx$ + "  #AW_OKOrCancel_CancelByDefault" + Chr(13)  tx$ + "  #AW_YesNoOrCancel_YesByDefault" + Chr(13)  tx$ + "  #AW_YesNoOrCancel_NoByDefault" + Chr(13)  tx$ + "  #AW_YesNoOrCancel_CancelByDefault" + Chr(13) + Chr(13)  tx$ + "Here is an exemple of result with #AW_YesNoOrCancel_CancelByDefault" + Chr(13) + Chr(13)  tx$ + "The return values are the same as those of the MessageRequester function." + Chr(13)  AlertYesNoCancel(tx$, "Demonstration", #AW_YesNoOrCancel_CancelByDefault)CompilerEndIf; IDE Options = PureBasic 6.12 LTS (Windows - x86); CursorPosition = 14; Folding = -f--; EnableXP; DPIAware