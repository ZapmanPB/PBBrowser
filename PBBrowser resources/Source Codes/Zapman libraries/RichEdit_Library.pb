;*********************************************;              RichEdit_Library;*********************************************;; Cette collection de fonctions a été collectée sur le forum PureBasic;; Remarque à propos des fonctions qui suivent :; Pour Windows, la position dans un Text$ commence à 0, alors que pour PureBasic, elle commence à 1; Les fonctions de la librairie Gadget respecte la logique de Windows.; Il faudra donc ajuster les valeurs retournées, si vous vous les utiliser dans un Mid(), par exemple.; Exemple concret : pour obtenir la chaîne sélectionnée dans le Gadget, vous devez faire :;       RE_GetSelection(NoGadget,@txtrange);       txt$ = Mid(StrRef$,txtrange\cpMin+1,txtrange\cpMax-txtrange\cpMin);     en suposant que le Gadget concerné contient une copie de la chaîne StrRef$;XIncludeFile "Alert.pb";Procedure.b RE_ReadBin(Valeur, Position)  ; Permet de lire un byte à la position   If Valeur & (%1 << Position)    ProcedureReturn 1  Else    ProcedureReturn 0  EndIfEndProcedure;Procedure RE_GetCursorPosition(Gadget)  Protected pos1, pos2  ;  SendMessage_(GadgetID(Gadget), #EM_GETSEL, @pos1, @pos2)  ProcedureReturn pos1EndProcedure;Procedure RE_SetReadOnly(Gadget, YesNo)  If YesNo : YesNo = 1 : EndIf  SendMessage_(GadgetID(Gadget), #EM_SETREADONLY, YesNo, 0)EndProcedure;Procedure RE_SetContent(Gadget, Content$)  ProcedureReturn SendMessage_(GadgetID(Gadget), #WM_SETTEXT, 0, @Content$)EndProcedure;Procedure.l RE_StreamFileInCallback(dwCookie, pbBuff, cb, pcb)  Protected result, length  result = 0  length = ReadData(dwCookie, pbBuff, cb)  PokeL(pcb, length)  If length = 0    result = 1  EndIf  ProcedureReturn resultEndProcedure;Procedure RE_LoadContent(Gadget, FileName$)  If FileName$  <> ""    Protected edstr.EDITSTREAM    edstr\dwCookie = ReadFile(#PB_Any, FileName$, #PB_File_SharedRead | #PB_File_SharedWrite)    If edstr\dwCookie      edstr\dwError = 0      edstr\pfnCallback = @RE_StreamFileInCallback()      SendMessage_(GadgetID(Gadget), #EM_STREAMIN, #SF_RTF, edstr)      CloseFile(edstr\dwCookie)      ProcedureReturn edstr\dwError    Else      ProcedureReturn 1    EndIf  EndIfEndProcedure;Procedure.s RE_GetContent(Gadget)  Protected textLength, buffer.s  textLength = SendMessage_(GadgetID(Gadget), #WM_GETTEXTLENGTH, 0, 0) + 1  buffer = Space(textLength)  SendMessage_(GadgetID(Gadget), #WM_GETTEXT, textLength, @buffer)  ProcedureReturn bufferEndProcedure;Procedure RE_GetSelection_Effect(Gadget)     Protected format.CHARFORMAT     format\cbSize = SizeOf(CHARFORMAT)   format\dwMask = #CFM_BOLD   SendMessage_(GadgetID(Gadget), #EM_GETCHARFORMAT, #SCF_SELECTION, @format)  ProcedureReturn format\dwEffectsEndProcedure;Procedure.f RE_GetSelection_Size(Gadget)     Protected format.CHARFORMAT     format\cbSize = SizeOf(CHARFORMAT)  format\dwMask = #CFM_SIZE    SendMessage_(GadgetID(Gadget), #EM_GETCHARFORMAT, #SCF_SELECTION, @format)  ProcedureReturn format\yHeight / 20EndProcedure;Procedure RE_GetSelection_Color(Gadget)     Protected format.CHARFORMAT     format\cbSize = SizeOf(CHARFORMAT)   format\dwMask = #CFM_COLOR   SendMessage_(GadgetID(Gadget), #EM_GETCHARFORMAT, #SCF_SELECTION, @format)  ProcedureReturn format\crTextColorEndProcedure ;#AllEffects = #CFE_BOLD | #CFE_ITALIC | #CFE_UNDERLINE | #CFE_STRIKEOUT | #CFE_PROTECTED | #CFE_LINK | #CFE_AUTOCOLOR | #CFE_SUBSCRIPT | #CFE_SUPERSCRIPT;Procedure RE_SetSelection_Effect(Gadget, effect, YesNo)  ;  Protected format.CHARFORMAT  ;  If YesNo : YesNo = 1 : EndIf  ;  format\cbSize = SizeOf(CHARFORMAT)   format\dwMask = effect  format\dwEffects = YesNo * effect  ProcedureReturn SendMessage_(GadgetID(Gadget), #EM_SETCHARFORMAT, #SCF_SELECTION, @format) EndProcedure;Procedure RE_IsSelection_Bold(Gadget)  ProcedureReturn RE_ReadBin(RE_GetSelection_Effect(Gadget), 0)EndProcedure;Procedure RE_IsSelection_Ital(Gadget)  ProcedureReturn RE_ReadBin(RE_GetSelection_Effect(Gadget), 1)EndProcedure;Procedure RE_IsSelection_Underline(Gadget)  Protected Effect = RE_GetSelection_Effect(Gadget)  ProcedureReturn Effect & #CFE_UNDERLINEEndProcedure;Procedure RE_SetSelection_Bold(Gadget, YesNo = #True)  ProcedureReturn RE_SetSelection_Effect(Gadget, #CFE_BOLD, YesNo)EndProcedure;Procedure RE_SetSelection_Ital(Gadget, YesNo = #True)  ProcedureReturn RE_SetSelection_Effect(Gadget, #CFE_ITALIC, YesNo)EndProcedure;Procedure RE_SetSelection_Underline(Gadget, YesNo = #True)  ProcedureReturn RE_SetSelection_Effect(Gadget, #CFE_UNDERLINE, YesNo)EndProcedure;Procedure RE_SetSelection_WaveUnderLine(Gadget, YesNo)  ;  Protected format.CHARFORMAT2   ;  If YesNo : YesNo = 1 : EndIf  ;  format\cbSize = SizeOf(CHARFORMAT2)   format\dwMask = #CFM_UNDERLINE | #CFM_UNDERLINETYPE    format\dwEffects = #CFE_UNDERLINE * YesNo  format\bUnderlineType = #CFU_UNDERLINEWAVE * YesNo ; Définit le style de soulignement en Wave    ProcedureReturn SendMessage_(GadgetID(Gadget), #EM_SETCHARFORMAT, #SCF_SELECTION, @format) EndProcedure;Procedure RE_SetSelection_Font(Gadget, FontName.s)  ;  Protected format.CHARFORMAT  ;  format\cbSize = SizeOf(CHARFORMAT)  format\dwMask = #CFM_FACE  PokeS(@format\szFaceName, FontName)  ProcedureReturn SendMessage_(GadgetID(Gadget), #EM_SETCHARFORMAT, #SCF_SELECTION, @format)EndProcedure;Procedure RE_SetSelection_Color(Gadget, Color)   ;  Protected format.CHARFORMAT  ;  format\cbSize = SizeOf(CHARFORMAT)   format\dwMask = #CFM_COLOR   format\crTextColor = Color   ProcedureReturn SendMessage_(GadgetID(Gadget), #EM_SETCHARFORMAT, #SCF_SELECTION, @format) EndProcedure ;Procedure RE_SetSelection_Size(Gadget, Taille.f)   ;  Protected format.CHARFORMAT  ;    ;  format\cbSize = SizeOf(CHARFORMAT)  format\yHeight = Round(Taille * 20, #PB_Round_Nearest)  format\dwMask = #CFM_SIZE    ProcedureReturn SendMessage_(GadgetID(Gadget), #EM_SETCHARFORMAT, #SCF_SELECTION, @format) EndProcedure ;Procedure RE_SetSelection_interpara(gadget.i, interpara)  ;  Protected format.PARAFORMAT2  ;  format\cbSize = SizeOf(PARAFORMAT2)   format\dwMask = #PFM_SPACEAFTER  format\dySpaceAfter = interpara  ProcedureReturn SendMessage_(GadgetID(Gadget), #EM_SETPARAFORMAT, #SCF_SELECTION, @format) EndProcedure;Procedure RE_SetSelection_paraValue(Gadget, Mask$, Value)  ;  Mask$ = LCase(Mask$)  ;  Protected format.PARAFORMAT  ;  format\cbSize = SizeOf(PARAFORMAT)  If FindString(Mask$, "right", -1, #PB_String_NoCase)    format\dwMask = #PFM_RIGHTINDENT    format\dxRightIndent = Value  ElseIf FindString(Mask$, "left", -1, #PB_String_NoCase) Or (FindString(Mask$, "offset", -1, #PB_String_NoCase) And FindString(Mask$, "indent", -1, #PB_String_NoCase))    format\dwMask = #PFM_OFFSETINDENT    format\dxStartIndent = Value  ElseIf FindString(Mask$, "align", -1, #PB_String_NoCase)    format\dwMask = #PFM_ALIGNMENT    format\wAlignment = Value  ElseIf FindString(Mask$, "offset", -1, #PB_String_NoCase)    format\dwMask = #PFM_OFFSET    format\dxOffset = Value  ElseIf Mask$ = "numbering"    format\dwMask = #PFM_NUMBERING    format\wNumbering  = Value  ElseIf FindString(Mask$, "start", -1, #PB_String_NoCase) And FindString(Mask$, "indent", -1, #PB_String_NoCase)    format\dwMask = #PFM_STARTINDENT    format\dxStartIndent  = Value  EndIf  ProcedureReturn SendMessage_(GadgetID(Gadget), #EM_SETPARAFORMAT, #SCF_SELECTION, @format)EndProcedure;Procedure RE_SetJustify(Gadget, JMode$)  ; Structure to set paragraph format  Protected paraFormat.PARAFORMAT2  ;  #PFA_JUSTIFY = 4  SendMessage_(GadgetID(Gadget), #EM_SETTEXTMODE, #TM_RICHTEXT, 0)  ;  ; Set structure size  paraFormat\cbSize = SizeOf(PARAFORMAT2)  ; Mask specifying which attributes to set  paraFormat\dwMask = #PFM_ALIGNMENT  ;  If FindString(LCase(JMode$), "left")    paraFormat\wAlignment = #PFA_LEFT  ElseIf FindString(LCase(JMode$), "right")    paraFormat\wAlignment = #PFA_RIGHT  ElseIf FindString(LCase(JMode$), "center")    paraFormat\wAlignment = #PFA_CENTER  ElseIf FindString(LCase(JMode$), "justify")    paraFormat\wAlignment = #PFA_JUSTIFY  EndIf  ;  SendMessage_(GadgetID(Gadget), #EM_SETPARAFORMAT, 0, @paraFormat)EndProcedure;Procedure RE_SetSelection_paraReset(Gadget)  ;  RE_SetSelection(Gadget, 0, -1)  RE_SetSelection_Color(Gadget, 0)  RE_SetJustify(Gadget, "left")  RE_SetSelection_interpara(Gadget, 0)  ;  Protected format.PARAFORMAT  ;  format\cbSize = SizeOf(PARAFORMAT)   format\dwMask = #PFM_RIGHTINDENT | #PFM_OFFSETINDENT | #PFM_ALIGNMENT | #PFM_OFFSET | #PFM_NUMBERING | #PFM_STARTINDENT  format\dxRightIndent = 0  format\dxStartIndent = 0  format\wAlignment = 0  format\dxOffset = 0  format\wNumbering  = 0  format\dxStartIndent  = 0  ProcedureReturn SendMessage_(GadgetID(Gadget), #EM_SETPARAFORMAT, #SCF_SELECTION, @format) EndProcedure;Procedure RE_SuspendRedraw(Gadget, YesNo = #True)  ;  ; Suspend Gadget content's redrawing for a while,  ; or retablish content's redrawing.  ; This is usefull to change Gadget's content without  ; multiple scrollings.  ;  Protected Redraw  Static ReadOnly = #False  ;  If YesNo = 0 : Redraw = #True : Else : Redraw = #False : EndIf  SendMessage_(GadgetID(Gadget), #WM_SETREDRAW, Redraw, 0)  ;  If Redraw = #False    ; Because we suppose that redrawing is suspended for content modifications    ; we'll allow them, but, first, we memorize ReadOnly state of the Gadget:    ReadOnly = SendMessage_(GadgetID(Gadget), #EM_GETOPTIONS, 0, 0) & #ECO_READONLY    ; Now, set the Gadget to READONLY/#False (allows modifications)    SendMessage_(GadgetID(Gadget), #EM_SETREADONLY, #False, 0)  Else    RedrawWindow_(GadgetID(Gadget), 0, 0, #RDW_ERASE | #RDW_INVALIDATE | #RDW_UPDATENOW)    SendMessage_(GadgetID(Gadget), #EM_SETREADONLY, ReadOnly, 0)  EndIfEndProcedure;Procedure RE_SelectAll(Gadget)  ProcedureReturn RE_SetSelection(Gadget, 0, -1)EndProcedure;Procedure.i RE_HideSelection(Gadget, YesNo = #True); Description .......:  Sets wheter the selection mark is visible.; Parameter(s) ......:  YesNo - #True to Hide, #False to Unhide  ProcedureReturn  SendMessage_(GadgetID(Gadget), #EM_HIDESELECTION, YesNo, 0)EndProcedure;Procedure RE_Copy(Gadget)  SendMessage_(GadgetID(Gadget), #WM_COPY, 0, 0)EndProcedure;Procedure RE_Paste(Gadget)  SendMessage_(GadgetID(Gadget), #WM_PASTE, 0, 0)EndProcedure;Procedure RE_InsertImage(Gadget, img, marker$ = "")  ;  ; Uses Clipboard as a shuttle to insert image in Gadget  ;  Protected KeepImg , KeepTxt$  ;  KeepImg = GetClipboardImage(#PB_Any) ; Keep a copy of existing clipboard content  KeepTxt$ = GetClipboardText()  ;  While OpenClipboard_(0) = 0 : Delay(1) : Wend  EmptyClipboard_()  SetClipboardImage(img)  CloseClipboard_()  ;  RE_Paste(Gadget)  If marker$    marker$ = "{\rtf1\v " + marker$ + "}"    SendMessage_(GadgetID(Gadget), #EM_REPLACESEL, #False, @marker$)  EndIf  ;  ; Restore clipboard content  SetClipboardImage(KeepImg)  If KeepTxt$    SetClipboardText(KeepTxt$)  EndIfEndProcedure;Procedure RE_InsertJPGImageFromFile(Gadget, FileAdr$, marker$ = "")  Protected img  UseJPEGImageDecoder()  img = LoadImage(#PB_Any, FileAdr$)  If img    RE_InsertImage(Gadget, img, marker$)  Else    MessageRequester("Oops!", "Can't load image!" + FileAdr$)  EndIfEndProcedure;Procedure RE_GetEndSelectPos(Gadget)Protected  pos1, pos2 ; ********* Added by PPBrowser.  SendMessage_(GadgetID(Gadget), #EM_GETSEL, @pos1, @pos2)  ProcedureReturn pos2EndProcedure ;Procedure RE_InsertTextAtCurrentPos(Gadget, Text$)   ProcedureReturn SendMessage_(GadgetID(Gadget), #EM_REPLACESEL, 0, Text$) EndProcedure;Procedure RE_InsertRTFTextAtCurrentPos(Gadget, Text$)  ;  Protected *mem, charr.CHARRANGE  ;  If Left(Text$, 6) = "{\rtf1" Or Left(Text$, 6) = "{\urtf"    *mem = AllocateMemory(StringByteLength(Text$, #PB_UTF8) + 1)    PokeS(*mem, Text$, -1, #PB_UTF8) ; on écrit la chaine en UTF8    RE_InsertTextAtCurrentPos(Gadget, PeekS(*mem, -1, #PB_Unicode)) ; on relit la chaine en Unicode et on l'insert dans le Gadget    FreeMemory(*mem)  Else    If Text$      RE_InsertTextAtCurrentPos(Gadget, Text$)    EndIf  EndIf  charr\cpMin = -1 ;  début de la sélection.   charr\cpMax = -1 ; fin de la sélection  ProcedureReturn SendMessage_(GadgetID(Gadget), #EM_EXSETSEL, 0, @charr);EndProcedure;Procedure RE_SetTextBackColor(Gadget, Color)  #CFM_BACKCOLOR = $4000000  Protected format.CHARFORMAT2  format\cbSize = SizeOf(CHARFORMAT2)  format\dwMask = #CFM_BACKCOLOR  format\crBackColor = Color  ProcedureReturn SendMessage_(GadgetID(Gadget), #EM_SETCHARFORMAT, #SCF_SELECTION, @format)  EndProcedure;Procedure RE_GetTextBackColor(Gadget)  #CFM_BACKCOLOR = $4000000  Protected format.CHARFORMAT2  format\cbSize = SizeOf(CHARFORMAT2)  format\dwMask = #CFM_BACKCOLOR  SendMessage_(GadgetID(Gadget), #EM_GETCHARFORMAT, #SCF_SELECTION, @format)  ProcedureReturn format\crBackColorEndProcedure;Procedure RE_AdjustZoom(NoGadget, AdjFactor)  ;  Protected num.l, denom.l, Factor.f  ;  ; Obtenir le niveau de zoom actuel  SendMessage_(GadgetID(NoGadget), #EM_GETZOOM, @num, @denom)  ; Calculer le nouveau niveau de zoom  If num And denom    Factor = num / denom  Else    Factor = 1  EndIf  ;  If AdjFactor    Factor * (AdjFactor + 100) / 100  Else    Factor = 1  EndIf  ;  denom = 10  num = denom * Factor  ;  ; Mettre à jour le niveau de zoom  SendMessage_(GadgetID(NoGadget), #EM_SETZOOM, num, denom)EndProcedure;; IDE Options = PureBasic 6.12 LTS (Windows - x86); CursorPosition = 333; FirstLine = 259; Folding = uB--48-; EnableXP; EnableUnicode