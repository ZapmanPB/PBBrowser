; *********************************************************************;;                General functions for Zapman softwares;                     Last Update: 04 oct. 2024;; *********************************************************************;XIncludeFile "Alert.pb";Global FileListing$ ; Pour 'ListFiles()'                    ;CompilerIf Not Defined(GetWinErrorMessage, #PB_Procedure)  Procedure.s GetWinErrorMessage(errorCode)    ;    ; Retourne un texte qui explicite l'erreur dont le numéro    ; est passé dans le paramètre 'errorCode'.    :     Protected messageBuffer$ = Space(256) ; Buffer pour le message    Protected messageLength      messageLength = FormatMessage_(#FORMAT_MESSAGE_FROM_SYSTEM | #FORMAT_MESSAGE_IGNORE_INSERTS, #Null, errorCode, 0, @messageBuffer$, 256, #Null)        If messageLength > 0      ; Supprime les retours à la ligne à la fin du message      messageBuffer$ = ReplaceString(messageBuffer$, Chr(10), "")      messageBuffer$ = ReplaceString(messageBuffer$, Chr(13), "")      messageBuffer$ = Trim(messageBuffer$)    Else      messageBuffer$ = "Unknown error code:"    EndIf    ProcedureReturn messageBuffer$ + "  ($" + Hex(errorCode) + ")"  EndProcedureCompilerEndIf;Procedure ReadFileWithPatience(numFile, FileName$)  ; Il arrive que DropBox ou d'autres logiciels  ; de synchronisation bloquent momentanément les  ; fichiers récemment modifiés en lecture.  ; En cas d'échec à l'ouverture d'un fichier,  ; cette procédure va tenter de réitérer la  ; tentative.  ;  Protected ct, noFile  ;  If FileSize(FileName$) > 2    For ct = 1 To 20      noFile = ReadFile(numFile, FileName$, #PB_File_SharedRead | #PB_File_SharedWrite)      If noFile = 0        Delay(100)      Else        Break      EndIf    Next  EndIf  ProcedureReturn noFileEndProcedure;Procedure.s GetTextFromCatalog(SName$, FileName$ = "")  ;  ; Get a text line from a '.catalog' language file.  ;  Static mCatalogContent$, mFileName$  ;  Protected fsize, noFile, CatalogContent$, FString$  Protected pos, posf  ;  If FileName$ : mFileName$ = FileName$  Else    FileName$ = mFileName$    CatalogContent$ = mCatalogContent$  EndIf  ;  If FileSize(FileName$) < 2    MessageRequester("Oops!", "GetTextFromCatalog(): Catalog FileName is wrong Or Catalog is missing!" + Chr(13) + FileName$)    ProcedureReturn ""  EndIf  ;  If Left(SName$, 5) = "file:"    ; Le paramètre SName$ contient un nom de fichier.    ;    FileName$ = GetPathPart(FileName$) + Mid(SName$, 6)    If ReadFileWithPatience(0, FileName$)      fsize = Lof(0)      If fsize > 0        FString$ = Space(fsize)        ReadData(0, @FString$, fsize)      EndIf      CloseFile(0)      ProcedureReturn FString$    Else      MessageRequester("Oops!", "GetTextFromCatalog(): Unable to read the file!" + Chr(13) + FileName$)      ProcedureReturn ""    EndIf  Else    ; Le paramètre SName$ contient un nom de chaîne.    ;    If CatalogContent$ = ""      noFile = ReadFile(#PB_Any, FileName$, #PB_File_SharedRead | #PB_File_SharedWrite)      If noFile        While Eof(noFile) = 0          CatalogContent$ + ReadString(noFile, #PB_UTF8) + Chr(13)        Wend        CloseFile(noFile)        CatalogContent$ = ReplaceString(CatalogContent$, Chr(9), " ")        mCatalogContent$ = CatalogContent$      Else        MessageRequester("Oops!", "GetTextFromCatalog(): ReadingError While reading Catalog For '" + SName$ + "'" + Chr(13) + "File exists, but can't be open." + Chr(13) + FileName$)        ProcedureReturn ""      EndIf    EndIf    ;    If SName$      If CatalogContent$        pos = FindString(CatalogContent$, Chr(13) + SName$ + " ")        If pos = 0          pos = FindString(CatalogContent$, Chr(13) + SName$ + "=")        EndIf        If pos = 0          pos = FindString(CatalogContent$, Chr(13) + SName$ + " ", 0, #PB_String_NoCase)        EndIf        If pos = 0          pos = FindString(CatalogContent$, Chr(13) + SName$ + "=", 0, #PB_String_NoCase)        EndIf        If pos = 0          MessageRequester("Oops!", "GetTextFromCatalog(): '" + SName$ + "' can't be found in catalog!" + Chr(13) + FileName$)          ProcedureReturn ""        Else          pos = FindString(CatalogContent$, "=", pos) + 2          posf = FindString(CatalogContent$, Chr(13), pos)          FString$ = Mid(CatalogContent$, pos, posf - pos)          If Left(FString$, 5) = "file:"            ; Le catalog nous redirige un nom de fichier.            ;            FileName$ = GetPathPart(FileName$) + Trim(Mid(FString$, 6))            If ReadFileWithPatience(0, FileName$)              fsize = Lof(0)              If fsize > 0                FString$ = Space(fsize)                ReadData(0, @FString$, fsize)              EndIf              CloseFile(0)            Else              MessageRequester("Oops!", "GetTextFromCatalog(): Unable to read the file!" + Chr(13) + FileName$)              ProcedureReturn ""            EndIf          Else            FString$ = ReplaceString(FString$, "%newline%", Chr(13))            FString$ = ReplaceString(FString$, "%quote%", Chr(34))            FString$ = ReplaceString(FString$, "%equal%", "=")            FString$ = ReplaceString(FString$, "%nonbreakingspace%", Chr(160))            FString$ = ReplaceString(FString$, "£µ|", "%")          EndIf          ProcedureReturn FString$        EndIf      Else        MessageRequester("Oops!", "Catalog is empty!")        ProcedureReturn ""      EndIf    Else      ProcedureReturn ""    EndIf  EndIfEndProcedure;Procedure OpenPreferencesWithPatience(FileName$)  ; Il arrive que DropBox ou d'autres logiciels  ; de synchronosation bloquent momentanément les  ; fichiers récemment modifiés en lecture.  ; En cas d'échec à l'ouverture d'un fichier,  ; cette procédure va tenter de réitérer la  ; tentative.  ;  Protected Result, noFile  ;  Result = OpenPreferences(FileName$)  If Result = 0    noFile = ReadFileWithPatience(#PB_Any, FileName$)    If noFile      CloseFile(noFile)      Delay(5)      Result = OpenPreferences(FileName$)    EndIf  EndIf  ProcedureReturn ResultEndProcedure;Procedure min(a, b)  If a < b: ProcedureReturn a: Else : ProcedureReturn b: EndIfEndProcedure;Procedure max(a, b)  If a > b: ProcedureReturn a: Else : ProcedureReturn b: EndIfEndProcedure;Procedure OpenWindowFromPrefCoordonnates(Pref_file$, WTitle$, WWidth = 300, WHeight = 300, WParam = -1)  If WParam = -1    WParam = #PB_Window_MinimizeGadget | #PB_Window_MaximizeGadget | #PB_Window_SystemMenu | #PB_Window_SizeGadget | #PB_Window_TitleBar  EndIf  ;  Protected WindowXPref, WindowYPref, WindowWidthPref, WindowHeightPref  Protected NbDesktops, k  Protected DeskTopXMin, DeskTopXMax, DeskTopYMin, DeskTopYMax  ;  NbDesktops = ExamineDesktops()  For k = 0 To NbDesktops - 1    DeskTopXMin = min(DeskTopXMin, DesktopX(k))    DeskTopXMax = max(DeskTopXMax, DesktopX(k) + DesktopWidth(k))    DeskTopYMin = min(DeskTopYMin, DesktopY(k))    DeskTopYMax = max(DeskTopYMax, DesktopY(k) + DesktopHeight(k))  Next  ;  WindowXPref = DeskTopXMin + (DeskTopXMax - DeskTopXMin - WWidth) / 2  WindowYPref = DeskTopYMin + (DeskTopYMax - DeskTopYMin - WHeight) / 2  WindowWidthPref = WWidth  WindowHeightPref = WHeight  If OpenPreferencesWithPatience(Pref_file$)    WindowXPref      = ReadPreferenceLong("WindowX", WindowXPref)    WindowYPref      = ReadPreferenceLong("WindowY", WindowYPref)    WindowWidthPref  = ReadPreferenceLong("WindowWidth", WWidth)    WindowHeightPref = ReadPreferenceLong("WindowHeight", WHeight)    ClosePreferences()  EndIf  If WindowWidthPref > DeskTopXMax    WindowWidthPref = DeskTopXMax - 40  EndIf  If WindowHeightPref > DeskTopYMax    WindowHeightPref = DeskTopYMax - 40  EndIf  If (WindowXPref + WindowWidthPref) > DeskTopXMax    WindowXPref = DeskTopXMax - WindowWidthPref - 20  EndIf  If (WindowYPref + WindowHeightPref) > DeskTopYMax    WindowYPref = DeskTopYMax - WindowHeightPref - 20  EndIf  If WindowXPref < DeskTopXMin    WindowXPref = DeskTopXMin + 20  EndIf  If WindowYPref < DeskTopYMin    WindowYPref = DeskTopYMin + 20  EndIf  ;  ProcedureReturn OpenWindow(#PB_Any, WindowXPref, WindowYPref, WindowWidthPref, WindowHeightPref, WTitle$, WParam)EndProcedure;Procedure RecordWindowDimInPref(Pref_file$, WindowHandle)  If OpenPreferencesWithPatience(Pref_file$)    WritePreferenceLong("WindowX", WindowX(WindowHandle))    WritePreferenceLong("WindowY", WindowY(WindowHandle))    WritePreferenceLong("WindowWidth", WindowWidth(WindowHandle))    WritePreferenceLong("WindowHeight", WindowHeight(WindowHandle))    ClosePreferences()  EndIfEndProcedure;Procedure OpenWaitWindow(WParent, WTexte$)  ;  Protected WaitWindow, WTextGadget  ;  If WParent    WaitWindow = OpenWindow(#PB_Any, 0, 0, 400, 70, "", #PB_Window_BorderLess | #PB_Window_WindowCentered, WindowID(WParent))  Else    WaitWindow = OpenWindow(#PB_Any, 0, 0, 400, 70, "", #PB_Window_BorderLess | #PB_Window_ScreenCentered)  EndIf  ;  WTextGadget = 0  If IsWindow(WaitWindow)    StickyWindow(WaitWindow, 1)    ; Comme on a ouvert une fenêtre borderless, on lui dessine un cadre    FrameGadget(#PB_Any, 1, 1, WindowWidth(WaitWindow) - 2, WindowHeight(WaitWindow) - 2, "", #PB_Frame_Flat)    WTextGadget = TextGadget(#PB_Any, 7, 7, (WindowWidth(WaitWindow) - 10), WindowHeight(WaitWindow) - 12, WTexte$, #PB_Text_Center)  EndIf  ProcedureReturn WTextGadgetEndProcedure;Procedure DestroyParentWindow(NoGadget)  If IsGadget(NoGadget)    DestroyWindow_(GetParent_(GadgetID(NoGadget)))  EndIfEndProcedure;Procedure ShiftWindow(WindowID, xShift, yShift)  Protected hWnd, NewX, NewY  ;  ; Récupère le handle de la fenêtre  If IsWindow(WindowID)    hWnd = WindowID(WindowID)  Else    hWnd = WindowID  EndIf  ;  ; Obtenir la position actuelle de la fenêtre  Protected rect.RECT  GetWindowRect_(hWnd, rect)  ;  ; Calculer la nouvelle position  NewX = rect\left + xShift  NewY = rect\top + yShift  ;  ; Déplacer la fenêtre à la nouvelle position  SetWindowPos_(hWnd, #Null, NewX, NewY, 0, 0, #SWP_NOZORDER | #SWP_NOSIZE)EndProcedure;Global mykey$ = "064892375816";Procedure.s EncodeString(tx$)  ;  ; Very simple function to encode a string  ; using a key. Not ultra-safe, for sure,  ; but quick and simple.  ;    ;  Protected ct, l  Protected Dest$ = ""  Protected keyp = 0  ;  For ct = 1 To Len(tx$)    keyp + 1    If keyp > Len(mykey$) : keyp = 1 : EndIf    ;    l = Asc(PeekS(@tx$ + (ct - 1) * SizeOf(CHARACTER), 1)) + Val(PeekS(@mykey$ + (keyp - 1) * SizeOf(CHARACTER), 1))    Dest$ + Chr(l)  Next  ProcedureReturn (Dest$)EndProcedure;Procedure.s DecodeString(tx$)  ;  Protected ct, l  Protected Dest$ = ""  Protected keyp = 0  ;  For ct = 1 To Len(tx$)    keyp + 1    If keyp > Len(mykey$) : keyp = 1 : EndIf    ;    l = Asc(PeekS(@tx$ + (ct - 1) * SizeOf(CHARACTER), 1)) - Val(PeekS(@mykey$ + (keyp - 1) * SizeOf(CHARACTER), 1))    Dest$ + Chr(l)  Next  ProcedureReturn (Dest$)EndProcedure;Procedure MakeGadgetTransparent(gadgetID, alpha)  Protected hWnd = GadgetID(gadgetID)  SetWindowLongPtr_(hWnd, #GWL_EXSTYLE, GetWindowLongPtr_(hWnd, #GWL_EXSTYLE) | #WS_EX_LAYERED)  SetLayeredWindowAttributes_(hWnd, 0, alpha, #LWA_ALPHA)  SetWindowPos_(hWnd, 0, 0, 0, 0, 0, #SWP_NOMOVE | #SWP_NOSIZE | #SWP_NOZORDER | #SWP_FRAMECHANGED)EndProcedure;Procedure WhiteBoxOverWindow(ThisWindow)  ;  ; Cette procédure crée un rectange blanc semi-transparent qui va se superposer avec le contenu de la fenêtre principale  ; lorsque l'on veut montrer qu'elle est inactive.  ; Si le rectangle a déjà été créé, on se contente de le remettre aux dimensions de la fenêtre.  ;  Static IWhiteOverList$  ;  Protected OldGL, pw, pwf, MemLine$  Protected IWhiteOver ; Valeur de retour                       ;  If IsWindow(ThisWindow)    ;    ; IWhiteOverList$ contient la liste de tous les gadgets IWhiteOver créés pour    ; toutes les fenêtres ouvertes. On cherche dans IWhiteOverList$ si un IWhiteOver    ; a déjà été créé pour la fenêtre 'ThisWindow' :    pw = FindString(Chr(13) + IWhiteOverList$, Chr(13) + Str(ThisWindow) + Chr(9))    If pw      pwf = FindString(IWhiteOverList$, Chr(13), pw)      MemLine$ = Mid(IWhiteOverList$, pw, pwf - pw)      IWhiteOver = Val(StringField(MemLine$, 2, Chr(9)))      If IsGadget(IWhiteOver)        ResizeGadget(IWhiteOver, #PB_Ignore, #PB_Ignore, WindowWidth(ThisWindow), WindowHeight(ThisWindow))        HideGadget(IWhiteOver, #True) ; on cache le rectangle pour le moment.        ProcedureReturn IWhiteOver      EndIf    EndIf    OldGL = UseGadgetList(WindowID(ThisWindow))    ; On dessine le gadget :    IWhiteOver = CanvasGadget(#PB_Any, 0, 0, WindowWidth(ThisWindow), WindowHeight(ThisWindow))    ; On rend le gadget semi-transparent    MakeGadgetTransparent(IWhiteOver, 130)    HideGadget(IWhiteOver, #True) ; on cache le rectangle pour le moment.    UseGadgetList(OldGL)    ;    ; On met la liste à jour :    IWhiteOverList$ + Str(ThisWindow) + Chr(9) + Str(IWhiteOver) + Chr(13)    ;    ProcedureReturn IWhiteOver  EndIfEndProcedure;Procedure.s GetSystemFolder(FolderType)  ;  Protected ItemID, Location$  ;Certains commentaires sont suivis d'une astisque (*). Ca indique que la macro ne fonctionne pas toujours (elle ne renvoit rien). ; Dossier virtuel représentant le bureau Windows;   GetSystemFolder(#CSIDL_DESKTOP); Dossier virtuel représentant l'Internet                                                     *;   GetSystemFolder(#CSIDL_INTERNET); Dossier systeme contenant le groupe de programmes de l'utilisateur;   GetSystemFolder(#CSIDL_PROGRAMS); Dossier virtuel contenant les icônes du panneau de contrôle                                 *;   GetSystemFolder(#CSIDL_CONTROLS); Dossier virtuel contenant les imprimantes installées                                        *;   GetSystemFolder(#CSIDL_PRINTERS); Dossier virtuel représenté par l'icône "Mes Documents" sur le bureau;   GetSystemFolder(#CSIDL_PERSONAL); Dossier système contenant les favoris (Internet Explorer) de l'utilisateur;   GetSystemFolder(#CSIDL_FAVORITES); Dossier système contenant les programmes lancés au démarrage de la session utilisateur;   GetSystemFolder(#CSIDL_STARTUP); Dossier système contenant les raccourcis vers les document récents;   GetSystemFolder(#CSIDL_RECENT); Dossier système contenant les éléments du menu "Envoyer vers";   GetSystemFolder(#CSIDL_SENDTO); Dossier virtuel contenant les objets de la corbeille                                        *;   GetSystemFolder(#CSIDL_BITBUCKET); Dossier système contenant les éléments du menu "Démarrer" de l'utilisateur;   GetSystemFolder(#CSIDL_STARTMENU); Dossier virtuel représenté par l'icône "Mes Documents" sur le bureau                        *;   GetSystemFolder(#CSIDL_MYDOCUMENTS); Dossier système contenant les musiques de l'utilisateur;   GetSystemFolder(#CSIDL_MYMUSIC); Dossier système contenant les vidéos de l'utilisateur;   GetSystemFolder(#CSIDL_MYVIDEO); Dossier système contenant les éléments du bureau de l'utilisateur;   GetSystemFolder(#CSIDL_DESKTOPDIRECTORY); Dossier virtuel représenté par l'icône "Poste de Travail"                                   *;   GetSystemFolder(#CSIDL_DRIVES); Dossier virtuel représentant le "Voisinage Réseau"                                          *;   GetSystemFolder(#CSIDL_NETWORK); Dossier système contenant les liens vers les postes du "Voisinage Réseau";   GetSystemFolder(#CSIDL_NETHOOD); Dossier système contenant les polices;   GetSystemFolder(#CSIDL_FONTS); Dossier système contenant les modèles de documents;   GetSystemFolder(#CSIDL_TEMPLATES); Dossier système contenant les éléments du menu "Démarrer" commun;   GetSystemFolder(#CSIDL_COMMON_STARTMENU); Dossier systeme contenant le groupe de programmes commun;   GetSystemFolder(#CSIDL_COMMON_PROGRAMS); Dossier système contenant les programmes lancés au démarrage d'une session commune;   GetSystemFolder(#CSIDL_COMMON_STARTUP); Dossier système contenant les éléments du bureau commun;   GetSystemFolder(#CSIDL_COMMON_DESKTOPDIRECTORY); Dossier système contenant les données des applications de l'utilisateur;   GetSystemFolder(#CSIDL_APPDATA); Dossier système contenant les liens vers les objets du dossier virtuel "Imprimantes";   GetSystemFolder(#CSIDL_PRINTHOOD); Dossier système contenant les données des applications locales de l'utilisateur;   GetSystemFolder(#CSIDL_LOCAL_APPDATA); Dossier système contenant les programmes lancés au démarrage d'une session                  *;   GetSystemFolder(#CSIDL_ALTSTARTUP); Dossier système contenant les programmes lancés au démarrage d'une session                  *;   GetSystemFolder(#CSIDL_COMMON_ALTSTARTUP); Dossier système contenant les favoris (Internet Explorer) communs;   GetSystemFolder(#CSIDL_COMMON_FAVORITES); EndMacro; Macro GetInternetCache    ; Dossier système contenant le cache internet de l'utilisateur;   GetSystemFolder(#CSIDL_INTERNET_CACHE); Dossier système contenant les cookies de l'utilisateur;   GetSystemFolder(#CSIDL_COOKIES); Dossier système contenant l'historique de navigation de l'utilisateur;   GetSystemFolder(#CSIDL_HISTORY); Dossier système contenant les données des applications communes;   GetSystemFolder(#CSIDL_COMMON_APPDATA); Dossier système Windows (Racine du système);   GetSystemFolder(#CSIDL_WINDOWS); Dossier "System" ou "System32";   GetSystemFolder(#CSIDL_SYSTEM); Dossier "Program Files";   GetSystemFolder(#CSIDL_PROGRAM_FILES); Dossier système contenant les images de l'utilisateur;   GetSystemFolder(#CSIDL_MYPICTURES); Dossier système contenant le profil de l'utilisateur;   GetSystemFolder(#CSIDL_PROFILE); Dossier système contenant les éléments partagé des programmes;   GetSystemFolder(#CSIDL_PROGRAM_FILES_COMMON); Dossier système contenant les modèles de documents communs;   GetSystemFolder(#CSIDL_COMMON_TEMPLATES); Dossier système "Documents" commun;   GetSystemFolder(#CSIDL_COMMON_DOCUMENTS); Dossier système contenant les outils d'administration communs;   GetSystemFolder(#CSIDL_COMMON_ADMINTOOLS); Dossier système contenant les outils d'administration de l'utilisateur                      *;   GetSystemFolder(#CSIDL_ADMINTOOLS); Dossier système contenant les musiques communes;   GetSystemFolder(#CSIDL_COMMON_MUSIC); Dossier système contenant les images communes;   GetSystemFolder(#CSIDL_COMMON_PICTURES); Dossier système contenant les vidéos communes;   GetSystemFolder(#CSIDL_COMMON_VIDEO); Dossier système contenant les données à graver;   GetSystemFolder(#CSIDL_CDBURN_AREA); Dossier contenant les profils de tous les utilisateurs                                      *;   GetSystemFolder(#CSIDL_PROFILES);  If SHGetSpecialFolderLocation_(0, FolderType, @ItemID) = #NOERROR    Location$ = Space(#MAX_PATH)    If SHGetPathFromIDList_(ItemID, @Location$)      ProcedureReturn Location$    EndIf  EndIfEndProcedure;Procedure.s GetCurrentApplicationPath()  Protected AppPath$  If #PB_Compiler_Debugger    AppPath$ = #PB_Compiler_FilePath    ; While 'ZapmanComman.pb' is in 'Zapman libraries' folder    ; we much return on level up:    AppPath$ = ReplaceString(AppPath$, "Zapman libraries\", "")  Else    AppPath$ = GetPathPart(ProgramFilename())  EndIf  ProcedureReturn AppPath$EndProcedure;Procedure.s GetParentFolder(Path$)  Protected ct  Path$ = ReplaceString(GetPathPart(Path$), "/", "\")  ; Supprimer le slash ou backslash de fin, si présent  If Right(Path$, 1) = "\"    Path$ = Left(Path$, Len(Path$) - 1)  EndIf  For ct = Len(Path$) To 1 Step - 1    If Mid(Path$, ct, 1) = "\"      Break    EndIf  Next  If Mid(Path$, ct, 1) = "\"    Path$ = Left(Path$, ct)  Else    Path$ = ""  EndIf  ProcedureReturn Path$EndProcedure;Procedure.s RemoveAccents(input.s)  ; Chaînes contenant les caractères à remplacer et leurs remplaçants respectifs  Protected ToReplace.s  = "áàäâãåāąăéèëêẽēęėíìïîĩīįîóòöôõøōőõúùüûũūůűýÿñçćčçđďšşßžźżÁÀÄÂÃÅĀĄĂÉÈËÊẼĒĘĖÍÌÏÎĨĪĮÎÓÒÖÔÕØŌŐÕÚÙÜÛŨŪŮŰÝŸÑÇĆČÇĐĎŠŞŽŹŻ"  Protected ReplacedBy.s = "aaaaaaaaaeeeeeeeeiiiiiiiiooooooooouuuuuuuuyynccccddssBzzzAAAAAAAAAEEEEEEEEIIIIIIIIOOOOOOOOOUUUUUUUUYYNCCCCDDSSZZZ"    ; Variables pour la boucle  Protected i.i, pos.i  Protected result.s = ReplaceString(input, "æ", "ae")  result.s = ReplaceString(input, "Æ", "AE")  result.s = ReplaceString(input, "œ", "oe")  result.s = ReplaceString(input, "Œ", "OE")    ; Parcourir chaque caractère à remplacer  For i = 1 To Len(ToReplace)    pos = FindString(input, Mid(ToReplace, i, 1))    If pos      result = ReplaceString(result, Mid(ToReplace, i, 1), Mid(ReplacedBy, i, 1))    EndIf  Next i    ProcedureReturn resultEndProcedure;Procedure.s FilePartSsExt(NF$)  NF$ = GetFilePart(NF$)  Protected p = Len(GetExtensionPart(NF$))  If p    NF$ = Left(NF$, Len(NF$) - p - 1)  EndIf  ProcedureReturn NF$EndProcedure;Procedure.s AssainitNomFic(tx$, GardeChiffre = 1)  ;  Protected NF$, mtx$, l, tx2$, ct  ;  FilePartSsExt(NF$)  mtx$ = tx$  tx$ = Left(RemoveAccents(tx$), 30)  If GardeChiffre    ; on récupère les chiffres qui sont à la fin du nom, s'il y en a    l = Len(mtx$) + 1    While l > 1 And (Val(Mid(mtx$, l - 1, 1)) > 0 Or Mid(mtx$, l - 1, 1) = "0") : l - 1 : Wend    If l < Len(mtx$) + 1 And Right(tx$, Len(mtx$) - l) <> Right(mtx$, Len(mtx$) - l)      tx$ + Mid(mtx$, l)    EndIf  EndIf      tx2$ = ""  For ct = 1 To Len(tx$)    If Asc(Mid(tx$, ct, 1)) < 48 Or (Asc(Mid(tx$, ct, 1)) > 57 And Asc(Mid(tx$, ct, 1)) < 65) Or (Asc(Mid(tx$, ct, 1)) > 90 And Asc(Mid(tx$, ct, 1)) < 97) Or Asc(Mid(tx$, ct, 1)) > 122      If Mid(tx$, ct, 1) <> " " And Mid(tx$, ct, 1) <> "-"        tx2$ + "_"      Else        tx2$ + Mid(tx$, ct, 1)      EndIf    Else      tx2$ + Mid(tx$, ct, 1)    EndIf  Next  ProcedureReturn tx2$EndProcedure;Procedure IsMouseOverGadget(NoGadget)  ;  Protected  re.RECT, pt.POINT, Result  ;  If IsGadget(NoGadget)    GetWindowRect_(GadgetID(NoGadget), @re)     GetCursorPos_(pt)    If PtInRect_(re, pt\y << 32 + pt\x)      pt\x - re\left      pt\y - re\top      Result = @pt    Else      Result = 0    EndIf  Else    Debug "Erreur dans IsMouseOverGadget(NoGadget) : ''NoGadget'' n'existe pas"  EndIf  ProcedureReturn Result EndProcedure;Procedure ClickOverGadget(TargetGadget, mouseButton = #MK_LBUTTON)  ; Simule un clic de souris dans le gadget TargetGadget.  ; Cela ne fonctionne que si le curseur de la souris  ; se trouve effectivement au-dessus de ce gadget.  ;  Protected CursorPos.point, GadgetRect.rect, Coordonates  Protected wDButton, wUButton  ;  If mouseButton = #MK_LBUTTON    wDButton = #WM_LBUTTONDOWN    wUButton = #WM_LBUTTONUP  ElseIf mouseButton = #MK_RBUTTON    wDButton = #WM_RBUTTONDOWN    wUButton = #WM_RBUTTONUP    mouseButton = #MK_RBUTTON  EndIf  If wDButton And IsGadget(TargetGadget)    GetCursorPos_(CursorPos)    GetWindowRect_(GadgetID(TargetGadget), @GadgetRect)    If PtInRect_(GadgetRect, CursorPos\y << 32 + CursorPos\x)      CursorPos\x - GadgetRect\left      CursorPos\y - GadgetRect\top      Coordonates = CursorPos\x | (CursorPos\y << 16)      ; Simule un clic      ; Button DOWN      SendMessage_(GadgetID(TargetGadget), wDButton, mouseButton, Coordonates)      ; Button UP      SendMessage_(GadgetID(TargetGadget), wUButton, mouseButton, Coordonates)      ;      ProcedureReturn #True    EndIf    ;  EndIfEndProcedure;Procedure TransfertClickToGadget()  ;  ; Lorsqu'une fenêtre inactive redevient active  ; (c'est-à-dire lorsque l'utilisateur à d'abord cliqué  ; sur une fenêtre autre que celle de l'application,  ; puis qu'il a cliqué sur la fenêtre de l'application),  ; le gadget dans lequel l'utilisateur a cliqué ne reçoit  ; pas les coordonnées du clic. Le premier clic a pour  ; seul effet de rendre la fenêtre active, et il faut  ; recliquer pour que le gadget reçoive le clic.  ;  ; Cette procédure corrige cela en simulant immédiatement  ; un deuxième clic, lorsque la fenêtre est réactivée.    Static OldActiveWindow  ;  Protected mouseButton  Protected RetValue = #False  ;  If GetActiveWindow() > -1 And OldActiveWindow = -1    ;    Protected ActiveGadget = GetActiveGadget()    ;    If ActiveGadget <> -1      ; Vérifie si un bouton de la souris est appuyé :      If GetAsyncKeyState_(#VK_LBUTTON) & $8000        mouseButton = #MK_LBUTTON      ElseIf GetAsyncKeyState_(#VK_RBUTTON) & $8000        mouseButton = #MK_RBUTTON      EndIf      ;      RetValue = ClickOverGadget(ActiveGadget, mouseButton)    EndIf  EndIf  ;  OldActiveWindow = GetActiveWindow()  ProcedureReturn RetValue  ;EndProcedure;Procedure FirstOccurrence(MainString$, OccList$, spos = 0, limpos = 0, Mode = #PB_String_CaseSensitive)  ;  ; Recherche, dans 'MainString$', la première occurrence de l'une des expressions contenues par 'OccList$'  ; à partir de la position 'spos', jusqu'à la position 'limpos'.  ; Si 'spos' vaut zéro, la recherche se fera depuis le début de 'MainString$'.  ; Si 'limpos' vaut zéro, la recherche se fera jusqu'à la fin de 'MainString$'.  ;  ; Cette fonction ne présente un intérêt par rapport à 'FindString' que si OccList$ comporte plusieurs valeurs  ; qui devront être renseignées sous la forme "valeur1,valeur2,etc." (sans espace, sauf si votre expression comprend des espaces).  ; Si une valeur doit comporter une virgule, remplacez la virgule par l'expression "\comma_".  ;  Protected l, sfind, sfind2, occ$  ;  OccList$ + ","  sfind = 0  l = 0  Repeat    l + 1    occ$ = StringField(OccList$, l, ",")    If occ$      occ$ = ReplaceString(occ$, "\comma_", ",")      sfind2 = FindString(MainString$, occ$, spos, Mode)      If sfind2 And (sfind2 < sfind Or sfind = 0) And (limpos = 0 Or sfind2 < limpos)        sfind = sfind2      EndIf    EndIf  Until occ$ = ""  ProcedureReturn sfindEndProcedure;Macro MFirstOccurenceOfChar(FOFCString)  ;  Protected l, sfind, sfind2, occ$  ;  sfind = 0  For l = 1 To Len(OccList$)    occ$ = Mid(OccList$, l, 1)    sfind2 = FindString(FOFCString, occ$, spos, Mode)    If sfind2 And (sfind2 < sfind Or sfind = 0) And (limpos = 0 Or sfind2 < limpos)      sfind = sfind2    EndIf  NextEndMacro;Procedure FirstOccurrenceOfChar(MainString$, OccList$, spos = 0, limpos = 0, Mode = #PB_String_CaseSensitive)  ;  ; Recherche, dans 'MainString$', la première occurrence de l'un des caractères contenus par 'OccList$'  ; à partir de la position 'spos', jusqu'à la position 'limpos'.  ; Si 'spos' vaut zéro, la recherche se fera depuis le début de 'MainString$'.  ; Si 'limpos' vaut zéro, la recherche se fera jusqu'à la fin de 'MainString$'.  ;  MFirstOccurenceOfChar(MainString$)  ProcedureReturn sfindEndProcedure;Procedure FirstOccurrenceOfCharPointed(*MainString.String, OccList$, spos = 0, limpos = 0, Mode = #PB_String_CaseSensitive)  ;  ; Recherche, dans '*MainString\s', la première occurrence de l'un des caractères contenus par 'OccList$'  ; à partir de la position 'spos', jusqu'à la position 'limpos'.  ; Si 'spos' vaut zéro, la recherche se fera depuis le début de '*MainString\s'.  ; Si 'limpos' vaut zéro, la recherche se fera jusqu'à la fin de '*MainString\s'.  ;  ; Plutôt que de passer le paramètre '*MainString' en chaîne, ce qui peut  ; consommer de la mémoire et du temps, si la chaîne est longue, on travaille  ; avec un pointeur sur une structure String. Ainsi, la chaîne n'est pas  ; duppliquée en mémoire au moment de l'appel.  MFirstOccurenceOfChar(*MainString\s)  ProcedureReturn sfindEndProcedure;Procedure EraseBalloonToolTip(Tooltip)  DestroyWindow_(Tooltip)EndProcedure;Procedure InitBalloonToolTip(WindowNumber)  ;  ; Crée une fenêtre de type "balloon" pour afficher une aide ou des renseignements  ; au moment du survol d'un gadget.  ;  Protected Tooltip = CreateWindowEx_(0, "ToolTips_Class32" , "" , #WS_POPUP | #TTS_NOPREFIX | #TTS_BALLOON , 0, 0, 0, 0, WindowID(WindowNumber), 0, GetModuleHandle_(0), 0)  SendMessage_(Tooltip, #TTM_SETTIPTEXTCOLOR , GetSysColor_(#COLOR_INFOTEXT), 0)  SendMessage_(Tooltip, #TTM_SETTIPBKCOLOR , GetSysColor_(#COLOR_INFOBK), 0)  SendMessage_(Tooltip, #TTM_SETMAXTIPWIDTH , 0, 250) ; ICI 250 représente la largeur de la bulle  SendMessage_(Tooltip, #TTM_SETDELAYTIME, #TTDT_INITIAL , 1000)  SendMessage_(Tooltip, #TTM_SETDELAYTIME, #TTDT_AUTOPOP , 10000)  SendMessage_(Tooltip, #TTM_SETDELAYTIME, #TTDT_RESHOW , 1)  ProcedureReturn TooltipEndProcedure;Procedure AddBalloonToolTip(Tooltip, GadgetNumber, Text.s)  Protected Balloon.TOOLINFO  Balloon\cbSize = SizeOf(TOOLINFO)  Balloon\uFlags = #TTF_IDISHWND | #TTF_SUBCLASS   Balloon\hwnd = GadgetID(GadgetNumber)  Balloon\uId = GadgetID(GadgetNumber)  Balloon\lpszText = @Text  ProcedureReturn SendMessage_(Tooltip, #TTM_ADDTOOL , 0, @Balloon)EndProcedure;Procedure RemoveBalloonToolTip(Tooltip, GadgetNumber)  Protected Balloon.TOOLINFO  Balloon\cbSize = SizeOf(TOOLINFO)  Balloon\uFlags = #TTF_IDISHWND   Balloon\hwnd = GadgetID(GadgetNumber)  Balloon\uId = GadgetID(GadgetNumber)  ProcedureReturn SendMessage_(Tooltip, #TTM_DELTOOL, 0, @Balloon)EndProcedure;Procedure CreatePathFolders(FileName$)  ;  ; Examine le chemin de FileName$ et crée  ; les différents dossiers qui composent ce chemin,  ; s'ils n'existent pas déjà  ;  Protected ProgressivePath$, NextFolder$, nl  ;  FileName$ = ReplaceString(FileName$, "/", "\")  ;  If FileName$ And FindString(FileName$, "\")    ProgressivePath$ = ""    nl = 0    Repeat      nl + 1      NextFolder$ = StringField(FileName$, nl, "\")      ProgressivePath$ + NextFolder$ + "\"      If nl > 1 And FileSize(ProgressivePath$) <> -2        If CreateDirectory(ProgressivePath$) = 0          Alert("Unable to create directory : " + ProgressivePath$)        EndIf      EndIf     Until ProgressivePath$ = GetPathPart(FileName$)  EndIfEndProcedure;Procedure CreateFileWithPatience(NomFichier$)  Protected ct, noFile  ;  For ct = 1 To 10    noFile = CreateFile(#PB_Any, NomFichier$)    If noFile = 0      Delay(100)    Else      Break    EndIf  Next  ProcedureReturn noFileEndProcedure;Procedure.s FileToText(FileName$, FileFormat = -1, Silence = 0)  ;  ; Quelle que soit la valeur donnée à FileFormat, si ReadStringFormat(noFile) retourne  ; une valeur, elle aura la priorité.  ;  ; Si FileFormat vaut zéro et que le fichier n'a pas de BOM, la lecture se fera au format  ; indiqué par la variable globale BOM. Si BOM n'a pas de valeur, la lecture se fera en ASCII.  ;  ; Cette procédure va toutefois essayer de corriger le tir, si le résultat obtenu  ; semble contenir des caractères UTF8 alors qu'il a été lu en ascii, une nouvelle lecture  ; sera tentée. Et inversement.  ;  ; Si TakeOffLF a une valeur non nulle, les caractères de fin de ligne sont supprimés  ; du contenu récupéré.  ;  Global BOM  ;  Protected mFileFormat, mBOM, fsize, noFile, RSF, ReadingPosition  Protected FileContent$, UTF8Test, ASCIITest, mFileContent$  ;  mFileFormat = FileFormat    If FileFormat = -1    FileFormat = #PB_UTF8 ; Format par défaut.  ElseIf FileFormat = 1  ; Raccourci pour demander une lecture au format Unicode    FileFormat = #PB_Unicode    mFileFormat = #PB_Unicode  ElseIf FileFormat = 0  ; Si zéro est passé en paramètre, en prend le format du dernier fichier lu.    FileFormat = BOM    mFileFormat = BOM  EndIf  mBOM = BOM  If FileFormat <> #PB_Ascii And FileFormat <> #PB_UTF8 And FileFormat <> #PB_Unicode    ; On ne supporte que ces trois formats.    FileFormat = #PB_Ascii  EndIf  ;  fsize = FileSize(FileName$)  ;  If fsize > 2    noFile = ReadFileWithPatience(#PB_Any, FileName$)  EndIf  ;  If noFile    RSF = ReadStringFormat(noFile) ; détection du format de fichier    If Loc(noFile)      ; Si Loc(noFile) est supérieur à zéro, c'est qu'un format a réellement été lu.      ; Cette vérification est nécessaire, car ReadStringFormat() renvoie la valeur ASCII      ; quand il n'y a aucun BOM enregistré dans le fichier.      ; On ne lui fera donc confiance que si un format est réellement enregistré.      FileFormat = RSF    Else      RSF = 0 ; On garde en mémoire le fait que le fichier n'avait pas de BOM.    EndIf    ;    ReadingPosition = Loc(noFile)    ;    FTT_StartReading:     ;    FileContent$ = ReadString(noFile, FileFormat | #PB_File_IgnoreEOL)        If FileContent$      If RSF = 0 Or mFileFormat <> FileFormat  ; Un format de lecture à été explicitement déclaré.                                             ; et on n'a trouvé aucune déclaration de format                                             ; dans le fichier pour confirmer son format.                                             ; Ou bien les deux ne concordent pas.        ;        ; On va regarder si le texte lu comporte des indicateurs semblant        ; démontrer qu'il n'a pas été lu dans le bon format.        ; Si l'on en trouve, on choisira le format le plus probable,        ; en fonction du nombre de caractères à problème que l'on        ; aura trouvés.        If FileFormat = #PB_Ascii          ; Le fichier a été lu en ASCII.          UTF8Test = CountString(FileContent$, "Ã")          ; Si UTF8Test n'est pas nul, il y a sans doute un problème.          ; Le caractère 'Ã' se retrouve typiquement dans un fichier UTF-8          ; lu en mode ASCII.          If UTF8Test > ASCIITest            If ASCIITest = 0              ; On a lu en ascii, mais le fichier est apparemment en UTF-8 !              FileFormat = #PB_UTF8              FileSeek(noFile, ReadingPosition)              mFileContent$ = FileContent$              Goto FTT_StartReading            Else              FileContent$ = mFileContent$            EndIf          EndIf        EndIf        ;        If FileFormat = #PB_UTF8          ; Le fichier a été lu en UTF8.          ASCIITest = CountString(FileContent$, Chr(65533))          ; Le caractère 65533 se retrouve typiquement dans un fichier ASCII          ; lu en mode UTF8.          If ASCIITest > UTF8Test            If UTF8Test = 0              ; On a lu en UTF-8, mais le fichier est apparemment en ascii !              FileFormat = #PB_Ascii              FileSeek(noFile, ReadingPosition)              mFileContent$ = FileContent$              Goto FTT_StartReading            Else              FileContent$ = mFileContent$            EndIf          EndIf        EndIf      EndIf      BOM = FileFormat    EndIf    CloseFile(noFile)    ;    If FileContent$ And TakeOffLF      FileContent$ = ReplaceString(FileContent$, Chr(10), "")      FileContent$ = ReplaceString(FileContent$, Chr(13), " ")    EndIf      ElseIf fsize < 3 And Silence = 0    MessageRequester("Error", "Unable To Read " + FileName$ + Chr(13) + "File is empty!", #PB_MessageRequester_Ok)  ElseIf (Silence = 2 Or Silence = 0)    MessageRequester("Error", "Unable to read " + FileName$ + Chr(13) + "It's perhaps allready open by another program...", #PB_MessageRequester_Ok)    If Silence = 0      End    EndIf  EndIf  ;  ProcedureReturn FileContent$EndProcedure;Procedure TexteDansFichier(NomFichier$, Texte$, Encodage = #PB_UTF8, CheckMod = 0, addBOM = 0)Protected p, DebText$, ThisFile, Result ; ********* Added by PPBrowser.; Variables déclarées mais non utilisées : CheckMod ********* (PPBrowser comment)  ;  ; Paramètre non utilisé : CheckMod  ;  If NomFichier$ = ""    alert("Le nom de fichier donné en argument de ''TexteDansFichier()'' est vide !")    CallDebugger  Else    If Encodage = 0      p = 1      While Mid(Texte$, p, 1) = " " Or Mid(Texte$, p, 1) = Chr(13) Or Mid(Texte$, p, 1) = Chr(10) Or Mid(Texte$, p, 1) = Chr(9) : p + 1 : Wend      If Mid(Texte$, p, 1) = "<" ; Il semble que l'on ait affaire à un fichier HTML        DebText$ = LCase(Left(Texte$, 2000)) ; on examine le début du texte à enregistrer        DebText$ = ReplaceString(DebText$, " ", ""); afin de reconnaître les instructions d'encodage HTML        DebText$ = ReplaceString(DebText$, Chr(10), "") ; si le fichier en contient        DebText$ = ReplaceString(DebText$, Chr(13), "")        DebText$ = ReplaceString(DebText$, Chr(9), "")        DebText$ = ReplaceString(DebText$, "'", Chr(34))        If FindString(DebText$, "charset=utf-8", 0) Or FindString(DebText$, "charset=" + Chr(34) + "utf-8" + Chr(34), 0) Or FindString(DebText$, "encoding=" + Chr(34) + "utf-8" + Chr(34), 0)          Encodage = #PB_UTF8          BOM = #PB_UTF8        ElseIf FindString(DebText$, "charset=iso-8859-1", 0) Or FindString(DebText$, "charset=" + Chr(34) + "iso-8859-1" + Chr(34), 0) Or FindString(DebText$, "encoding=" + Chr(34) + "iso-8859-1" + Chr(34), 0)          Encodage = #PB_Ascii          BOM = #PB_Ascii        EndIf      EndIf    EndIf    ;    CreatePathFolders(NomFichier$)    ;    ThisFile = CreateFileWithPatience(NomFichier$)    If ThisFile = 0      MessageRequester("Ooops!", "Impossible de créer le fichier " + Chr(13) + NomFichier$, #PB_MessageRequester_Ok)      CallDebugger    Else      p = 1      While Mid(Texte$, p, 1) = " " Or Mid(Texte$, p, 1) = Chr(13) Or Mid(Texte$, p, 1) = Chr(10) Or Mid(Texte$, p, 1) = Chr(9) : p + 1 : Wend      If addBOM And Mid(Texte$, p, 1) <> "<" ; on ajoute pas de BOM dans les fichiers HTML        WriteStringFormat(ThisFile, Encodage)        ;Debug "J'enregistre le BOM dans le fichier "+NomFichier$+Chr(13)+"addBOM = "+Str(addBOM)+Chr(13)+Mid(Texte$,p,100)      EndIf      ;      WriteString(ThisFile, Texte$, Encodage)      CloseFile(ThisFile)      Result = 1    EndIf  EndIf  ProcedureReturn ResultEndProcedure;Procedure ListFiles(directory.s , filename.s, extension.s , directoryid.l = 0, ReadHiddenFile = 0, StopIfOneFind = 0, DirectorySearch = 0, LevelLimit = 0, TimeLimit = 0, Silence = 0)  ; Author: Sebi (english forum)  ; Extended and Adapted by Zapman  ;  ; Give the complete content of a directory  ; Donne le contenu complet d'un dossier  ;  ; Le résultat figurera dans la variable globale FileListing$  ;  ; OR / OU  ; Give the content corresponding to filename and extension criterias  ; Donne le contenu correspondant aux critères contenus dans filename et extension  ;  ; Exemples pour extension : "*", "bmp" ou "gif;bmp"  ; Examples for extension: "*", "bmp" or "gif;bmp"  ;  ; Exemples pour filename : "*" ou "NomDuFichier"  ; Examples for filename: "*" or "NameOfFile"  ;  ; Result is returned into the FileListing$ variable  ; This variable must be GLOBAL in order to transmit the result to your program  ;  ; If StopIfOneFind is set to 1, the search will stop after the first find matching parameters  ;  ; If DirectorySearch is set to 1, the search will only concern directory names  ;  ; LevelLimit will limit the level of search in directories.  ; If you set it to 1, the function will only search at the first level of the directory given in parameter  ;  ; TimeLimit can define in milliseconds the maximum time allowed for the search  ;  ; Cette procédure est récursive (elle s'appelle elle-même).  ;  ;  Shared ListFileInitLevel, ListFileOrigineTime  ;  Protected  Attributs, cont, DirType, file.s, this_extension.s, this_filename.s, Nbpliste  ;  extension = ReplaceString(extension, ".", "")  ;  If directory    If FileSize(directory) > 0 ; Un nom de fichier a été donné en paramètre      Attributs = GetFileAttributes(directory)      If Attributs & #PB_FileSystem_Hidden = 0 Or ReadHiddenFile        FileListing$ + directory + Chr(13)      EndIf    Else      filename = LCase(filename)      extension = LCase(ReplaceString(extension, " ", ""))      If Right(directory, 1) <> "\"         directory + "\"       EndIf       If directoryid = 0        ListFileInitLevel = CountString(directory, "\")        ListFileOrigineTime = ElapsedMilliseconds()        FileListing$ = ""      EndIf      directoryid = ExamineDirectory(#PB_Any, directory, "")      If IsDirectory(directoryid)        cont = 1        Repeat          If NextDirectoryEntry(directoryid)            DirType = DirectoryEntryType(directoryid)            file.s = DirectoryEntryName(directoryid)            Select DirType               Case #PB_DirectoryEntry_File                If DirectorySearch = 0                  Attributs = DirectoryEntryAttributes(directoryid)                  If Attributs & #PB_FileSystem_Hidden = 0 Or ReadHiddenFile                    this_extension.s = LCase(GetExtensionPart(file))                    this_filename.s = LCase(Left(file, Len(file) - Len(this_extension)))                     If Len(this_extension)                       this_filename = Left(this_filename, Len(this_filename) - 1)                     EndIf                    If FindString(";" + extension + ";", ";" + this_extension + ";", 0) Or extension = "*"                       If FindString(";" + filename + ";", ";" + this_filename + ";", 0) Or filename = "*"                         file.s = directory + DirectoryEntryName(directoryid)                         ;file contains the full path and filename                         FileListing$ + file + Chr(13)                                                Nbpliste + 1                      EndIf                     EndIf                   EndIf                EndIf              Case #PB_DirectoryEntry_Directory                If file <> "." And file <> ".."                  If DirectorySearch And (FindString(";" + filename + ";", ";" + LCase(file) + ";", 0) Or filename = "*")                    FileListing$ + directory + file + "\" + Chr(13)                    Nbpliste + 1                  EndIf                  If (LevelLimit = 0 Or (CountString(directory, "\") - ListFileInitLevel) < (LevelLimit - 1))                    ListFiles(directory + file + "\", filename, extension, directoryid + 1, ReadHiddenFile, StopIfOneFind, DirectorySearch, LevelLimit, TimeLimit, Silence)                  EndIf                EndIf             EndSelect           Else            Cont = 0          EndIf        Until Cont = 0 Or (StopIfOneFind And FileListing$) Or (TimeLimit And (ElapsedMilliseconds() - ListFileOrigineTime) > TimeLimit)        FinishDirectory(directoryid)      Else        If Silence = 0          MessageRequester("Ooop !", "Impossible d'examiner le répertoire " + directory)        EndIf      EndIf    EndIf  EndIfEndProcedure;Procedure ListEmptyFolders(directory.s)  ;  ; Dresse la liste des répertoires vides contenus dans 'directory'  ; Le résultat est retourné dans la variable globale   'EmptyFolder$'  ;  ;  ; Cette procédure est récursive (elle s'appelle elle-même).  ;  Global EmptyFolder$  ;  Protected  directoryid, cont, st, DirType, file.s, deb  ;  If directory And FileSize(directory) < 0    If Right(directory, 1) <> "\"       directory + "\"     EndIf     If directoryid = 0      FileListing$ = ""    EndIf    directoryid = ExamineDirectory(#PB_Any, directory, "")    If directoryid      cont = 1      st = 0      Repeat        If NextDirectoryEntry(directoryid) = 0          Cont = 0        Else          DirType = DirectoryEntryType(directoryid)          file.s = DirectoryEntryName(directoryid)          Select DirType             Case #PB_DirectoryEntry_File              st + 1            Case #PB_DirectoryEntry_Directory              If file <> "." And file <> ".."                st + ListEmptyFolders(directory + file + "\")              EndIf           EndSelect         EndIf        deb = 0      Until Cont = 0      If st = 0        EmptyFolder$ + directory + Chr(13)      EndIf      FinishDirectory(directoryid)    Else      MessageRequester("Ooop !", "Impossible d'examiner le répertoire " + directory)    EndIf  EndIf  ProcedureReturn stEndProcedure;Procedure.s ChangeFileExtension(NFile$, NewExt$)  If NFile$ = "" Or NewExt$ = ""    Alert("L'un des paramètres de ''ChangeFileExtension'' est vide !")  Else    NewExt$ = ReplaceString(NewExt$, ".", "")    NFile$ = Left(NFile$, Len(NFile$) - Len(GetExtensionPart(NFile$)))    If Right(NFile$, 1) <> "."      NFile$ + "."    EndIf    ProcedureReturn NFile$ + NewExt$  EndIfEndProcedure;Procedure IsStringNum(EString$)  ; Examine la chaîne de caractères 'EString$'  ; pour voir si elle contient une valeur numérique.  Protected ct  Protected TS$ = "0123456789.$%"  ;  For ct = 1 To Len(EString$)    If FindString(TS$, PeekS(@EString$ + (ct - 1) * SizeOf(CHARACTER), 1)) = 0      ProcedureReturn #False    EndIf  Next  ProcedureReturn #TrueEndProcedure ;Procedure KillPrg(ProcessName.s)    ;   Protected snapshot.i   Protected prinfo.PROCESSENTRY32   Protected phandle.i   Protected PN$, Result ; ********* Added by PPBrowser.   Protected pexitc.i   prinfo\dwSize = SizeOf(PROCESSENTRY32)   snapshot = CreateToolhelp32Snapshot_(#TH32CS_SNAPPROCESS, 0)   If snapshot      If Process32First_(snapshot, prinfo)         Repeat           PN$ = UCase(PeekS(@prinfo\szExeFile))            If UCase(ProcessName) = GetFilePart(PN$)               phandle = OpenProcess_(#PROCESS_TERMINATE, #False, prinfo\th32ProcessID)                If phandle                   Result = TerminateProcess_(phandle, @pexitc)                                    CloseHandle_(phandle)               EndIf            EndIf         Until Process32Next_(snapshot, prinfo) = 0      EndIf      CloseHandle_(snapshot)   EndIf   ProcedureReturn Result EndProcedure ;Procedure.l TravelsWindowsProc(hFind, lParam)Protected Result ; ********* Added by PPBrowser.; Variables déclarées mais non utilisées : lParam ********* (PPBrowser comment)  ; Paramètre non utilisé : lParam  Global HideOrShow123$, ApplicationToHideOrShow123$  ;  Protected WindowName.s = Space(255)  Protected WindowClass.s = Space(255)  Protected mparam  Protected dontchangeit  ;  If GetWindowText_(hFind, WindowName, 255)    Result = GetClassName_(hFind, WindowClass, 255)    If WindowClass <> "Button" And WindowClass <> "Progman"      If FindString(LCase(WindowName), LCase(ApplicationToHideOrShow123$), 0)        If LCase(HideOrShow123$) = "minimize"          mparam = #SW_MINIMIZE        ElseIf LCase(HideOrShow123$) = "maximize"          mparam = #SW_MAXIMIZE        ElseIf LCase(HideOrShow123$) = "show" Or LCase(HideOrShow123$) = "bringtofront" Or LCase(HideOrShow123$) = "bring to front"          mparam = #SW_RESTORE        ElseIf LCase(HideOrShow123$) = "hide"          mparam = #SW_HIDE        Else          dontchangeit = 1        EndIf        If dontchangeit = 0          ShowWindow_(hFind, mparam)        EndIf        If LCase(HideOrShow123$) = "bringtofront" Or LCase(HideOrShow123$) = "bring to front"          SetForegroundWindow_(hFind)        EndIf      EndIf    EndIf  EndIf  ProcedureReturn 1EndProcedure;Procedure HideOrShowAnApplicationWindow(ApplicationName$, HideOrShow$)  ;  ; HideOrShow123$ et ApplicationToHideOrShow123$ sont des variables globales  ;  HideOrShow123$ = HideOrShow$  ApplicationToHideOrShow123$ = ApplicationName$  EnumWindows_(@TravelsWindowsProc(), 0)EndProcedure;Procedure CheckRunningProg(Name.s)  ;  Protected result.l, Snapshot.l, ProcessFound.l, PN$, Process.PROCESSENTRY32  ;  Process\dwSize = SizeOf(PROCESSENTRY32)  Snapshot = CreateToolhelp32Snapshot_(#TH32CS_SNAPPROCESS, 0)  If Snapshot    ProcessFound = Process32First_(Snapshot, Process)    While ProcessFound      PN$ = UCase(PeekS(@Process\szExeFile));, #PB_Any))      If UCase(Name) = GetFilePart(PN$)        result = #True        ProcessFound = 0      Else        ProcessFound = Process32Next_(Snapshot, Process)      EndIf    Wend    CloseHandle_(Snapshot)  EndIf  ProcedureReturn resultEndProcedure;Procedure.s ProgramfileNameFromWindow(WindowID)  ;  Protected ProcessID, Process32, Snapshot, ProcessEntry.PROCESSENTRY32, ProgramfileName.s  ;  GetWindowThreadProcessId_(WindowID, @ProcessID)    Process32 = OpenLibrary(#PB_Any, "kernel32.dll")   If Process32    Snapshot = CallFunction(Process32, "CreateToolhelp32Snapshot", #TH32CS_SNAPPROCESS, 0)     If Snapshot       ProcessEntry\dwSize = SizeOf(PROCESSENTRY32)       If CallFunction(Process32, "Process32First", Snapshot, @ProcessEntry)         Repeat          If ProcessID = ProcessEntry\th32ProcessID             ProgramfileName = PeekS(@ProcessEntry\szExeFile, 1000, #PB_Ascii)            Break          EndIf        Until CallFunction(Process32, "Process32Next", Snapshot, @ProcessEntry) = 0      EndIf          CloseHandle_(Snapshot)     EndIf     CloseLibrary(Process32)   EndIf   ProcedureReturn ProgramfileNameEndProcedure;Procedure WaitForEventAchieve()  ;  ; Wait for system redrawing windows and gadgets  ; without loosing PureBasic or other events.  ;  ; This is equivalent to "While WindowEvent() : Wend"  ; except that it doesn't erase messages.  ;  ; This is also equivalent to a simple 'delay(1)'  ; except that duration is not fixed here : the procedure  ; get out of the loop when current operation (as redrawing  ; a window) is completed.  ;  Protected msg.MSG  ;  While PeekMessage_(@msg, 0, 0, 0, #PM_REMOVE)    TranslateMessage_(@msg)    DispatchMessage_(@msg)  WendEndProcedure;Procedure.i IsGadgetHidden(GadgetID.i)  ; Retourne 1 si le gadget est masqué, sinon 0  ;  If IsGadget(GadgetID) And IsWindowVisible_(GadgetID(GadgetID)) = 0    ProcedureReturn #True  Else    ProcedureReturn #False  EndIfEndProcedure;Procedure.i GetCurrentCursor()  ;  Protected ci.CURSORINFO  ci\cbSize = SizeOf(CURSORINFO)  ;  ; Get cursor information  If GetCursorInfo_(@ci)    If ci\flags = 1      ProcedureReturn ci\hCursor    EndIf  EndIf  ;  ProcedureReturn 0EndProcedure;Procedure.s StrDate(Date)  ProcedureReturn FormatDate("%dd/%mm/%yyyy-%hh:%ii:%ss", Date)EndProcedure;Procedure ValDate(Date$)  ProcedureReturn ParseDate("%dd/%mm/%yyyy-%hh:%ii:%ss", Date$)EndProcedure;Procedure.s DecimalToBinary(number.i)  ;  Protected binary.s = ""  Protected bit.i  ;  If number = 0    binary = "0"  EndIf    While number > 0    bit = number & 1    binary = Str(bit) + binary    number >> 1  Wend    While Len(binary) < 16    binary = "0" + binary  Wend    binary = Left(binary, 8) + " " + Mid(binary, 9)    ProcedureReturn binaryEndProcedure;Procedure.i TestBit(BinaryNumber.i, BitNumber.i)  ;  ; Vérifie si le BitNumber est valide  ;  If BitNumber < 0 Or BitNumber >= 32 ; On suppose ici que les entiers sont de 32 bits    ProcedureReturn - 1 ; Retourne -1 en cas de BitNumber invalide  EndIf    ; Déplace le bit à tester à la position 0 et applique un AND avec 1  Protected result.i = (BinaryNumber >> (BitNumber - 1)) & 1    ProcedureReturn resultEndProcedure;Procedure ReverseFindString(MainString$, SearchString$, posdep = 0, FMode = #PB_String_CaseSensitive)  ;  ; Recherche 'SearchString$' dans 'MainString$' en remontant à partir de la position 'posdep'.  ; (cherche si 'SearchString$' se trouve avant la position posdep).  ;  ; Si 'posdep' vaut zéro ou n'est pas renseigné, on cherche à partir de la fin de 'MainString$'  ;  If SearchString$ ; pour éviter de perdre du temps pour rien    If posdep : posdep = Len(MainString$) - posdep + 1 : EndIf    Protected Result = FindString(ReverseString(MainString$), ReverseString(SearchString$), posdep, FMode)    If Result      Result = Len(MainString$) - Len(SearchString$) - Result + 2    EndIf  EndIf  ProcedureReturn ResultEndProcedure;Procedure OpenUrl(URL.s, Alert = 0, post_data$ = "", LastURL$ = "")  ;   ; Can read a HTML page or any file through Internet (picture or other)  ;  ; Readen data is returned as a pointer to a buffer.  ; This buffer must be cleaned by FreeMemory(Buffer) after use.  ;  ; To post data to the URL, fill post_data$ with your data.  ;  ; To give a referrer to the URL, fill "LastURL$" with the URL which you want to declare as the referrer.  ;  ; If declared as ''global'', after return LastURL$ will contain the real URL which answered to the request  ; (if there is a redirection, this could be different from the URL.s entry parameter)  ;  ; To know if an error as occured, declare "ErrorOpenURL$" as a global variable  ; and check it after "OpenUrl"  ;  ; If you want the user to be informed about errors, set "Alert" to a non zero value.   ;  Protected ErrorOpenURL$, IPAdress$, p, host.s, get_url.s, Buffer, PostGet, hInet  Protected prefixe$, connect_handle, Verb$, request_handle, headers.s, fsize, BufferP  Protected now, YetRead, NowOU, Bytes, Success, OpenURLDone, bufflen, buffer$  ;   #INTERNET_OPEN_TYPE_DIRECT = 1   #HTTP_ADDREQ_FLAG_ADD = $20000000   #HTTP_ADDREQ_FLAG_REPLACE = $80000000   #INTERNET_FLAG_SECURE = $800000  #INTERNET_FLAG_RELOAD = $80000000  #INTERNET_FLAG_EXISTING_CONNECT = $20000000  #HTTP_QUERY_CONTENT_LENGTH = 5  #HTTP_QUERY_URI = 13  #INTERNET_OPTION_URL = 34    ;   ; Type of connection (could be FTP Gopher etc). HTTPS is done as HTTP too.   ;   #INTERNET_SERVICE_HTTP = 3     ;   ; HTTP port is 80, HTTPS (SSL) port is 443.   ;   #INTERNET_DEFAULT_HTTP_PORT = 80   ErrorOpenURL$ = ""  IPAdress$ = "127.0.0.1:" + Str(#INTERNET_DEFAULT_HTTP_PORT)  If URL    If Left(URL, 1) = Chr(34) : URL = Right(URL, Len(URL) - 1) : EndIf    If Right(URL, 1) = Chr(34) : URL = Left(URL, Len(URL) - 1)  : EndIf    URL = ReplaceString(URL, " ", "%20")    URL = RemoveString(URL, "http://")    URL = ReplaceString(URL, "//", "/")        p = 0    While p < Len(URL) And Mid(URL, p, 1) <> "/" And Mid(URL, p, 1) <> "\" : p + 1 : Wend    ;p + 1    host.s = Left(URL, p - 1)    get_url.s = Right(URL, Len(URL) - p + 1)    Buffer = 0    If post_data$ Or LastURL$      PostGet = 1    EndIf    hInet = InternetOpen_("Mozilla/4.0", #INTERNET_OPEN_TYPE_DIRECT, IPAdress$, "", 0)    If hINet      If PostGet        If FindString(host, "\", 0)          prefixe$ = "file://"          host = ReplaceString(host, "\", "/")        Else          prefixe$ = ""        EndIf        connect_handle = InternetConnect_(hInet, prefixe$ + host, #INTERNET_DEFAULT_HTTP_PORT, "", "", #INTERNET_SERVICE_HTTP, 0, 0)      Else        If FindString(host, "\", 0)          prefixe$ = "file://"          URL = ReplaceString(URL, "\", "/")        Else          prefixe$ = "http://"        EndIf        connect_handle = InternetOpenUrl_(hInet, prefixe$ + URL, "", -1, #INTERNET_FLAG_RELOAD | #INTERNET_FLAG_EXISTING_CONNECT, 0)      EndIf      If connect_handle              If post_data$ : Verb$ = "POST" : Else : Verb$ = "GET" : EndIf        If PostGet          request_handle = HttpOpenRequest_(connect_handle, Verb$, get_URL, 0, LastURL$, 0, #INTERNET_FLAG_RELOAD, 0)        Else          request_handle = connect_handle        EndIf                If request_handle          headers.s = "Content-Type: application/x-www-form-urlencoded" + Chr(13) + Chr(10)          If post_data$ Or PostGet            HttpAddRequestHeaders_(request_handle, headers, Len(headers), #HTTP_ADDREQ_FLAG_REPLACE | #HTTP_ADDREQ_FLAG_ADD)            HttpSendRequest_(request_handle, "", 0, post_data$, Len(post_data$))          EndIf          ;          fsize = 5000          ;          BufferP = AllocateMemory(fsize)          now = Date()          YetRead = 0          Buffer = AllocateMemory(fsize)          NowOU = Date()          Repeat            Bytes = 0            Success = InternetReadFile_(request_handle, BufferP, fsize, @Bytes)            If Success = 0              ErrorOpenURL$ = "Unable to open " + host + get_url + ". : " + TextError()              OpenURLDone = 1              If Alert                MessageRequester("Error", ErrorOpenURL$, 0)              EndIf            EndIf            NowOU = Date()            If Bytes              Buffer = ReAllocateMemory(Buffer , YetRead + Bytes)              CopyMemory(BufferP, Buffer + YetRead, Bytes)              YetRead + Bytes            EndIf          Until Bytes = 0 Or Interrupt          ;          FreeMemory(BufferP)          ;          bufflen = 1000          buffer$ = Space(bufflen)          InternetQueryOption_(request_handle, #INTERNET_OPTION_URL, @buffer$, @bufflen) ; get the real URL          InternetCloseHandle_(request_handle)                    LastURL$ = buffer$        Else          ErrorOpenURL$ = "Unable to open " + host + get_url + ". : " + TextError()          OpenURLDone = 1          If Alert            MessageRequester("Error", ErrorOpenURL$, 0)          EndIf        EndIf        InternetCloseHandle_(connect_handle)      Else        ErrorOpenURL$ = "Unable to open " + host + ". : " + TextError()        OpenURLDone = 1        If Alert          MessageRequester("Error", ErrorOpenURL$, 0)        EndIf      EndIf      InternetCloseHandle_(hInet)    Else      ErrorOpenURL$ = "Unable to use the web connection. : " + TextError()      OpenURLDone = 1      If Alert        MessageRequester("Error", ErrorOpenURL$, 0)      EndIf    EndIf  EndIf;   If Buffer;     RES.s="";     RES = PeekS(Buffer);     LastPage$ = RES;     FileName$ = "temp.htm";     If CreateFile(0,FileName$);       WriteData(0,Buffer,YetRead);       CloseFile(0);     EndIf;     FreeMemory(Buffer);   EndIf  ;  ProcedureReturn Buffer EndProcedure;; IDE Options = PureBasic 6.12 LTS (Windows - x86); CursorPosition = 192; FirstLine = 144; Folding = rJ52jvBDA-; EnableXP; DPIAware; UseMainFile = ..\PBBrowser.pb