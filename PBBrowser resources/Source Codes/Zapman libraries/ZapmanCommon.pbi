; *********************************************************************;;                General functions for Zapman softwares;                     Last Update: March 2025 - 2;;     This file should be saved under the name "ZapmanCommon.pbi".;; *********************************************************************;XIncludeFile "Alert.pbi";Global FileListing$ ; Pour 'ListFiles()'                    ;CompilerIf Not Defined(GetWinErrorMessage, #PB_Procedure)  Procedure.s GetWinErrorMessage(errorCode = 0)    ;    ; Retourne un texte qui explicite l'erreur dont le numéro    ; est passé dans le paramètre 'errorCode'.    :     Protected messageBuffer$ ; Buffer pour le message    Protected MLength, length, ErrorN, MHandle    ;    If errorCode = 0      errorCode = GetLastError_()    EndIf    If errorCode      MLength = 500      messageBuffer$ = Space((MLength + 1) * 2)      length = FormatMessage_(#FORMAT_MESSAGE_FROM_SYSTEM, #Null, errorCode, 0, @messageBuffer$, MLength, #Null)      If length < 1        #ERROR_INTERNET_EXTENDED_ERROR = 12003        If errorCode = #ERROR_INTERNET_EXTENDED_ERROR          ErrorN = 0          length = InternetGetLastResponseInfo_(@ErrorN, @messageBuffer$, @MLength)          If length = 0            length = FormatMessage_(#FORMAT_MESSAGE_FROM_SYSTEM, #Null, GetLastError_(), 0, @messageBuffer$, MLength, #Null)          EndIf         Else          If errorCode > 11999 And errorCode < 13000            #FORMAT_MESSAGE_FROM_HMODULE = $00000800            MHandle = GetModuleHandle_("wininet.dll")            length = FormatMessage_(#FORMAT_MESSAGE_FROM_HMODULE, MHandle, errorCode, 0, @messageBuffer$, MLength, #Null)          EndIf        EndIf       EndIf      messageBuffer$ = ReplaceString(messageBuffer$, #LF$, "")      messageBuffer$ = ReplaceString(messageBuffer$, #CR$, "")      messageBuffer$ = Trim(messageBuffer$)      If messageBuffer$ = ""        messageBuffer$ = "Unknown error"      EndIf      ProcedureReturn messageBuffer$ + "  ($" + Hex(errorCode) + ")"    EndIf  EndProcedureCompilerEndIf;Procedure.s GetComputerName()  Protected computerNameLength = 256  Protected computerName$ = Space(computerNameLength)  GetComputerName_(@computerName$, @computerNameLength)  ProcedureReturn computerName$EndProcedure;Procedure.s GetUserName()  Protected userNameLength = 256  Protected userName$ = Space(userNameLength)  GetUserName_(@userName$, @userNameLength)  ProcedureReturn userName$EndProcedure;Procedure.i IsMemoryValid(*ptr)  Protected result.i = #False  Protected mbi.MEMORY_BASIC_INFORMATION  ;  If VirtualQuery_(*ptr, @mbi, SizeOf(MEMORY_BASIC_INFORMATION))    If mbi\State = #MEM_COMMIT And (mbi\Protect & (#PAGE_NOACCESS | #PAGE_GUARD)) = 0      result = #True    EndIf  EndIf  ;  ProcedureReturn resultEndProcedure;Procedure.s ReplaceDoubleSimpleQuoteByDoubleQuote(MyString$)  ProcedureReturn ReplaceString(MyString$, "['']", #DOUBLEQUOTE$)EndProcedure;Procedure ReadFileWithPatience(numFile, FileName$)  ; Il arrive que DropBox ou d'autres logiciels  ; de synchronisation bloquent momentanément les  ; fichiers récemment modifiés en lecture.  ; En cas d'échec à l'ouverture d'un fichier,  ; cette procédure va tenter de réitérer la  ; tentative.  ;  Protected ct, noFile  ;  If FileSize(FileName$) > 2    For ct = 1 To 20      noFile = ReadFile(numFile, FileName$, #PB_File_SharedRead | #PB_File_SharedWrite)      If noFile = 0        Delay(100)      Else        Break      EndIf    Next  EndIf  ProcedureReturn noFileEndProcedure;Procedure OpenPreferencesWithPatience(FileName$)  ; Il arrive que DropBox ou d'autres logiciels  ; de synchronosation bloquent momentanément les  ; fichiers récemment modifiés en lecture.  ; En cas d'échec à l'ouverture d'un fichier,  ; cette procédure va tenter de réitérer la  ; tentative.  ;  Protected Result, noFile  ;  Result = OpenPreferences(FileName$)  If Result = 0    noFile = ReadFileWithPatience(#PB_Any, FileName$)    If noFile      CloseFile(noFile)      Delay(5)      Result = OpenPreferences(FileName$)    EndIf  EndIf  ProcedureReturn ResultEndProcedure;CompilerIf Not Defined(min, #PB_Procedure)  Procedure min(a, b)    If a < b: ProcedureReturn a: Else : ProcedureReturn b: EndIf  EndProcedureCompilerEndIf;CompilerIf Not Defined(max, #PB_Procedure)  Procedure max(a, b)    If a > b: ProcedureReturn a: Else : ProcedureReturn b: EndIf  EndProcedureCompilerEndIf;CompilerIf Not Defined(ComputeWinOrigins, #PB_Procedure)  Procedure ComputeWinOrigins(*OX.Integer, *OY.Integer, WWidth, WHeight, ParentWindow = #CWO_ActiveWindowPos, XShiftOrPos = 0, YShiftOrPos = 0, ParentAnchor = #CWO_Center, WindowAnchor = #CWO_Center)    ;    ; Compute the X and Y origins of a window from its width (WWidth) and height (WHeight)    ; and from the parent window position or from the monitor of the parent window.    ;    ; • If ParentWindow is a valid window number, the new window will be positionned relatively to it,    ;   and then shifted by XShiftOrPos and YShiftOrPos.    ; • If ParentWindow = #CWO_ActiveWindowPos and GetActiveWindow() returns a valid window number,    ;   GetActiveWindow() will be considered as the parent window.    ; • If ParentWindow = #CWO_ActiveWindowPos and GetActiveWindow() does NOT return a valid window number,    ;   the position will be calculated relatively to the main screen.    ; • It ParentWindow = #CWO_AbsolutePos, XShiftOrPos and YShiftOrPos will be the absolute coordinates    ;   of the new window.    ; • If ParentWindow = #CWO_MonitorPos, the position will be calculated relatively to the screen where    ;   GetActiveWindow() is found or relatively to the main screen if GetActiveWindow()    ;   is not a valid window.    ;    ; • The new window will be positionned relatively to the center, top-left, top-right, bottom-left    ;   or bottom-right of the parent window (or monitor), depending on the 'ParentAnchor' parameter.    ;    ; • The anchor of the new window can be the center, top-left, top-right, bottom-left or bottom-right    ;   of the new window, depending on the 'WindowAnchor' parameter.    ;    ; • In all case, except if ParentWindow = #CWO_AbsolutePos, the position of the new window will be    ;   shifted regarding the 'XShiftOrPos' and 'YShiftOrPos' parameters.    ;    Protected DesktopLeft, DesktopRight, DesktopTop, DesktopBottom    Protected ParentWindowID, MFWindow, hMonitor, mi.MONITORINFO    ;    If ParentWindow = #CWO_AbsolutePos      *OX\i = XShiftOrPos      *OY\i = YShiftOrPos      ProcedureReturn 0    EndIf    ;    If ParentWindow = #CWO_ActiveWindowPos And IsWindow(GetActiveWindow())      ; If ParentWindow = #CWO_ActiveWindowPos, use GetActiveWindow() as parent:      ParentWindow = GetActiveWindow()    EndIf    ;    ; Get the screen coordinates for the monitor where the parent window is found:    MFWindow = ParentWindow    If Not(IsWindow(MFWindow))      MFWindow = GetActiveWindow()    EndIf    If IsWindow(MFWindow)      MFWindow = WindowID(MFWindow)    Else      ; If there is no active-window, use the main monitor:      MFWindow = 0    EndIf    ;    hMonitor = MonitorFromWindow_(MFWindow, #MONITOR_DEFAULTTONEAREST)    mi\cbSize = SizeOf(MONITORINFO)    GetMonitorInfo_(hMonitor, @mi)    ;    DesktopLeft   = DesktopUnscaledX(mi\rcWork\left)    DesktopRight  = DesktopUnscaledX(mi\rcWork\Right)    DesktopTop    = DesktopUnscaledY(mi\rcWork\top)    DesktopBottom = DesktopUnscaledY(mi\rcWork\Bottom)    ;    ;____________________________________________    ;    ; Calculate the starting point coordinates:    If IsWindow(ParentWindow)      ParentWindowID = WindowID(ParentWindow)      ;      *OX\i = WindowX(ParentWindow)      *OY\i = WindowY(ParentWindow)      ;      If ParentAnchor = #CWO_Center        *OX\i + WindowWidth(ParentWindow) / 2        *OY\i + WindowHeight(ParentWindow) / 2      ElseIf ParentAnchor = #CWO_TopRight        *OX\i + WindowWidth(ParentWindow)      ElseIf ParentAnchor = #CWO_BottomLeft        *OY\i + WindowHeight(ParentWindow)      ElseIf ParentAnchor = #CWO_BottomRight        *OX\i + WindowWidth(ParentWindow)        *OY\i + WindowHeight(ParentWindow)      EndIf    Else      ;      *OX\i = DeskTopLeft      *OY\i = DesktopTop      ;      If ParentAnchor = #CWO_Center        *OX\i / 2 + DesktopRight / 2        *OY\i / 2 + DesktopBottom / 2      ElseIf ParentAnchor = #CWO_TopRight        *OX\i = DesktopRight      ElseIf ParentAnchor = #CWO_BottomLeft        *OY\i = DesktopBottom      ElseIf ParentAnchor = #CWO_BottomRight        *OX\i = DesktopRight        *OY\i = DesktopBottom      EndIf    EndIf    ;____________________________________________    ;    ; Adjust the final coordinates regarding the new window size:    ;    WHeight + MenuHeight() + 4 ; <-- Calculate the real total height of the new window                               ;     that will be created by "OpenWindow(#PB_Any, OX, OY, WWidth, WHeight..."    If WindowAnchor = #CWO_Center      *OX\i - WWidth / 2      *OY\i - WHeight / 2    ElseIf WindowAnchor = #CWO_TopRight      *OX\i - WWidth    ElseIf WindowAnchor = #CWO_BottomLeft      *OY\i - WHeight    ElseIf WindowAnchor = #CWO_BottomRight      *OX\i - WWidth      *OY\i - WHeight    EndIf    ;    ;____________________________________________    ;    ; Shift the final position:    *OX\i + XShiftOrPos    *OY\i + YShiftOrPos    ;    ; Test if window extends beyond screen bounds due to ParentWindow position or XShiftOrPos or YShiftOrPos:    If *OX\i < DesktopLeft      *OX\i = DesktopLeft + 10    ElseIf *OX\i + WWidth > DesktopRight      *OX\i =  DesktopRight - WWidth - 10    EndIf    If *OY\i < DesktopTop      *OY\i = DesktopTop + 10    ElseIf *OY\i + WHeight > DesktopBottom      *OY\i =  DesktopBottom - WHeight - 10    EndIf    ;    ProcedureReturn ParentWindowID  EndProcedureCompilerEndIf;Procedure OpenWindowFromPrefCoordonnates(Pref_file$, WTitle$, WWidth = 300, WHeight = 300, WParam = -1)  If WParam = -1    WParam = #PB_Window_MinimizeGadget | #PB_Window_MaximizeGadget | #PB_Window_SystemMenu | #PB_Window_SizeGadget | #PB_Window_TitleBar  EndIf  ;  Protected WindowXPref, WindowYPref, WindowWidthPref, WindowHeightPref  Protected NbDesktops, k  Protected DeskTopXMin, DeskTopXMax, DeskTopYMin, DeskTopYMax  ;  NbDesktops = ExamineDesktops()  For k = 0 To NbDesktops - 1    DeskTopXMin = min(DeskTopXMin, DesktopX(k))    DeskTopXMax = max(DeskTopXMax, DesktopX(k) + DesktopWidth(k))    DeskTopYMin = min(DeskTopYMin, DesktopY(k))    DeskTopYMax = max(DeskTopYMax, DesktopY(k) + DesktopHeight(k))  Next  ;  WindowXPref = DeskTopXMin + (DeskTopXMax - DeskTopXMin - WWidth) / 2  WindowYPref = DeskTopYMin + (DeskTopYMax - DeskTopYMin - WHeight) / 2  WindowWidthPref = WWidth  WindowHeightPref = WHeight  If OpenPreferencesWithPatience(Pref_file$)    WindowXPref      = ReadPreferenceLong("WindowX", WindowXPref)    WindowYPref      = ReadPreferenceLong("WindowY", WindowYPref)    WindowWidthPref  = ReadPreferenceLong("WindowWidth", WWidth)    WindowHeightPref = ReadPreferenceLong("WindowHeight", WHeight)    ClosePreferences()  EndIf  If WindowWidthPref > DeskTopXMax    WindowWidthPref = DeskTopXMax - 40  EndIf  If WindowHeightPref > DeskTopYMax    WindowHeightPref = DeskTopYMax - 40  EndIf  If (WindowXPref + WindowWidthPref) > DeskTopXMax    WindowXPref = DeskTopXMax - WindowWidthPref - 20  EndIf  If (WindowYPref + WindowHeightPref) > DeskTopYMax    WindowYPref = DeskTopYMax - WindowHeightPref - 20  EndIf  If WindowXPref < DeskTopXMin    WindowXPref = DeskTopXMin + 20  EndIf  If WindowYPref < DeskTopYMin    WindowYPref = DeskTopYMin + 20  EndIf  ;  ProcedureReturn OpenWindow(#PB_Any, WindowXPref, WindowYPref, WindowWidthPref, WindowHeightPref, WTitle$, WParam)EndProcedure;Procedure RecordWindowDimInPref(Pref_file$, WindowHandle)  If OpenPreferencesWithPatience(Pref_file$)    WritePreferenceLong("WindowX", WindowX(WindowHandle))    WritePreferenceLong("WindowY", WindowY(WindowHandle))    WritePreferenceLong("WindowWidth", WindowWidth(WindowHandle))    WritePreferenceLong("WindowHeight", WindowHeight(WindowHandle))    ClosePreferences()  EndIfEndProcedure;Procedure OpenWaitWindow(WParent, WTexte$)  ;  Protected WaitWindow, WTextGadget  ;  If IsWindow(WParent)    WaitWindow = OpenWindow(#PB_Any, 0, 0, 400, 70, "", #PB_Window_BorderLess | #PB_Window_WindowCentered, WindowID(WParent))  Else    WaitWindow = OpenWindow(#PB_Any, 0, 0, 400, 70, "", #PB_Window_BorderLess | #PB_Window_ScreenCentered)  EndIf  ;  WTextGadget = 0  If IsWindow(WaitWindow)    StickyWindow(WaitWindow, 1)    ; Comme on a ouvert une fenêtre borderless, on lui dessine un cadre    FG = FrameGadget(#PB_Any, 1, 1, WindowWidth(WaitWindow) - 2, WindowHeight(WaitWindow) - 2, "", #PB_Frame_Flat)    GadgetList$ + Str(FG) + ","    WTextGadget = TextGadget(#PB_Any, 7, 7, (WindowWidth(WaitWindow) - 10), WindowHeight(WaitWindow) - 12, WTexte$, #PB_Text_Center)    GadgetList$ + Str(WTextGadget) + ","    ;    ; ---------------------------------------------------    ; Apply color theme if it exists:    ;    ;    CompilerIf Defined(SetFontAndGadgetsColors, #PB_Procedure)      ;      If ListSize(InterfaceColorPresets()) > 0        SetFontAndGadgetsColors(WaitWindow, InterfaceColorPresets(), GadgetList$)      EndIf      ;    CompilerEndIf  EndIf  ProcedureReturn WTextGadgetEndProcedure;Procedure DestroyParentWindow(NoGadget)  If IsGadget(NoGadget)    DestroyWindow_(GetParent_(GadgetID(NoGadget)))  EndIfEndProcedure;Procedure ShiftWindow(WindowID, xShift, yShift)  Protected hWnd, NewX, NewY  ;  ; Récupère le handle de la fenêtre  If IsWindow(WindowID)    hWnd = WindowID(WindowID)  Else    hWnd = WindowID  EndIf  ;  ; Obtenir la position actuelle de la fenêtre  Protected rect.RECT  GetWindowRect_(hWnd, rect)  ;  ; Calculer la nouvelle position  NewX = rect\left + xShift  NewY = rect\top + yShift  ;  ; Déplacer la fenêtre à la nouvelle position  SetWindowPos_(hWnd, #Null, NewX, NewY, 0, 0, #SWP_NOZORDER | #SWP_NOSIZE)EndProcedure;Global mykey$ = "064892375816";Procedure.s EncodeString(tx$)  ;  ; Very simple function to encode a string  ; using a key. Not ultra-safe, for sure,  ; but quick and simple.  ;    ;  Protected ct, l  Protected Dest$ = ""  Protected keyp = 0  ;  For ct = 1 To Len(tx$)    keyp + 1    If keyp > Len(mykey$) : keyp = 1 : EndIf    ;    l = Asc(PeekS(@tx$ + (ct - 1) * SizeOf(CHARACTER), 1)) + Val(PeekS(@mykey$ + (keyp - 1) * SizeOf(CHARACTER), 1))    Dest$ + Chr(l)  Next  ProcedureReturn (Dest$)EndProcedure;Procedure.s DecodeString(tx$)  ;  Protected ct, l  Protected Dest$ = ""  Protected keyp = 0  ;  For ct = 1 To Len(tx$)    keyp + 1    If keyp > Len(mykey$) : keyp = 1 : EndIf    ;    l = Asc(PeekS(@tx$ + (ct - 1) * SizeOf(CHARACTER), 1)) - Val(PeekS(@mykey$ + (keyp - 1) * SizeOf(CHARACTER), 1))    Dest$ + Chr(l)  Next  ProcedureReturn (Dest$)EndProcedure;Procedure GetWindowBackgroundColor(hwnd = -1)  ;  ; Thanks to Keya https://www.purebasic.fr/english/viewtopic.php?t=66974  ; for the crossplaform version figuring here:  ;  Protected Color  If IsWindow(hwnd)    color = GetWindowColor(hwnd)    If color <> -1      ProcedureReturn color    EndIf    hwnd = WindowID(hwnd)  ElseIf IsGadget(hwnd)    hwnd = GadgetID(hwnd)  EndIf  ;  CompilerSelect #PB_Compiler_OS          CompilerCase #PB_OS_Windows      color = GetSysColor_(#COLOR_WINDOW)      If color = $FFFFFF Or color = 0 : color = GetSysColor_(#COLOR_BTNFACE) : EndIf      ProcedureReturn color      ;    CompilerCase #PB_OS_Linux   ;thanks to uwekel http://www.purebasic.fr/english/viewtopic.php?p=405822      Protected *style.GtkStyle, *color.GdkColor      *style = gtk_widget_get_style_(hwnd) ; GadgetID(Gadget)) or WindowID(Window))      *color = *style\bg[0]                ; 0=#GtkStateNormal      ProcedureReturn RGB(*color\red >> 8, *color\green >> 8, *color\blue >> 8)          CompilerCase #PB_OS_MacOS   ;thanks to wilbert http://purebasic.fr/english/viewtopic.php?f=19&t=55719&p=497009      Protected.i color, Rect.NSRect, Image, NSColor = CocoaMessage(#Null, #Null, "NSColor windowBackgroundColor")      If NSColor        Rect\size\width = 1        Rect\size\height = 1        Image = CreateImage(#PB_Any, 1, 1)        StartDrawing(ImageOutput(Image))        CocoaMessage(#Null, NSColor, "drawSwatchInRect:@", @Rect)        color = Point(0, 0)        StopDrawing()        FreeImage(Image)        ProcedureReturn color      Else        ProcedureReturn - 1      EndIf  CompilerEndSelectEndProcedure ;Procedure MakeGadgetTransparent(gadgetID, alpha)  Protected hWnd = GadgetID(gadgetID)  SetWindowLongPtr_(hWnd, #GWL_EXSTYLE, GetWindowLongPtr_(hWnd, #GWL_EXSTYLE) | #WS_EX_LAYERED)  SetLayeredWindowAttributes_(hWnd, 0, alpha, #LWA_ALPHA)  SetWindowPos_(hWnd, 0, 0, 0, 0, 0, #SWP_NOMOVE | #SWP_NOSIZE | #SWP_NOZORDER | #SWP_FRAMECHANGED)EndProcedure;Procedure WhiteBoxOverWindow(ThisWindow)  ;  ; Cette procédure crée un rectange blanc semi-transparent qui va se superposer avec le contenu de la fenêtre principale  ; lorsque l'on veut montrer qu'elle est inactive.  ; Si le rectangle a déjà été créé, on se contente de le remettre aux dimensions de la fenêtre.  ;  Static IWhiteOverList$  ;  Protected OldGL, pw, pwf, MemLine$, WColor, DarkMode  Protected IWhiteOver ; Valeur de retour                       ;  If IsWindow(ThisWindow)    WColor = GetWindowBackgroundColor(ThisWindow)    If Red(WColor) + Green(WColor) + Blue(WColor) < (127 * 3)      WColor = 0    Else      WColor = $FFFFFF    EndIf    ;    ; IWhiteOverList$ contient la liste de tous les gadgets IWhiteOver créés pour    ; toutes les fenêtres ouvertes. On cherche dans IWhiteOverList$ si un IWhiteOver    ; a déjà été créé pour la fenêtre 'ThisWindow' :    pw = FindString(#CR$ + IWhiteOverList$, #CR$ + Str(ThisWindow) + #TAB$)    If pw      pwf = FindString(IWhiteOverList$, #CR$, pw)      MemLine$ = Mid(IWhiteOverList$, pw, pwf - pw)      IWhiteOver = Val(StringField(MemLine$, 2, #TAB$))    Else      OldGL = UseGadgetList(WindowID(ThisWindow))      ; On dessine le gadget :      IWhiteOver = CanvasGadget(#PB_Any, 0, 0, 1, 1)    EndIf    If IsGadget(IWhiteOver)      HideGadget(IWhiteOver, #True) ; on cache le rectangle pour le moment.      ResizeGadget(IWhiteOver, #PB_Ignore, #PB_Ignore, WindowWidth(ThisWindow), WindowHeight(ThisWindow))      If WColor = 0         Protected Output = CanvasOutput(IWhiteOver)        If Output And StartDrawing(OutPut)          Box(0, 0, DesktopScaledX(GadgetWidth(IWhiteOver)), DesktopScaledY(GadgetHeight(IWhiteOver)), WColor)          StopDrawing()        EndIf      EndIf    EndIf    If pw = 0      ;      ; On rend le gadget semi-transparent      MakeGadgetTransparent(IWhiteOver, 130)      ;      UseGadgetList(OldGL)      ;      ; On met la liste à jour :      IWhiteOverList$ + Str(ThisWindow) + #TAB$ + Str(IWhiteOver) + #CR$    EndIf    ;    ProcedureReturn IWhiteOver  EndIfEndProcedure;Procedure.s GetSystemFolder(FolderType)  ;  Protected ItemID, Location$  ;Certains commentaires sont suivis d'une astisque (*). Ca indique que la macro ne fonctionne pas toujours (elle ne renvoit rien). ; Dossier virtuel représentant le bureau Windows;   GetSystemFolder(#CSIDL_DESKTOP); Dossier virtuel représentant l'Internet                                                     *;   GetSystemFolder(#CSIDL_INTERNET); Dossier systeme contenant le groupe de programmes de l'utilisateur;   GetSystemFolder(#CSIDL_PROGRAMS); Dossier virtuel contenant les icônes du panneau de contrôle                                 *;   GetSystemFolder(#CSIDL_CONTROLS); Dossier virtuel contenant les imprimantes installées                                        *;   GetSystemFolder(#CSIDL_PRINTERS); Dossier virtuel représenté par l'icône "Mes Documents" sur le bureau;   GetSystemFolder(#CSIDL_PERSONAL); Dossier système contenant les favoris (Internet Explorer) de l'utilisateur;   GetSystemFolder(#CSIDL_FAVORITES); Dossier système contenant les programmes lancés au démarrage de la session utilisateur;   GetSystemFolder(#CSIDL_STARTUP); Dossier système contenant les raccourcis vers les document récents;   GetSystemFolder(#CSIDL_RECENT); Dossier système contenant les éléments du menu "Envoyer vers";   GetSystemFolder(#CSIDL_SENDTO); Dossier virtuel contenant les objets de la corbeille                                        *;   GetSystemFolder(#CSIDL_BITBUCKET); Dossier système contenant les éléments du menu "Démarrer" de l'utilisateur;   GetSystemFolder(#CSIDL_STARTMENU); Dossier virtuel représenté par l'icône "Mes Documents" sur le bureau                        *;   GetSystemFolder(#CSIDL_MYDOCUMENTS); Dossier système contenant les musiques de l'utilisateur;   GetSystemFolder(#CSIDL_MYMUSIC); Dossier système contenant les vidéos de l'utilisateur;   GetSystemFolder(#CSIDL_MYVIDEO); Dossier système contenant les éléments du bureau de l'utilisateur;   GetSystemFolder(#CSIDL_DESKTOPDIRECTORY); Dossier virtuel représenté par l'icône "Poste de Travail"                                   *;   GetSystemFolder(#CSIDL_DRIVES); Dossier virtuel représentant le "Voisinage Réseau"                                          *;   GetSystemFolder(#CSIDL_NETWORK); Dossier système contenant les liens vers les postes du "Voisinage Réseau";   GetSystemFolder(#CSIDL_NETHOOD); Dossier système contenant les polices;   GetSystemFolder(#CSIDL_FONTS); Dossier système contenant les modèles de documents;   GetSystemFolder(#CSIDL_TEMPLATES); Dossier système contenant les éléments du menu "Démarrer" commun;   GetSystemFolder(#CSIDL_COMMON_STARTMENU); Dossier systeme contenant le groupe de programmes commun;   GetSystemFolder(#CSIDL_COMMON_PROGRAMS); Dossier système contenant les programmes lancés au démarrage d'une session commune;   GetSystemFolder(#CSIDL_COMMON_STARTUP); Dossier système contenant les éléments du bureau commun;   GetSystemFolder(#CSIDL_COMMON_DESKTOPDIRECTORY); Dossier système contenant les données des applications de l'utilisateur;   GetSystemFolder(#CSIDL_APPDATA); Dossier système contenant les liens vers les objets du dossier virtuel "Imprimantes";   GetSystemFolder(#CSIDL_PRINTHOOD); Dossier système contenant les données des applications locales de l'utilisateur;   GetSystemFolder(#CSIDL_LOCAL_APPDATA); Dossier système contenant les programmes lancés au démarrage d'une session                  *;   GetSystemFolder(#CSIDL_ALTSTARTUP); Dossier système contenant les programmes lancés au démarrage d'une session                  *;   GetSystemFolder(#CSIDL_COMMON_ALTSTARTUP); Dossier système contenant les favoris (Internet Explorer) communs;   GetSystemFolder(#CSIDL_COMMON_FAVORITES); EndMacro; Macro GetInternetCache    ; Dossier système contenant le cache internet de l'utilisateur;   GetSystemFolder(#CSIDL_INTERNET_CACHE); Dossier système contenant les cookies de l'utilisateur;   GetSystemFolder(#CSIDL_COOKIES); Dossier système contenant l'historique de navigation de l'utilisateur;   GetSystemFolder(#CSIDL_HISTORY); Dossier système contenant les données des applications communes;   GetSystemFolder(#CSIDL_COMMON_APPDATA); Dossier système Windows (Racine du système);   GetSystemFolder(#CSIDL_WINDOWS); Dossier "System" ou "System32";   GetSystemFolder(#CSIDL_SYSTEM); Dossier "Program Files";   GetSystemFolder(#CSIDL_PROGRAM_FILES); Dossier système contenant les images de l'utilisateur;   GetSystemFolder(#CSIDL_MYPICTURES); Dossier système contenant le profil de l'utilisateur;   GetSystemFolder(#CSIDL_PROFILE); Dossier système contenant les éléments partagé des programmes;   GetSystemFolder(#CSIDL_PROGRAM_FILES_COMMON); Dossier système contenant les modèles de documents communs;   GetSystemFolder(#CSIDL_COMMON_TEMPLATES); Dossier système "Documents" commun;   GetSystemFolder(#CSIDL_COMMON_DOCUMENTS); Dossier système contenant les outils d'administration communs;   GetSystemFolder(#CSIDL_COMMON_ADMINTOOLS); Dossier système contenant les outils d'administration de l'utilisateur                      *;   GetSystemFolder(#CSIDL_ADMINTOOLS); Dossier système contenant les musiques communes;   GetSystemFolder(#CSIDL_COMMON_MUSIC); Dossier système contenant les images communes;   GetSystemFolder(#CSIDL_COMMON_PICTURES); Dossier système contenant les vidéos communes;   GetSystemFolder(#CSIDL_COMMON_VIDEO); Dossier système contenant les données à graver;   GetSystemFolder(#CSIDL_CDBURN_AREA); Dossier contenant les profils de tous les utilisateurs                                      *;   GetSystemFolder(#CSIDL_PROFILES);  If SHGetSpecialFolderLocation_(0, FolderType, @ItemID) = #NOERROR    Location$ = Space(#MAX_PATH)    If SHGetPathFromIDList_(ItemID, @Location$)      ProcedureReturn Location$    EndIf  EndIfEndProcedure;Procedure.s GetCurrentApplicationPath()  Protected AppPath$  If #PB_Compiler_Debugger    AppPath$ = #PB_Compiler_FilePath    ; While 'ZapmanComman.pb' is in 'Zapman libraries' folder    ; we much return on level up:    AppPath$ = ReplaceString(AppPath$, "Zapman libraries\", "")  Else    AppPath$ = GetPathPart(ProgramFilename())  EndIf  ProcedureReturn AppPath$EndProcedure;Procedure.s GetParentFolder(Path$)  Protected ct  Path$ = ReplaceString(GetPathPart(Path$), "/", "\")  ; Supprimer le slash ou backslash de fin, si présent  If Right(Path$, 1) = "\"    Path$ = Left(Path$, Len(Path$) - 1)  EndIf  For ct = Len(Path$) To 1 Step - 1    If Mid(Path$, ct, 1) = "\"      Break    EndIf  Next  If Mid(Path$, ct, 1) = "\"    Path$ = Left(Path$, ct)  Else    Path$ = ""  EndIf  ProcedureReturn Path$EndProcedure;CompilerIf Not(Defined(RemoveAccents, #PB_Procedure))  Procedure.s RemoveAccents(Text$)    ; Function to remove accents from a string. By Zapman.    If Text$      Protected length = Len(Text$) * 2      Protected OPos, NPos, DoubleLength      Protected NormalizedText$ = Space(Length)      ;      ; FoldString_() will replace each accentuated character by a pair of characteres      ; as this: (NonAccentuatedCharactere) + (diacritic)      Length = FoldString_(#MAP_COMPOSITE, @Text$, - 1, @NormalizedText$, Length) - 1      ;      ; Examine the result:      If Length > 0 And Length <> Len(Text$)        DoubleLength = (Length - 1) * 2        For NPos = 0 To DoubleLength Step 2          If PeekC(@Text$ + OPos) <> PeekC(@NormalizedText$ + NPos)            ; If the character has been replaced, replace it into the original text:            PokeC(@Text$ + OPos, PeekC(@NormalizedText$ + NPos))            ; The following character contains the diacritic. Jump over it:            NPos + 2          EndIf          OPos + 2        Next      EndIf      ;      ProcedureReturn Text$    EndIf  EndProcedureCompilerEndIf;Procedure.s FilePartSsExt(NF$)  NF$ = GetFilePart(NF$)  Protected p = Len(GetExtensionPart(NF$))  If p    NF$ = Left(NF$, Len(NF$) - p - 1)  EndIf  ProcedureReturn NF$EndProcedure;Procedure.s AssainitNomFic(tx$, GardeChiffre = 1)  ;  Protected NF$, mtx$, l, tx2$, ct  ;  FilePartSsExt(NF$)  mtx$ = tx$  tx$ = Left(RemoveAccents(tx$), 30)  If GardeChiffre    ; on récupère les chiffres qui sont à la fin du nom, s'il y en a    l = Len(mtx$) + 1    While l > 1 And (Val(Mid(mtx$, l - 1, 1)) > 0 Or Mid(mtx$, l - 1, 1) = "0") : l - 1 : Wend    If l < Len(mtx$) + 1 And Right(tx$, Len(mtx$) - l) <> Right(mtx$, Len(mtx$) - l)      tx$ + Mid(mtx$, l)    EndIf  EndIf      tx2$ = ""  For ct = 1 To Len(tx$)    If Asc(Mid(tx$, ct, 1)) < 48 Or (Asc(Mid(tx$, ct, 1)) > 57 And Asc(Mid(tx$, ct, 1)) < 65) Or (Asc(Mid(tx$, ct, 1)) > 90 And Asc(Mid(tx$, ct, 1)) < 97) Or Asc(Mid(tx$, ct, 1)) > 122      If Mid(tx$, ct, 1) <> " " And Mid(tx$, ct, 1) <> "-"        tx2$ + "_"      Else        tx2$ + Mid(tx$, ct, 1)      EndIf    Else      tx2$ + Mid(tx$, ct, 1)    EndIf  Next  ProcedureReturn tx2$EndProcedure;Procedure IsMouseOverGadget(NoGadget)  ;  Protected  re.RECT, pt.POINT, Result  ;  If IsGadget(NoGadget)    GetWindowRect_(GadgetID(NoGadget), @re)     GetCursorPos_(pt)    If PtInRect_(re, pt\y << 32 + pt\x)      pt\x - re\left      pt\y - re\top      Result = @pt    Else      Result = 0    EndIf  Else    Debug "Erreur dans IsMouseOverGadget(NoGadget) : ''NoGadget'' n'existe pas"  EndIf  ProcedureReturn Result EndProcedure;Procedure ClickOverGadget(TargetGadget, mouseButton = #MK_LBUTTON)  ; Simule un clic de souris dans le gadget TargetGadget.  ; Cela ne fonctionne que si le curseur de la souris  ; se trouve effectivement au-dessus de ce gadget.  ;  Protected CursorPos.point, GadgetRect.rect, Coordonates  Protected wDButton, wUButton  ;  If mouseButton = #MK_LBUTTON    wDButton = #WM_LBUTTONDOWN    wUButton = #WM_LBUTTONUP  ElseIf mouseButton = #MK_RBUTTON    wDButton = #WM_RBUTTONDOWN    wUButton = #WM_RBUTTONUP    mouseButton = #MK_RBUTTON  EndIf  If wDButton And IsGadget(TargetGadget)    GetCursorPos_(CursorPos)    GetWindowRect_(GadgetID(TargetGadget), @GadgetRect)    If PtInRect_(GadgetRect, CursorPos\y << 32 + CursorPos\x)      CursorPos\x - GadgetRect\left      CursorPos\y - GadgetRect\top      Coordonates = CursorPos\x | (CursorPos\y << 16)      ; Simule un clic      ; Button DOWN      SendMessage_(GadgetID(TargetGadget), wDButton, mouseButton, Coordonates)      ; Button UP      SendMessage_(GadgetID(TargetGadget), wUButton, mouseButton, Coordonates)      ;      ProcedureReturn #True    EndIf    ;  EndIfEndProcedure;Procedure TransfertClickToGadget()  ;  ; Lorsqu'une fenêtre inactive redevient active  ; (c'est-à-dire lorsque l'utilisateur à d'abord cliqué  ; sur une fenêtre autre que celle de l'application,  ; puis qu'il a cliqué sur la fenêtre de l'application),  ; le gadget dans lequel l'utilisateur a cliqué ne reçoit  ; pas les coordonnées du clic. Le premier clic a pour  ; seul effet de rendre la fenêtre active, et il faut  ; recliquer pour que le gadget reçoive le clic.  ;  ; Cette procédure corrige cela en simulant immédiatement  ; un deuxième clic, lorsque la fenêtre est réactivée.    Static OldActiveWindow  ;  Protected mouseButton  Protected RetValue = #False  ;  If GetActiveWindow() > -1 And OldActiveWindow = -1    ;    Protected ActiveGadget = GetActiveGadget()    ;    If ActiveGadget <> -1      ; Vérifie si un bouton de la souris est appuyé :      If GetAsyncKeyState_(#VK_LBUTTON) & $8000        mouseButton = #MK_LBUTTON      ElseIf GetAsyncKeyState_(#VK_RBUTTON) & $8000        mouseButton = #MK_RBUTTON      EndIf      ;      RetValue = ClickOverGadget(ActiveGadget, mouseButton)    EndIf  EndIf  ;  OldActiveWindow = GetActiveWindow()  ProcedureReturn RetValue  ;EndProcedure;Procedure IsVertScrollBarVisible(Gadget)  Protected iGwlStyle = GetWindowLongPtr_(GadgetID(Gadget), #GWL_STYLE)  If (iGwlStyle & #WS_VSCROLL)    ProcedureReturn #True  Else    ProcedureReturn #False  EndIfEndProcedure;Procedure FirstOccurrence(MainString$, OccList$, spos = 0, limpos = 0, Mode = #PB_String_CaseSensitive)  ;  ; Recherche, dans 'MainString$', la première occurrence de l'une des expressions contenues par 'OccList$'  ; à partir de la position 'spos', jusqu'à la position 'limpos'.  ; Si 'spos' vaut zéro, la recherche se fera depuis le début de 'MainString$'.  ; Si 'limpos' vaut zéro, la recherche se fera jusqu'à la fin de 'MainString$'.  ;  ; Cette fonction ne présente un intérêt par rapport à 'FindString' que si OccList$ comporte plusieurs valeurs  ; qui devront être renseignées sous la forme "valeur1,valeur2,etc." (sans espace, sauf si votre expression comprend des espaces).  ; Si une valeur doit comporter une virgule, remplacez la virgule par l'expression "\comma_".  ;  Protected l, sfind, sfind2, occ$  ;  OccList$ + ","  sfind = 0  l = 0  Repeat    l + 1    occ$ = StringField(OccList$, l, ",")    If occ$      occ$ = ReplaceString(occ$, "\comma_", ",")      sfind2 = FindString(MainString$, occ$, spos, Mode)      If sfind2 And (sfind2 < sfind Or sfind = 0) And (limpos = 0 Or sfind2 < limpos)        sfind = sfind2      EndIf    EndIf  Until occ$ = ""  ProcedureReturn sfindEndProcedure;Macro MFirstOccurenceOfChar(FOFCString)  ;  Protected l, sfind, sfind2, occ$  ;  sfind = 0  For l = 1 To Len(OccList$)    occ$ = Mid(OccList$, l, 1)    sfind2 = FindString(FOFCString, occ$, spos, Mode)    If sfind2 And (sfind2 < sfind Or sfind = 0) And (limpos = 0 Or sfind2 < limpos)      sfind = sfind2    EndIf  NextEndMacro;Procedure FirstOccurrenceOfChar(MainString$, OccList$, spos = 0, limpos = 0, Mode = #PB_String_CaseSensitive)  ;  ; Recherche, dans 'MainString$', la première occurrence de l'un des caractères contenus par 'OccList$'  ; à partir de la position 'spos', jusqu'à la position 'limpos'.  ; Si 'spos' vaut zéro, la recherche se fera depuis le début de 'MainString$'.  ; Si 'limpos' vaut zéro, la recherche se fera jusqu'à la fin de 'MainString$'.  ;  MFirstOccurenceOfChar(MainString$)  ProcedureReturn sfindEndProcedure;Procedure FirstOccurrenceOfCharPointed(*MainString.String, OccList$, spos = 0, limpos = 0, Mode = #PB_String_CaseSensitive)  ;  ; Recherche, dans '*MainString\s', la première occurrence de l'un des caractères contenus par 'OccList$'  ; à partir de la position 'spos', jusqu'à la position 'limpos'.  ; Si 'spos' vaut zéro, la recherche se fera depuis le début de '*MainString\s'.  ; Si 'limpos' vaut zéro, la recherche se fera jusqu'à la fin de '*MainString\s'.  ;  ; Plutôt que de passer le paramètre '*MainString' en chaîne, ce qui peut  ; consommer de la mémoire et du temps, si la chaîne est longue, on travaille  ; avec un pointeur sur une structure String. Ainsi, la chaîne n'est pas  ; duppliquée en mémoire au moment de l'appel.  MFirstOccurenceOfChar(*MainString\s)  ProcedureReturn sfindEndProcedure;Procedure EraseBalloonToolTip(Tooltip)  DestroyWindow_(Tooltip)EndProcedure;Procedure InitBalloonToolTip(WindowNumber)  ;  ; Crée une fenêtre de type "balloon" pour afficher une aide ou des renseignements  ; au moment du survol d'un gadget.  ;  Protected Tooltip = CreateWindowEx_(0, "ToolTips_Class32" , "" , #WS_POPUP | #TTS_NOPREFIX | #TTS_BALLOON , 0, 0, 0, 0, WindowID(WindowNumber), 0, GetModuleHandle_(0), 0)  SendMessage_(Tooltip, #TTM_SETTIPTEXTCOLOR , GetSysColor_(#COLOR_INFOTEXT), 0)  SendMessage_(Tooltip, #TTM_SETTIPBKCOLOR , GetSysColor_(#COLOR_INFOBK), 0)  SendMessage_(Tooltip, #TTM_SETMAXTIPWIDTH , 0, 250) ; ICI 250 représente la largeur de la bulle  SendMessage_(Tooltip, #TTM_SETDELAYTIME, #TTDT_INITIAL , 1000)  SendMessage_(Tooltip, #TTM_SETDELAYTIME, #TTDT_AUTOPOP , 10000)  SendMessage_(Tooltip, #TTM_SETDELAYTIME, #TTDT_RESHOW , 1)  ProcedureReturn TooltipEndProcedure;Procedure AddBalloonToolTip(Tooltip, GadgetNumber, Text.s)  Protected Balloon.TOOLINFO  Balloon\cbSize = SizeOf(TOOLINFO)  Balloon\uFlags = #TTF_IDISHWND | #TTF_SUBCLASS   Balloon\hwnd = GadgetID(GadgetNumber)  Balloon\uId = GadgetID(GadgetNumber)  Balloon\lpszText = @Text  ProcedureReturn SendMessage_(Tooltip, #TTM_ADDTOOL , 0, @Balloon)EndProcedure;Procedure RemoveBalloonToolTip(Tooltip, GadgetNumber)  Protected Balloon.TOOLINFO  Balloon\cbSize = SizeOf(TOOLINFO)  Balloon\uFlags = #TTF_IDISHWND   Balloon\hwnd = GadgetID(GadgetNumber)  Balloon\uId = GadgetID(GadgetNumber)  ProcedureReturn SendMessage_(Tooltip, #TTM_DELTOOL, 0, @Balloon)EndProcedure;Procedure CreatePathFolders(FileName$)  ;  ; Examine le chemin de FileName$ et crée  ; les différents dossiers qui composent ce chemin,  ; s'ils n'existent pas déjà  ;  Protected ProgressivePath$, NextFolder$, nl  ;  FileName$ = ReplaceString(FileName$, "/", "\")  ;  If FileName$ And FindString(FileName$, "\")    ProgressivePath$ = ""    nl = 0    Repeat      nl + 1      NextFolder$ = StringField(FileName$, nl, "\")      ProgressivePath$ + NextFolder$ + "\"      If nl > 1 And FileSize(ProgressivePath$) <> -2        If CreateDirectory(ProgressivePath$) = 0          Alert("Unable to create directory : " + ProgressivePath$)        EndIf      EndIf     Until ProgressivePath$ = GetPathPart(FileName$)  EndIfEndProcedure;Procedure CreateFileWithPatience(NomFichier$, Option = 0)  Protected ct, noFile  ;  For ct = 1 To 10    noFile = CreateFile(#PB_Any, NomFichier$, Option)    If noFile = 0      Delay(100)    Else      Break    EndIf  Next  ProcedureReturn noFileEndProcedure;Procedure.s FileToText(FileName$, FileFormat = -1, Silence = 0)  ;  ; Quelle que soit la valeur donnée à FileFormat, si ReadStringFormat(noFile) retourne  ; une valeur, elle aura la priorité.  ;  ; Si FileFormat vaut zéro et que le fichier n'a pas de BOM, la lecture se fera au format  ; indiqué par la variable globale BOM. Si BOM n'a pas de valeur, la lecture se fera en ASCII.  ;  ; Cette procédure va toutefois essayer de corriger le tir, si le résultat obtenu  ; semble contenir des caractères UTF8 alors qu'il a été lu en ascii, une nouvelle lecture  ; sera tentée. Et inversement.  ;  ; Si TakeOffLF a une valeur non nulle, les caractères de fin de ligne sont supprimés  ; du contenu récupéré.  ;  Global BOM  ;  Protected mFileFormat, mBOM, fsize, noFile, RSF, ReadingPosition  Protected FileContent$, UTF8Test, ASCIITest, mFileContent$, TakeOffLF  ;  mFileFormat = FileFormat    If FileFormat = -1    FileFormat = #PB_UTF8 ; Format par défaut.  ElseIf FileFormat = 1  ; Raccourci pour demander une lecture au format Unicode    FileFormat = #PB_Unicode    mFileFormat = #PB_Unicode  ElseIf FileFormat = 0  ; Si zéro est passé en paramètre, en prend le format du dernier fichier lu.    FileFormat = BOM    mFileFormat = BOM  EndIf  mBOM = BOM  If FileFormat <> #PB_Ascii And FileFormat <> #PB_UTF8 And FileFormat <> #PB_Unicode    ; On ne supporte que ces trois formats.    FileFormat = #PB_Ascii  EndIf  ;  fsize = FileSize(FileName$)  ;  If fsize > 2    noFile = ReadFileWithPatience(#PB_Any, FileName$)  EndIf  ;  If noFile    RSF = ReadStringFormat(noFile) ; détection du format de fichier    If Loc(noFile)      ; Si Loc(noFile) est supérieur à zéro, c'est qu'un format a réellement été lu.      ; Cette vérification est nécessaire, car ReadStringFormat() renvoie la valeur ASCII      ; quand il n'y a aucun BOM enregistré dans le fichier.      ; On ne lui fera donc confiance que si un format est réellement enregistré.      FileFormat = RSF    Else      RSF = 0 ; On garde en mémoire le fait que le fichier n'avait pas de BOM.    EndIf    ;    ReadingPosition = Loc(noFile)    ;    FTT_StartReading:     ;    FileContent$ = ReadString(noFile, FileFormat | #PB_File_IgnoreEOL)        If FileContent$      If RSF = 0 Or mFileFormat <> FileFormat  ; Un format de lecture à été explicitement déclaré.                                               ; et on n'a trouvé aucun BOM dans le fichier pour                                               ; confirmer son format. Ou bien les deux ne concordent pas.        ;        ; On va regarder si le texte lu comporte des indicateurs semblant        ; démontrer qu'il n'a pas été lu dans le bon format.        ; Si l'on en trouve, on choisira le format le plus probable,        ; en fonction du nombre de caractères à problème que l'on        ; aura trouvés.        If FileFormat = #PB_Ascii          ; Le fichier a été lu en ASCII.          UTF8Test = CountString(FileContent$, "Ã")          ; Si UTF8Test n'est pas nul, il y a sans doute un problème.          ; Le caractère 'Ã' se retrouve typiquement dans un fichier UTF-8          ; lu en mode ASCII.          If UTF8Test > ASCIITest            If ASCIITest = 0              ; On a lu en ascii, mais le fichier est apparemment en UTF-8 !              FileFormat = #PB_UTF8              FileSeek(noFile, ReadingPosition)              mFileContent$ = FileContent$              Goto FTT_StartReading            Else              FileContent$ = mFileContent$            EndIf          EndIf        EndIf        ;        If FileFormat = #PB_UTF8          ; Le fichier a été lu en UTF8.          ASCIITest = CountString(FileContent$, Chr(65533))          ; Le caractère 65533 se retrouve typiquement dans un fichier ASCII          ; lu en mode UTF8.          If ASCIITest > UTF8Test            If UTF8Test = 0              ; On a lu en UTF-8, mais le fichier est apparemment en ascii !              FileFormat = #PB_Ascii              FileSeek(noFile, ReadingPosition)              mFileContent$ = FileContent$              Goto FTT_StartReading            Else              FileContent$ = mFileContent$            EndIf          EndIf        EndIf      EndIf      BOM = FileFormat    EndIf    CloseFile(noFile)    ;    If FileContent$ And TakeOffLF      FileContent$ = ReplaceString(FileContent$, #LF$, "")      FileContent$ = ReplaceString(FileContent$, #CR$, " ")    EndIf      ElseIf fsize < 3 And Silence = 0    MessageRequester("Error", "Unable To Read " + FileName$ + #CR$ + "File is empty!", #PB_MessageRequester_Ok)  ElseIf (Silence = 2 Or Silence = 0)    MessageRequester("Error", "Unable to read " + FileName$ + #CR$ + "It's perhaps allready open by another program...", #PB_MessageRequester_Ok)    If Silence = 0      End    EndIf  EndIf  ;  ProcedureReturn FileContent$EndProcedure;Procedure TexteDansFichier(NomFichier$, Texte$, Encodage = #PB_UTF8, CheckMod = 0, addBOM = 0)  ;  Protected p, DebText$, ThisFile, Result  ; Variables déclarées mais non utilisées : CheckMod ********* (PPBrowser comment)  ;  If NomFichier$ = ""    alert("TexteDansFichier: The file name is empty!", "Error")    CallDebugger  Else    If BOM And Encodage = -1      Encodage = BOM    ElseIf Encodage = 0      p = 1      While Mid(Texte$, p, 1) = " " Or Mid(Texte$, p, 1) = #CR$ Or Mid(Texte$, p, 1) = #LF$ Or Mid(Texte$, p, 1) = #TAB$ : p + 1 : Wend      If Mid(Texte$, p, 1) = "<" ; Il semble que l'on ait affaire à un fichier HTML        DebText$ = LCase(Left(Texte$, 2000)) ; on examine le début du texte à enregistrer        DebText$ = ReplaceString(DebText$, " ", ""); afin de reconnaître les instructions d'encodage HTML        DebText$ = ReplaceString(DebText$, #LF$, "") ; si le fichier en contient        DebText$ = ReplaceString(DebText$, #CR$, "")        DebText$ = ReplaceString(DebText$, #TAB$, "")        DebText$ = ReplaceString(DebText$, "'", #DOUBLEQUOTE$)        If FindString(DebText$, "charset=utf-8", 0) Or FindString(DebText$, "charset=" + #DOUBLEQUOTE$ + "utf-8" + #DOUBLEQUOTE$, 0) Or FindString(DebText$, "encoding=" + #DOUBLEQUOTE$ + "utf-8" + #DOUBLEQUOTE$, 0)          Encodage = #PB_UTF8          BOM = #PB_UTF8        ElseIf FindString(DebText$, "charset=iso-8859-1", 0) Or FindString(DebText$, "charset=" + #DOUBLEQUOTE$ + "iso-8859-1" + #DOUBLEQUOTE$, 0) Or FindString(DebText$, "encoding=" + #DOUBLEQUOTE$ + "iso-8859-1" + #DOUBLEQUOTE$, 0)          Encodage = #PB_Ascii          BOM = #PB_Ascii        EndIf      EndIf    EndIf    ;    CreatePathFolders(NomFichier$)    ;    ThisFile = CreateFileWithPatience(NomFichier$, Encodage)    If ThisFile = 0      MessageRequester("Ooops!", "Unable to create the file " + #CR$ + NomFichier$, #PB_MessageRequester_Ok)      CallDebugger    Else      p = 1      While Mid(Texte$, p, 1) = " " Or Mid(Texte$, p, 1) = #CR$ Or Mid(Texte$, p, 1) = #LF$ Or Mid(Texte$, p, 1) = #TAB$ : p + 1 : Wend      If addBOM And Mid(Texte$, p, 1) <> "<" ; don't add BOM in HTML files.        WriteStringFormat(ThisFile, Encodage)        ;      EndIf      ;      WriteString(ThisFile, Texte$, Encodage)      CloseFile(ThisFile)      Result = 1    EndIf  EndIf  ProcedureReturn ResultEndProcedure;Procedure ListFiles(directory.s , filename.s, extension.s , directoryid.l = 0, ReadHiddenFile = 0, StopIfOneFind = 0, DirectorySearch = 0, LevelLimit = 0, TimeLimit = 0, Silence = 0)  ; Author: Sebi (english forum)  ; Extended and Adapted by Zapman  ;  ; Give the complete content of a directory  ; Donne le contenu complet d'un dossier  ;  ; Le résultat figurera dans la variable globale FileListing$  ;  ; OR / OU  ; Give the content corresponding to filename and extension criterias  ; Donne le contenu correspondant aux critères contenus dans filename et extension  ;  ; Exemples pour extension : "*", "bmp" ou "gif;bmp"  ; Examples for extension: "*", "bmp" or "gif;bmp"  ;  ; Exemples pour filename : "*" ou "NomDuFichier"  ; Examples for filename: "*" or "NameOfFile"  ;  ; Result is returned into the FileListing$ variable  ; This variable must be GLOBAL in order to transmit the result to your program  ;  ; If StopIfOneFind is set to 1, the search will stop after the first find matching parameters  ;  ; If DirectorySearch is set to 1, the search will only concern directory names  ;  ; LevelLimit will limit the level of search in directories.  ; If you set it to 1, the function will only search at the first level of the directory given in parameter  ;  ; TimeLimit can define in milliseconds the maximum time allowed for the search  ;  ; Cette procédure est récursive (elle s'appelle elle-même).  ;  ;  Shared ListFileInitLevel, ListFileOrigineTime  ;  Protected  Attributs, cont, DirType, file.s, this_extension.s, this_filename.s, Nbpliste  ;  extension = ReplaceString(extension, ".", "")  ;  If directory    If FileSize(directory) > 0 ; Un nom de fichier a été donné en paramètre      Attributs = GetFileAttributes(directory)      If Attributs & #PB_FileSystem_Hidden = 0 Or ReadHiddenFile        FileListing$ + directory + #CR$      EndIf    Else      filename = LCase(filename)      extension = LCase(ReplaceString(extension, " ", ""))      If Right(directory, 1) <> "\"         directory + "\"       EndIf       If directoryid = 0        ListFileInitLevel = CountString(directory, "\")        ListFileOrigineTime = ElapsedMilliseconds()        FileListing$ = ""      EndIf      directoryid = ExamineDirectory(#PB_Any, directory, "")      If IsDirectory(directoryid)        cont = 1        Repeat          If NextDirectoryEntry(directoryid)            DirType = DirectoryEntryType(directoryid)            file.s = DirectoryEntryName(directoryid)            Select DirType               Case #PB_DirectoryEntry_File                If DirectorySearch = 0                  Attributs = DirectoryEntryAttributes(directoryid)                  If Attributs & #PB_FileSystem_Hidden = 0 Or ReadHiddenFile                    this_extension.s = LCase(GetExtensionPart(file))                    this_filename.s = LCase(Left(file, Len(file) - Len(this_extension)))                     If Len(this_extension)                       this_filename = Left(this_filename, Len(this_filename) - 1)                     EndIf                    If FindString(";" + extension + ";", ";" + this_extension + ";", 0) Or extension = "*"                       If FindString(";" + filename + ";", ";" + this_filename + ";", 0) Or filename = "*"                         file.s = directory + DirectoryEntryName(directoryid)                         ;file contains the full path and filename                         FileListing$ + file + #CR$                                                Nbpliste + 1                      EndIf                     EndIf                   EndIf                EndIf              Case #PB_DirectoryEntry_Directory                If file <> "." And file <> ".."                  If DirectorySearch And (FindString(";" + filename + ";", ";" + LCase(file) + ";", 0) Or filename = "*")                    FileListing$ + directory + file + "\" + #CR$                    Nbpliste + 1                  EndIf                  If (LevelLimit = 0 Or (CountString(directory, "\") - ListFileInitLevel) < (LevelLimit - 1))                    ListFiles(directory + file + "\", filename, extension, directoryid + 1, ReadHiddenFile, StopIfOneFind, DirectorySearch, LevelLimit, TimeLimit, Silence)                  EndIf                EndIf             EndSelect           Else            Cont = 0          EndIf        Until Cont = 0 Or (StopIfOneFind And FileListing$) Or (TimeLimit And (ElapsedMilliseconds() - ListFileOrigineTime) > TimeLimit)        FinishDirectory(directoryid)      Else        If Silence = 0          MessageRequester("Ooop !", "Impossible d'examiner le répertoire " + directory)        EndIf      EndIf    EndIf  EndIfEndProcedure;Procedure ListEmptyFolders(directory.s)  ;  ; Dresse la liste des répertoires vides contenus dans 'directory'  ; Le résultat est retourné dans la variable globale   'EmptyFolder$'  ;  ;  ; Cette procédure est récursive (elle s'appelle elle-même).  ;  Global EmptyFolder$  ;  Protected  directoryid, cont, st, DirType, file.s, deb  ;  If directory And FileSize(directory) < 0    If Right(directory, 1) <> "\"       directory + "\"     EndIf     If directoryid = 0      FileListing$ = ""    EndIf    directoryid = ExamineDirectory(#PB_Any, directory, "")    If directoryid      cont = 1      st = 0      Repeat        If NextDirectoryEntry(directoryid) = 0          Cont = 0        Else          DirType = DirectoryEntryType(directoryid)          file.s = DirectoryEntryName(directoryid)          Select DirType             Case #PB_DirectoryEntry_File              st + 1            Case #PB_DirectoryEntry_Directory              If file <> "." And file <> ".."                st + ListEmptyFolders(directory + file + "\")              EndIf           EndSelect         EndIf        deb = 0      Until Cont = 0      If st = 0        EmptyFolder$ + directory + #CR$      EndIf      FinishDirectory(directoryid)    Else      MessageRequester("Ooop !", "Impossible d'examiner le répertoire " + directory)    EndIf  EndIf  ProcedureReturn stEndProcedure;Procedure.s ChangeFileExtension(NFile$, NewExt$)  If NFile$ = "" Or NewExt$ = ""    Alert("L'un des paramètres de ''ChangeFileExtension'' est vide !")  Else    NewExt$ = ReplaceString(NewExt$, ".", "")    NFile$ = Left(NFile$, Len(NFile$) - Len(GetExtensionPart(NFile$)))    If Right(NFile$, 1) <> "."      NFile$ + "."    EndIf    ProcedureReturn NFile$ + NewExt$  EndIfEndProcedure;Procedure IsStringNum(EString$)  ; Examine la chaîne de caractères 'EString$'  ; pour voir si elle contient une valeur numérique.  Protected ct  Protected TS$ = "0123456789.$%"  ;  For ct = 1 To Len(EString$)    If FindString(TS$, PeekS(@EString$ + (ct - 1) * SizeOf(CHARACTER), 1)) = 0      ProcedureReturn #False    EndIf  Next  ProcedureReturn #TrueEndProcedure ;Procedure KillPrg(ProcessName.s)    ;   Protected snapshot.i   Protected prinfo.PROCESSENTRY32   Protected phandle.i   Protected PN$, Result   Protected pexitc.i   prinfo\dwSize = SizeOf(PROCESSENTRY32)   snapshot = CreateToolhelp32Snapshot_(#TH32CS_SNAPPROCESS, 0)   If snapshot      If Process32First_(snapshot, prinfo)         Repeat           PN$ = UCase(PeekS(@prinfo\szExeFile))            If UCase(ProcessName) = GetFilePart(PN$)               phandle = OpenProcess_(#PROCESS_TERMINATE, #False, prinfo\th32ProcessID)                If phandle                   Result = TerminateProcess_(phandle, @pexitc)                                    CloseHandle_(phandle)               EndIf            EndIf         Until Process32Next_(snapshot, prinfo) = 0      EndIf      CloseHandle_(snapshot)   EndIf   ProcedureReturn Result EndProcedure  ;Structure EnumWindows_Data  ApplicationName$  HideOrShow$EndStructure;Procedure.l HideOrShowAppWindowCallback(hFind, *EWData.EnumWindows_Data)  ;  Protected Result  ;  Protected WindowName.s = Space(255)  Protected WindowClass.s = Space(255)  Protected mparam  Protected dontchangeit  ;  If GetWindowText_(hFind, WindowName, 255)        Result = GetClassName_(hFind, WindowClass, 255)    ;    If WindowClass <> "Button" And WindowClass <> "Progman"      If FindString(LCase(WindowName), LCase(*EWData\ApplicationName$), 0)        If LCase(*EWData\HideOrShow$) = "minimize"          mparam = #SW_MINIMIZE        ElseIf LCase(*EWData\HideOrShow$) = "maximize"          mparam = #SW_MAXIMIZE        ElseIf LCase(*EWData\HideOrShow$) = "show" Or FindString(LCase(*EWData\HideOrShow$), "front")          mparam = #SW_RESTORE        ElseIf LCase(*EWData\HideOrShow$) = "hide"          mparam = #SW_HIDE        Else          dontchangeit = 1        EndIf        If dontchangeit = 0          ShowWindow_(hFind, mparam)        EndIf        If FindString(LCase(*EWData\HideOrShow$), "front")          SetForegroundWindow_(hFind)        EndIf      EndIf    EndIf  EndIf  ProcedureReturn 1EndProcedure;Procedure HideOrShowAnApplicationWindow(ApplicationName$, HideOrShow$)  ;  ; HideOrShow$ can contain "Hide", "Show" (or "Bring to front"), "Minimize" and "Maximize".  ;  Protected EWData.EnumWindows_Data  EWData\HideOrShow$ = HideOrShow$  EWData\ApplicationName$ = ApplicationName$  EnumWindows_(@HideOrShowAppWindowCallback(), @EWData)EndProcedure;Procedure CheckRunningProg(ProgName$)  ;  Protected result.l, Snapshot.l, ProcessFound.l, PN$, Process.PROCESSENTRY32  ;  Process\dwSize = SizeOf(PROCESSENTRY32)  Snapshot = CreateToolhelp32Snapshot_(#TH32CS_SNAPPROCESS, 0)  If Snapshot    ProcessFound = Process32First_(Snapshot, Process)    While ProcessFound      PN$ = UCase(PeekS(@Process\szExeFile));, #PB_Any))      If UCase(ProgName$) = GetFilePart(PN$)        result = #True        ProcessFound = 0      Else        ProcessFound = Process32Next_(Snapshot, Process)      EndIf    Wend    CloseHandle_(Snapshot)  EndIf  ProcedureReturn resultEndProcedure;Procedure.s ProgramfileNameFromWindow(WindowID)  ;  Protected ProcessID, Process32, Snapshot, ProcessEntry.PROCESSENTRY32, ProgramfileName.s  ;  GetWindowThreadProcessId_(WindowID, @ProcessID)    Process32 = OpenLibrary(#PB_Any, "kernel32.dll")   If Process32    Snapshot = CallFunction(Process32, "CreateToolhelp32Snapshot", #TH32CS_SNAPPROCESS, 0)     If Snapshot       ProcessEntry\dwSize = SizeOf(PROCESSENTRY32)       If CallFunction(Process32, "Process32First", Snapshot, @ProcessEntry)         Repeat          If ProcessID = ProcessEntry\th32ProcessID             ProgramfileName = PeekS(@ProcessEntry\szExeFile, 1000, #PB_Ascii)            Break          EndIf        Until CallFunction(Process32, "Process32Next", Snapshot, @ProcessEntry) = 0      EndIf          CloseHandle_(Snapshot)     EndIf     CloseLibrary(Process32)   EndIf   ProcedureReturn ProgramfileNameEndProcedure;Procedure.l SetForegroundExplorerWindow(hWnd, lParam)  Protected windowText.s = Space(255)  Protected className.s = Space(255)  Protected *folderPath.String = lParam  ; Récupère le texte et la classe de la fenêtre  GetWindowText_(hWnd, @windowText, 255)  GetClassName_(hWnd, @className, 255)    ; Vérifie si la classe correspond à une fenêtre de l'explorateur  If className = "CabinetWClass" Or className = "ExplorerWClass"    If FindString(LCase(windowText), LCase(*folderPath\s), 0) ; Compare le titre de la fenêtre      ; Met la fenêtre au premier plan et restaure si nécessaire      ShowWindow_(hWnd, #SW_RESTORE)      SetForegroundWindow_(hWnd)      ProcedureReturn #False ; Stoppe l'énumération, la fenêtre a été trouvée    EndIf  EndIf    ProcedureReturn #True ; Continue l'énumérationEndProcedureProcedure OpenFolderIfNotOpen(folderPath.s)  Protected folder.String  folder\s = folderPath    ; Vérifie si la fenêtre du dossier est déjà ouverte  If EnumWindows_(@SetForegroundExplorerWindow(), @folder)    ; Ouvre le dossier si aucune fenêtre n'a été trouvée    ShellExecute_(0, "open", folderPath, "", "", #SW_SHOWNORMAL)  EndIfEndProcedure;Procedure WaitForEventAchieve()  ;  ; Wait for system redrawing windows and gadgets  ; without loosing PureBasic or other events.  ;  ; This is equivalent to "While WindowEvent() : Wend"  ; except that it doesn't erase messages.  ;  ; This is also equivalent to a simple 'delay(1)'  ; except that duration is not fixed here : the procedure  ; get out of the loop when current operation (as redrawing  ; a window) is completed.  ;  Protected msg.MSG  ;  While PeekMessage_(@msg, 0, 0, 0, #PM_NOREMOVE)    TranslateMessage_(@msg)    DispatchMessage_(@msg)  WendEndProcedure;Procedure.i IsGadgetHidden(GadgetID.i)  ; Retourne 1 si le gadget est masqué, sinon 0  ;  If IsGadget(GadgetID) And IsWindowVisible_(GadgetID(GadgetID)) = 0    ProcedureReturn #True  Else    ProcedureReturn #False  EndIfEndProcedure;Procedure.s StrDate(Date)  ProcedureReturn FormatDate("%dd/%mm/%yyyy-%hh:%ii:%ss", Date)EndProcedure;Procedure ValDate(Date$)  ProcedureReturn ParseDate("%dd/%mm/%yyyy-%hh:%ii:%ss", Date$)EndProcedure;Procedure.s DecimalToBinary(number.i)  ;  Protected binary.s = ""  Protected bit.i  ;  If number = 0    binary = "0"  EndIf    While number > 0    bit = number & 1    binary = Str(bit) + binary    number >> 1  Wend    While Len(binary) < 16    binary = "0" + binary  Wend    binary = Left(binary, 8) + " " + Mid(binary, 9)    ProcedureReturn binaryEndProcedure;Procedure.i TestBit(BinaryNumber.i, BitNumber.i)  ;  ; Vérifie si le BitNumber est valide  ;  If BitNumber < 0 Or BitNumber >= 32 ; On suppose ici que les entiers sont de 32 bits    ProcedureReturn - 1 ; Retourne -1 en cas de BitNumber invalide  EndIf    ; Déplace le bit à tester à la position 0 et applique un AND avec 1  Protected result.i = (BinaryNumber >> (BitNumber - 1)) & 1    ProcedureReturn resultEndProcedure;Procedure ReverseFindString(MainString$, SearchString$, posdep = 0, FMode = #PB_String_CaseSensitive)  ;  ; Recherche 'SearchString$' dans 'MainString$' en remontant à partir de la position 'posdep'.  ; (cherche si 'SearchString$' se trouve avant la position posdep).  ;  ; Si 'posdep' vaut zéro ou n'est pas renseigné, on cherche à partir de la fin de 'MainString$'  ;  If SearchString$ ; pour éviter de perdre du temps pour rien    If posdep : posdep = Len(MainString$) - posdep + 1 : EndIf    Protected Result = FindString(ReverseString(MainString$), ReverseString(SearchString$), posdep, FMode)    If Result      Result = Len(MainString$) - Len(SearchString$) - Result + 2    EndIf  EndIf  ProcedureReturn ResultEndProcedure;Procedure OpenUrl(URL.s, Alert = 0, post_data$ = "", LastURL$ = "")  ;   ; Can read a HTML page or any file through Internet (picture or other)  ;  ; Readen data is returned as a pointer to a buffer.  ; This buffer must be cleaned by FreeMemory(Buffer) after use.  ;  ; To post data to the URL, fill post_data$ with your data.  ;  ; To give a referrer to the URL, fill "LastURL$" with the URL which you want to declare as the referrer.  ;  ; If declared as ''global'', after return LastURL$ will contain the real URL which answered to the request  ; (if there is a redirection, this could be different from the URL.s entry parameter)  ;  ; To know if an error as occured, declare "ErrorOpenURL$" as a global variable  ; and check it after "OpenUrl"  ;  ; If you want the user to be informed about errors, set "Alert" to a non zero value.   ;  Protected ErrorOpenURL$, IPAdress$, p, host.s, get_url.s, Buffer, PostGet, hInet  Protected prefixe$, connect_handle, Verb$, request_handle, headers.s, fsize, BufferP  Protected now, YetRead, NowOU, Bytes, Success, OpenURLDone, bufflen, buffer$, Interrupt  ;   #INTERNET_OPEN_TYPE_DIRECT = 1   #HTTP_ADDREQ_FLAG_ADD = $20000000   #HTTP_ADDREQ_FLAG_REPLACE = $80000000   #INTERNET_FLAG_SECURE = $800000  #INTERNET_FLAG_RELOAD = $80000000  #INTERNET_FLAG_EXISTING_CONNECT = $20000000  #HTTP_QUERY_CONTENT_LENGTH = 5  #HTTP_QUERY_URI = 13  #INTERNET_OPTION_URL = 34    ;   ; Type of connection (could be FTP Gopher etc). HTTPS is done as HTTP too.   ;   #INTERNET_SERVICE_HTTP = 3     ;   ; HTTP port is 80, HTTPS (SSL) port is 443.   ;   #INTERNET_DEFAULT_HTTP_PORT = 80   ErrorOpenURL$ = ""  IPAdress$ = "127.0.0.1:" + Str(#INTERNET_DEFAULT_HTTP_PORT)  If URL    If Left(URL, 1) = #DOUBLEQUOTE$ : URL = Right(URL, Len(URL) - 1) : EndIf    If Right(URL, 1) = #DOUBLEQUOTE$ : URL = Left(URL, Len(URL) - 1)  : EndIf    URL = ReplaceString(URL, " ", "%20")    URL = RemoveString(URL, "http://")    URL = ReplaceString(URL, "//", "/")        p = 0    While p < Len(URL) And Mid(URL, p, 1) <> "/" And Mid(URL, p, 1) <> "\" : p + 1 : Wend    ;p + 1    host.s = Left(URL, p - 1)    get_url.s = Right(URL, Len(URL) - p + 1)    Buffer = 0    If post_data$ Or LastURL$      PostGet = 1    EndIf    hInet = InternetOpen_("Mozilla/4.0", #INTERNET_OPEN_TYPE_DIRECT, IPAdress$, "", 0)    If hINet      If PostGet        If FindString(host, "\", 0)          prefixe$ = "file://"          host = ReplaceString(host, "\", "/")        Else          prefixe$ = ""        EndIf        connect_handle = InternetConnect_(hInet, prefixe$ + host, #INTERNET_DEFAULT_HTTP_PORT, "", "", #INTERNET_SERVICE_HTTP, 0, 0)      Else        If FindString(host, "\", 0)          prefixe$ = "file://"          URL = ReplaceString(URL, "\", "/")        Else          prefixe$ = "http://"        EndIf        connect_handle = InternetOpenUrl_(hInet, prefixe$ + URL, "", -1, #INTERNET_FLAG_RELOAD | #INTERNET_FLAG_EXISTING_CONNECT, 0)      EndIf      If connect_handle              If post_data$ : Verb$ = "POST" : Else : Verb$ = "GET" : EndIf        If PostGet          request_handle = HttpOpenRequest_(connect_handle, Verb$, get_URL, 0, LastURL$, 0, #INTERNET_FLAG_RELOAD, 0)        Else          request_handle = connect_handle        EndIf                If request_handle          headers.s = "Content-Type: application/x-www-form-urlencoded" + #CRLF$          If post_data$ Or PostGet            HttpAddRequestHeaders_(request_handle, headers, Len(headers), #HTTP_ADDREQ_FLAG_REPLACE | #HTTP_ADDREQ_FLAG_ADD)            HttpSendRequest_(request_handle, "", 0, post_data$, Len(post_data$))          EndIf          ;          fsize = 5000          ;          BufferP = AllocateMemory(fsize)          now = Date()          YetRead = 0          Buffer = AllocateMemory(fsize)          NowOU = Date()          Repeat            Bytes = 0            Success = InternetReadFile_(request_handle, BufferP, fsize, @Bytes)            If Success = 0              ErrorOpenURL$ = "Unable to open " + host + get_url + ". : " + GetWinErrorMessage()              OpenURLDone = 1              If Alert                MessageRequester("Error", ErrorOpenURL$, 0)              EndIf            EndIf            NowOU = Date()            If Bytes              Buffer = ReAllocateMemory(Buffer , YetRead + Bytes)              CopyMemory(BufferP, Buffer + YetRead, Bytes)              YetRead + Bytes            EndIf          Until Bytes = 0 Or Interrupt          ;          FreeMemory(BufferP)          ;          bufflen = 1000          buffer$ = Space(bufflen)          InternetQueryOption_(request_handle, #INTERNET_OPTION_URL, @buffer$, @bufflen) ; get the real URL          InternetCloseHandle_(request_handle)                    LastURL$ = buffer$        Else          ErrorOpenURL$ = "Unable to open " + host + get_url + ". : " + GetWinErrorMessage()          OpenURLDone = 1          If Alert            MessageRequester("Error", ErrorOpenURL$, 0)          EndIf        EndIf        InternetCloseHandle_(connect_handle)      Else        ErrorOpenURL$ = "Unable to open " + host + ". : " + GetWinErrorMessage()        OpenURLDone = 1        If Alert          MessageRequester("Error", ErrorOpenURL$, 0)        EndIf      EndIf      InternetCloseHandle_(hInet)    Else      ErrorOpenURL$ = "Unable to use the web connection. : " + GetWinErrorMessage()      OpenURLDone = 1      If Alert        MessageRequester("Error", ErrorOpenURL$, 0)      EndIf    EndIf  EndIf;   If Buffer;     RES.s="";     RES = PeekS(Buffer);     LastPage$ = RES;     FileName$ = "temp.htm";     If CreateFile(0,FileName$);       WriteData(0,Buffer,YetRead);       CloseFile(0);     EndIf;     FreeMemory(Buffer);   EndIf  ;  ProcedureReturn Buffer EndProcedure;; IDE Options = PureBasic 6.21 Beta 2 (Windows - x86); CursorPosition = 682; FirstLine = 421; Folding = r+bu2Eo-hi+-; EnableXP; DPIAware