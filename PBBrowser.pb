; ***************************************************************************;;                               PBBrowser;;                         By Zapman - Oct. 2024;                      created with PureBasic 6.12;                           For Windows only.;       Version number is registered in PBB_NumVersion$ just bellow.;; ***************************************************************************;; To Do : Modification des préférence (police de titre et couleurs);         Liste des chaînes.;;;#NomProg = "PBBrowser";Global PBB_NumVersion$ = "Beta 0.6"If #PB_Compiler_64Bit  PBB_NumVersion$ + " x64"ElseIf #PB_Compiler_32Bit  PBB_NumVersion$ + " x86"EndIf;Global debugging = #False ; Utilisée par les versions beta pour tracer certaines fonctions.;XIncludeFile "PBBrowser resources\Source Codes\PBBrowserDeclarations.pb"XIncludeFile "PBBrowser resources\Source Codes\PBBrowserInitialize.pb"XIncludeFile "PBBrowser resources\Source Codes\AddToolToPureBasic.pb"XIncludeFile "PBBrowser resources\Source Codes\HelpAndTools.pb"XIncludeFile "PBBrowser resources\Source Codes\FindInPBCode.pb";If PBBFirstLaunch And PureBasicProgAdr$ And Not (IsToolAllreadyInstalled("PB Browser"))  If AlertYesNoCancel(GetTextFromCatalog("ShouldInstall"), "", #AW_YesOrNo_YesByDefault) = #PB_MessageRequester_Yes    InstallPBBrowserAndPrintResult()  EndIfEndIf;; **********************************************************************************;;        Procédures générales, utilisées par plusieurs parties du programme;; **********************************************************************************;;Procedure ManageWaitingWindow(PriorityMode = #WorkInBackGround, ToPrint$ = "", EProgBarTitle$ = "")  ;  ; Cette procédure est destinée à afficher une fenêtre d'attente, pour les procédures  ; dont l'exécution dure longtemps. La gestion de ce système est assez simple :  ; Il suffit d'intégrer la ligne 'ManageWaitingWindow(MyAppWindow)' dans une boucle  ; pour que la fenêtre apparaîsse automatiquement si l'exécution de la boucle dure  ; plus de 300 millisecondes.  ;  ; On appellera 'CloseWaitingWindow()' pour fermer cette fenêtre d'attente   ; quand la boucle d'exécution sera terminée.  ;  ; Pour fonctionner, cette procédure a besoin que 'WhiteBoxOverWindow' ait été  ; appelée après la création de la fenêtre principale de l'application ('MainWindow')  ;  ; Au bout de 300 millisecondes après le premier appel, un voile blanc est affiché  ; devant la fenêtre principale.  ; Au bout de 500 millisecondes après le premier appel, une petite fenêtre est créée  ; au centre de la fenêtre principale, avec le message GetTextFromCatalog("SearchInProgress").  ; Après 500 millisecondes, et toutes les 350 millisecondes, le message est suivi  ; d'un nombre de points qui va en croissant.  ;  ; Dans la version actuelle de PBBrowser, la fenêtre d'attente n'a plus l'occasion  ; de s'afficher, puisque toutes les opérations liées à l'exploration profonde sont  ; découpées en tranches de 200 ms, et ne bloquent plus la navigation de l'utilisateur.  ; Ce système de fenêtre d'attente avait été mis au point pour des versions antérieures  ; et a été conservé pour une éventuelle évolution du programme.  ;  ; La première partie de cette procédure est cependant toujours utile : elle met à jour  ; le texte de GPBBGadgets\TProgressBar afin d'afficher, au fur et à mesure de l'exploration,  ; le type d'élément qui est en cours d'examen. 'EProgBarTitle$' est le paramètre qui  ; doit contenir le texte à afficher; Ce texte est mis à jour toutes les 200 ms.  ;  ; Variables déclarées mais non utilisées : TotTPBTime, LastEProgBarTitle$  ;  Shared PBBWaitingGadget  ;  Static LastUpdateForWaitingMS, LastValueForToPrint$, LastUpdateForPBarTitleMS, TotTPBTime  ;  Static LastEProgBarTitle$  ;  If EProgBarTitle$ And IsGadget(GPBBGadgets\TProgressBar) And ElapsedMilliseconds() - LastUpdateForPBarTitleMS > 200    If Len(EProgBarTitle$) > 17      ; 17 est la longueur limite de ce que peut afficher GPBBGadgets\TProgressBar.      SetGadgetText(GPBBGadgets\TProgressBar, EProgBarTitle$)    Else      SetGadgetText(GPBBGadgets\TProgressBar, GetTextFromCatalog("Exploration") + " " + EProgBarTitle$)    EndIf    LastUpdateForPBarTitleMS = ElapsedMilliseconds()    ;    ; Les lignes qui suivent permettent de connaître le durée de chaque type d'opération    ; lors de l'exploration profonde. Cela m'a permis d'optimiser les procédures    ; employées pour ce travail.;     If LastEProgBarTitle$ <> EProgBarTitle$;       If LastEProgBarTitle$;         Debug LastEProgBarTitle$ + " : "+Str(ElapsedMilliseconds()-TotTPBTime)+" ms.";       EndIf;       LastEProgBarTitle$ = EProgBarTitle$;       TotTPBTime = ElapsedMilliseconds();     EndIf  EndIf  ;  If PriorityMode <> #WorkInBackGround    If ElapsedMilliseconds() - LastUpdateForWaitingMS > 1000      ; Houlà ! LastUpdateForWaitingMS n'a pas été mis à jour depuis longtemps.      ; Nous sommes sans doute dans le premier appel de cette procédure      ; au sein d'une boucle.      ; On se contente de mettre LastUpdateForWaitingMS à jour.      LastUpdateForWaitingMS = ElapsedMilliseconds()    Else      If PBBWaitingGadget = 0 And ElapsedMilliseconds() - LastUpdateForWaitingMS > 500        ; La fenêtre d'attente n'est pas encore ouverte. On l'ouvre.        DisablePBBWindow()        If ToPrint$ = ""          ToPrint$ = GetTextFromCatalog("SearchInProgress")        EndIf        LastValueForToPrint$ = ""        PBBWaitingGadget = OpenWaitWindow(GPBBGadgets\PBBWindow, ToPrint$)        LastUpdateForWaitingMS = ElapsedMilliseconds()        WaitForEventAchieve()      ElseIf IsGadgetHidden(GPBBGadgets\IWhiteOver) And (ElapsedMilliseconds() - LastUpdateForWaitingMS) > 300        HideGadget(GPBBGadgets\IWhiteOver, #False) ; Affiche un voile blanc devant la fenêtre principale        WaitForEventAchieve()      ElseIf ElapsedMilliseconds() - LastUpdateForWaitingMS > 350 And IsGadget(PBBWaitingGadget)        ; La fenêtre d'attente est ouverte. On met le message à jour.        If LastValueForToPrint$ = ToPrint$ Or ToPrint$ = ""          ToPrint$ = GetGadgetText(PBBWaitingGadget)        Else          LastValueForToPrint$ = ToPrint$          ToPrint$ + Chr(13)        EndIf        ToPrint$ = ReplaceString(ToPrint$, Chr(13), Chr(13) + ".")        SetGadgetText(PBBWaitingGadget, ToPrint$)        LastUpdateForWaitingMS = ElapsedMilliseconds()        WaitForEventAchieve()      EndIf    EndIf  EndIfEndProcedure;Procedure CloseWaitingWindow()  Shared PBBWaitingGadget  ;  If PBBWaitingGadget    ; Si la fenêtre d'attente est ouverte, on la ferme.    DestroyParentWindow(PBBWaitingGadget)    PBBWaitingGadget = 0  EndIf  EnablePBBWindow()EndProcedure;Procedure.s FullAdresseToRelativeAdresse(Adr$, RefAdr$)  ;  ; Destinée au calcul des valeurs de IncludedFile, cette procédure convertit l'adresse  ; d'une page sur le disque ( "C:\Mes Document\DossierWeb\sous_dossier\nomdefichier.htm" , par exemple)  ; en adresse relative vers cette page ( "sous_dossier/nomdefichier.htm" )  ;  ; La variable RefAdr$ (adresse de référence) doit contenir le path vers le fichier contenant 'IncludedFile Adr$'  ;  Protected PosInText  ;  PosInText = 1  RefAdr$ = ReplaceString(GetPathPart(RefAdr$), "\", "/")  Adr$ = ReplaceString(Adr$, "\", "/") ; au cas où  ;  If Right(RefAdr$, 1) <> "/" : RefAdr$ + "/" : EndIf  If LCase(FastLeft(Adr$, 7)) <> "http://" And LCase(FastLeft(Adr$, 8)) <> "https://"  And LCase(FastLeft(Adr$, 4)) <> "www."    While PosInText <= Len(RefAdr$) And FastMid(RefAdr$, PosInText, 1) = FastMid(Adr$, PosInText, 1) : PosInText + 1 : Wend ; on détermine la racine commune    While PosInText > 1 And FastMid(Adr$, PosInText - 1, 1) <> "/" : PosInText - 1 : Wend ; On remonte jusqu'à / (les 2 noms peut avoir leurs premières lettres identiques)    Adr$ = Right(Adr$, Len(Adr$) - PosInText + 1)    While RefAdr$      PosInText = FindString(RefAdr$, "/", PosInText)      If PosInText        Adr$    = "../" + Adr$        RefAdr$ = Right(RefAdr$, Len(RefAdr$) - PosInText)        PosInText = 0      Else        RefAdr$ = ""      EndIf    Wend  EndIf  ProcedureReturn Adr$EndProcedure;Procedure.s RelativeAdresseToFullAdresse(RelAdr$, RefAdr$)  ;  ; Destinée au décodage des valeurs de IncludedPath et IncludedFile, cette procédure convertit l'adresse relative  ; d'une page ( "sous_dossier/nomdefichier.htm", par exemple), en adresse sur le disque.  ;  ; La variable RefAdr$ (adresse de référence) doit contenir le path vers le fichier contenant 'IncludedFile RelAdr$'  ;  ; Example :  ; Si RelAdr$ contient une adresse relative (comme "..\DropUpLoad\cree_menu.php")  ; et RefAdr$ contient une adresse de référence (comme "D:\LUC\Dropbox\RankSpiritDev\CSSMenuManager\CSSMenuManager.pb")  ; La valeur retournée sera D:\LUC\Dropbox\RankSpiritDev\DropUpLoad\cree_menu.php"  ;  Protected NewPath$, NewAdr$, PosInText, pf  ;  NewPath$ = GetPathPart(RefAdr$)  RelAdr$ = ReplaceString(RelAdr$, "/", "\")  RelAdr$ = ReplaceString(RelAdr$, "\\", "\")  If RelAdr$    NewAdr$ = NewPath$ + RelAdr$  EndIf  ;  Repeat    PosInText = FindString(NewAdr$, "\..\")    ; La notation '..\' indique qu'il faut remonter d'un niveau dans l'arborescence des dossiers.    If PosInText      pf = PosInText + 4      ; On remonte donc d'un niveau...      While PosInText And FastMid(NewAdr$, PosInText - 1, 1) <> "\" : PosInText - 1 : Wend      If PosInText And pf <= Len(NewAdr$)        ; et on efface le niveau en même temps que '..\'        NewAdr$ = FastLeft(NewAdr$, PosInText - 1) + FastMid(NewAdr$, pf)      EndIf    EndIf  Until PosInText = 0  ProcedureReturn NewAdr$EndProcedure;Structure ElementContentStruct  EC_FSource$  EC_LCase.i  EC_StartingPos.i  EC_Content.StringEndStructure;NewList ElementContentListing.ElementContentStruct();Procedure GetPointedElementContentFromFile(FSource$, ElementStartingPos, ElementEndingPos, ReturnLCase = #False)  ;  ; Extrait du fichier FSource$ la portion de code balisée par les positions  ; données en paramètres.  ;  ; Pour gagner du temps, les extraits sont conservés en mémoire-cache.  ; La valeur de retour est un pointeur sur une chaîne String et ce pointeur  ; demeure valide hors de la procédure parce que la chaîne est conservée  ; dans un tableau 'Shared'.  ;  Shared ElementContentListing()  ;  Protected *SPointer.string, LS  ;  Protected Found = 0  ForEach ElementContentListing()    If ElementContentListing()\EC_FSource$ = FSource$ And ElementContentListing()\EC_StartingPos = ElementStartingPos And ElementContentListing()\EC_LCase = ReturnLCase      Found = 1      Break    EndIf  Next  ;  If Found = 0    AddElement(ElementContentListing())    ElementContentListing()\EC_FSource$ = FSource$    ElementContentListing()\EC_LCase = ReturnLCase    ElementContentListing()\EC_StartingPos = ElementStartingPos    *SPointer.string = GetPointedCodeFromFile(FSource$, ReturnLCase)    If *SPointer      LS = Len(*SPointer\s)      If ElementStartingPos < LS And ElementEndingPos < LS And *SPointer\s <> "Error"        ElementContentListing()\EC_Content\s = FastMid(*SPointer\s, ElementStartingPos, ElementEndingPos - ElementStartingPos)      Else        ElementContentListing()\EC_Content\s = "Error"      EndIf    EndIf  EndIf  ProcedureReturn ElementContentListing()\EC_Content  ;EndProcedure;Procedure EraseObsoleteElementsContents(FileName$)  ;  Shared ElementContentListing()  ;  ForEach ElementContentListing()    If ElementContentListing()\EC_FSource$ = FileName$      ; On nous demande de supprimer tous les extraits de code      ; que nous avons en mémoire pour le fichier 'FileName$'      DeleteElement(ElementContentListing())    EndIf  NextEndProcedure;Procedure.s CompleteListOfFiles(FileName$, ParentFileName$ = "", PriorityMode = #WorkInBackGround, ErrorWhileReadingFile$ = "")  ;  ; À partir de l'adresse d'un fichier PureBasic,  ; fait la liste des fichiers inclus (par IncludeFile ou XIncludeFile).  ;  ; Le résultat est stocké dans la chaîne 'PBBListOfFiles$"  ; sous la forme 'AdresseFichierInclus + chr(9) + 'AdresseFichierIncluant' + chr(13)  ;  ; PBBListOfFiles$ doit avoir été déclarée comme une variable globale en amont.  ;  ;   Protected *SearchString.String, PosInCode, pf, Included$, CAdr$  Protected mp, SStrLength, IncludePathMem$  ;  If FileName$    If FileSize(FileName$) < 2       If FindString(ErrorWhileReadingFile$, FileName$ + Chr(13)) = 0        ErrorWhileReadingFile$ + FileName$ + Chr(13)      EndIf    Else      If FindString(PBBListOfFiles$, FileName$ + Chr(9), 0) = 0        PBBListOfFiles$ + FileName$ + Chr(9) + ParentFileName$ + Chr(13)        *SearchString = GetPointedCodeFromFile(FileName$, #False)        ManageWaitingWindow(PriorityMode)        PosInCode = 0        Repeat          PosInCode = FindInPBPointedCode(*SearchString, "IncludePath,IncludeFile,XIncludeFile", PosInCode + 1)          If PosInCode            mp = PosInCode            PosInCode + 11            PosInCode = FirstOccurrenceOfChar(*SearchString\s, " (" + Chr(34), PosInCode)            If PosInCode              SStrLength = Len(*SearchString\s)              ;              ; On saute les espaces qui suivent :              Repeat                PosInCode + 1                If PosInCode < SStrLength                  CChar = PeekC(@*SearchString\s + (PosInCode - 1) * SizeOf(CHARACTER))                EndIf              Until CChar <> 32 And Chr(CChar) <> "(" And PosInCode < SStrLength              ;              If CChar = 34                PosInCode + 1                pf = FindString(*SearchString\s, Chr(34), PosInCode)                If pf                  CAdr$ = FastMid(*SearchString\s, PosInCode, pf - PosInCode)                  If mp + Len("IncludePath") <= SStrLength And FastMid(*SearchString\s, mp, Len("IncludePath")) = "IncludePath"                    IncludePathMem$ + CAdr$ + "\"                  Else                    Included$ = RelativeAdresseToFullAdresse(IncludePathMem$ + CAdr$, FileName$)                    ErrorWhileReadingFile$ = CompleteListOfFiles(Included$, FileName$, PriorityMode, ErrorWhileReadingFile$) ; Appel récursif.                  EndIf                EndIf              EndIf            EndIf          EndIf        Until PosInCode = 0      EndIf    EndIf  EndIf  ProcedureReturn ErrorWhileReadingFile$EndProcedure;Procedure.s SetListOfFiles(FileName$, PriorityMode = #WorkInBackGround)  ;  ; À partir de l'adresse d'un fichier PureBasic,  ; fait la liste des fichiers inclus par IncludeFile ou XIncludeFile  ; de façon récursive.  ;  ; Le résultat est stocké dans la chaîne 'PBBListOfFiles$"  ; sous la forme 'AdresseFichierInclus + chr(9) + 'AdresseFichierIncluant' + chr(13)  ;  ; PBBListOfFiles$ doit avoir été déclarée comme une variable globale en amont.  ; LidtProc$ aussi, puisque cette variable est initialisée ici.  ;  Protected ErrorWhileReadingFile$  Protected *FirstFileContent.String  Protected mFileName$, AdrFP$, PosInCode, pf  ;  PBBListOfFiles$ = ""  If FileName$    *FirstFileContent = GetPointedCodeFromFile(FileName$, #False)    If *FirstFileContent\s = ""      ; Le fichier est vide ou inexistant      ProcedureReturn FileName$    Else      ; On regarde si le fichier dont on vient d'avoir l'adresse a pour paramètre      ; un 'Fichier principal' (voir la commande 'Compilateur/Option du compilateur...'      ; dans l'éditeur de PureBasic).      mFileName$ = FileName$      AdrFP$ = ""      PosInCode = FindString(*FirstFileContent\s, Chr(13) + "; UseMainFile = ")      If PosInCode        ;        ; Le fichier a un 'Fichier principal' pour paramètre. Nous allons partir        ; de ce fichier principal pour établir la liste des fichiers.        PosInCode + Len("; UseMainFile = ")        pf = FindString(*FirstFileContent\s, Chr(13), PosInCode)        If pf = 0          pf = Len(*FirstFileContent\s) + 1        EndIf        AdrFP$ = Trim(FastMid(*FirstFileContent\s, PosInCode, pf - PosInCode))        AdrFP$ = RelativeAdresseToFullAdresse(AdrFP$, FileName$)        If FileSize(AdrFP$) > 2          FileName$ = AdrFP$        EndIf      EndIf      ErrorWhileReadingFile$ = CompleteListOfFiles(FileName$, "", PriorityMode)      ;      If FindString(PBBListOfFiles$, mFileName$) = 0        ; Il y a un problème !        ; Il semble que l'adresse dont nous sommes partis désignait AdrFP$ comme fichier principal,        ; mais AdrFP$ ne comporte pas l'adresse d'origine dans sa liste de fichiers inclus.        ; Résultat : l'adresse dont nous sommes partis ne figure pas dans PBBListOfFiles$.        ; Ça ne va pas. On intègre l'adresse d'origine et ses éventuels fichiers 'included'.        FileName$ = mFileName$        ErrorWhileReadingFile$ = CompleteListOfFiles(FileName$, "", PriorityMode, ErrorWhileReadingFile$)      EndIf      ;      If ErrorWhileReadingFile$        AlertInPBBWindow(GetTextFromCatalog("ErrorWhileReadingFile") + Chr(13) + ErrorWhileReadingFile$)      EndIf      ;      CloseWaitingWindow()    EndIf  EndIf  ProcedureReturn FileName$EndProcedure;Procedure.s PurifyElementName(ElementName$)  ;  ; Cette procédure supprime les parenthèses et la mention du type d'élément  ; (pour les variables), afin de s'assurer que l'élément est bien trouvé  ; dans les listes et dans le code. Le nom d'élément est retourné en LCase  ; car toutes les recherches se font sur des versions LCase du code et des  ; listes.  ;  Protected pp  ;  ElementName$ = Trim(StringField(ElementName$, 1, Chr(8239)))  ;  pp = FindString(ElementName$, ":")  If pp    ElementName$ = FastLeft(ElementName$, pp - 1)  EndIf  pp = FindString(ElementName$, "(")  If pp    ElementName$ = FastLeft(ElementName$, pp - 1)  EndIf  pp = FindString(ElementName$, ".")  If pp    ElementName$ = FastLeft(ElementName$, pp - 1)  EndIf  ProcedureReturn LCase(ElementName$)EndProcedure;Procedure.s ExtractSectionArroundExpression(*CodeString.String, Expression$, posInCode, KeepComment = #False, CheckInCode = #CheckAll | #CheckOneKeyWordOnly)  ; Vérifie que Expression$ n'est pas située entre guillemets ou en commentaire  ; dans le code figurant dans *CodeString, puis extrait la section de ligne  ; contenant l'expression, en éliminant, éventuellement,  ; les parties de ligne figurant avant et après ":".  ; Si posInCode vaut zéro au moment de l'appel de procédure, l'Expression$ est recherchée  ; à l'intérieur de *CodeString, sinon, PosInCode est censée contenir cette position.  ;  ; Si KeepComment = #True, une copie du commentaire qui figurait dans la ligne  ; est laissée dans la variable partagée 'PBBLComment$'.  ;  ; Si CheckInCode = #NoCheck, le travail sera fait en présumant qu'on ne se trouve pas  ; entre guillemets ou en commentaire.  ;  Protected posdepR, posEndR, posInLine, BreakInLine, mBreakInLine, FullLine.String  Shared PBBLComment$  ;  If posInCode = 0    posInCode = FindInPBPointedCode(*CodeString, Expression$, 1, CheckInCode)  EndIf  If PosInCode    ; On remonte au début de ligne :    posdepR = posInCode    ;While posdepR And Mid(*CodeString\s,posdepR,1) <> Chr(13) : posdepR - 1 : Wend    FastFindPrecReturn(*CodeString\s, posdepR)    posdepR + 1    ; On cherche la fin de ligne :    posEndR = FindString(*CodeString\s, Chr(13), posInCode)    If posEndR = 0 : posEndR = Len(*CodeString\s) + 1 : EndIf    ; On extrait la ligne complète :    FullLine\s = FastMid(*CodeString\s, posdepR, posEndR - posdepR)    ; On vérifie que l'expression trouvée est encadrée par des séparateurs valides    ; et si CheckInCode = #CheckAll, on vérifie aussi qu'elle n'est pas    ; entre guillemets ou dans un commentaire.    posInLine = FindInPBPointedCode(FullLine, Expression$, 1, CheckInCode)    If PosInLine      ; Si la ligne est composée de plusieurs tronçons séparés par ":",      ; on enlève les tronçons qui précèdent celui qui nous intéresse :      BreakInLine = 0      Repeat        mBreakInLine = BreakInLine        If CheckInCode & #CheckOnlyComAndQuote          BreakInLine = FindInPBPointedCode(FullLine, ":", BreakInLine + 1, #CheckOnlyComAndQuote | #CheckOneKeyWordOnly)        Else          BreakInLine = FindString(FullLine\s, ":", BreakInLine + 1)        EndIf      Until BreakInLine = 0 Or BreakInLine > PosInLine      If mBreakInLine        FullLine\s = FastMid(FullLine\s, mBreakInLine + 1)      EndIf      ;      ; S'il y a des tronçons derrière, on les enlève aussi,      ; et on enlève le commentaire éventuel.      If KeepComment = #True        If CheckInCode & #CheckOnlyComAndQuote          BreakInLine = FindInPBPointedCode(FullLine, ";", 1, #CheckOnlyComAndQuote | #CheckOneKeyWordOnly)        Else          BreakInLine = FindString(FullLine\s, ";", 1)        EndIf        If BreakInLine          PBBLComment$ = FastMid(FullLine\s, BreakInLine)          FullLine\s = FastLeft(FullLine\s, BreakInLine - 1)        Else          PBBLComment$ = ""        EndIf        If CheckInCode & #CheckOnlyComAndQuote          BreakInLine = FindInPBPointedCode(FullLine, ":", 1, #CheckOnlyComAndQuote | #CheckOneKeyWordOnly)        Else          BreakInLine = FindString(FullLine\s, ";", 1)        EndIf      Else        BreakInLine = FindInPBPointedCode(FullLine, ":,;", 1, #CheckOnlyComAndQuote)      EndIf      If BreakInLine        FullLine\s = FastLeft(FullLine\s, BreakInLine - 1)      EndIf      FullLine\s = Trim(FullLine\s)    Else      FullLine\s = ""    EndIf  Else    FullLine\s = ""  EndIf  ProcedureReturn FullLine\sEndProcedure;#FindBeginningBy = -1;Macro CheckIfElementExistsInList(ElementList, ElementName, TypeOfElement)  ; Regarde si l'élément nommé 'ElementName$' figure déjà dans la liste 'ElementList'.  ;  EFName$ = ElementName  ExistingElement = 0  Repeat    mExistingElement = ExistingElement + 1    If TypeOfElement = #FindBeginningBy      ExistingElement = FindString(ElementList, EFName$, mExistingElement)    Else      If TypeOfElement = #PBBLabel And Right(EFName$, 1) <> ":"        EFName$ + ":"      EndIf      ExistingElement = FindString(ElementList, EFName$ + Chr(9), mExistingElement)      If ExistingElement = 0 And TypeOfElement = #PBBVariable        ExistingElement = FindString(ElementList, EFName$ + ".", mExistingElement)      EndIf    EndIf    ;        ; On teste les 3 cas de figure possibles :    ; 1- le nom de l'élément n'est pas dans la liste,    ; 2- le nom de l'élément est dans la liste en première position,    ; 3- le nom de l'élément est dans la liste et il est précédé du caractère Chr(13) :  Until ExistingElement = 0 Or ExistingElement = 1 Or PeekS(@ElementList + (ExistingElement - 2) * SizeOf(CHARACTER), 1) = Chr(13);FastMid(ElementList, ExistingElement - 1, 1) = Chr(13)  ; Cette façon de procéder permet de vérifier que le nom de l'élément trouvé  ; dans la liste est bien encadré d'un Chr(9) sur son côté droit et d'un Chr(13)  ; sur son côté gauche (à moins qu'il ne s'agisse du tout premier élément de la liste).  ; Ainsi, on ne confondra pas, par exemple, 'TestThis' avec 'TestThisAgain',  ; ou 'TestThis' avec 'NewTestThis'.  ;  ; On suppose implicitement qu'il n'existera pas deux éléments portant le même nom,  ; car PureBasic n'autorise pas un tel cas de figure, à moins que les deux éléments  ; soient de types différents (on peut avoir une structure qui porte le même nom  ; qu'une procédure, mais pas deux structures qui portent le même nom, par exemple).  ; Comme les listes ListOfAllElements$() et ListOfUsedElements$() comportent des  ; lignes indépendantes pour chaque type d'élément, nous sommes cohérents avec ces  ; conventions.  ; Les éléments du type 'Enumeration' présentent un cas particulier puisqu'ils ne  ; portent pas forcément un nom. C'est pourquoi, dans la procédure 'CompleteListOfAllElements()',  ; nous avons attribué un nom unique (en fonction de leur position dans le code) qui  ; permettra de les repérer dans les listes.EndMacro;Procedure GetTypeOfExpression(Expression$, *FoundedDetails.LastSearchDetails = 0, ExactValueSearch = #NoSearchOrManualSearch)  ;  ; Recherche 'Expression$' dans les diverses listes d'éléments ainsi  ; que dans les fonctions natives et les mots-clés de PureBasic, et  ; retourne le type d'expression trouvée.  ; Le type en question sera l'une des valeurs de l'énumération 'PBBTypes'  ; définie dans PBBrowersDeclaration.pb  ;  Protected  EFName$  Protected pf, found, ExistingElement, ELine$, FIL, mExpression$  Protected  mExistingElement, ne  Protected ctype = -1 ; Valeur de retour  ;  found = 0  ;  mExpression$ = Expression$  ;  If Expression$    Expression$ = PurifyElementName(Expression$)    If Expression$      ;      ; On explore toutes les listes d'éléments, jusqu'à trouver l'expression dans l'une d'elles.      ;      ctype = 0      ;      While ctype < #EndEnumPBBElementTypes And found = 0                If ExactValueSearch = #NoSearchOrManualSearch          ; Recherche ce qui commence par...          CheckIfElementExistsInList(ListOfAllElements$(ctype), Expression$, #FindBeginningBy)        Else          ; Recherche exacte :          CheckIfElementExistsInList(ListOfAllElements$(ctype), Expression$, ctype)        EndIf        If ExistingElement          pf = FindString(ListOfAllElements$(ctype), Chr(13), ExistingElement)          ELine$ = FastMid(ListOfAllElements$(ctype), ExistingElement, pf - ExistingElement)          ; On a fait la recherche sur le premier champs qui est en LCase,          ; mais on retourne la valeur en CaseSensitive.          Expression$ = StringField(ELine$, #EL_ElementName, Chr(9))          found = 1          Break        EndIf        ctype + 1      Wend      ;      If found = 0        If FastLeft(Expression$, 1) = "#"          ctype = #PBBConstante        Else          ctype = -1          ; On cherche l'expression dans la liste des fonctions natives,          ; et on corrige sa casse, si on la trouve.          FIL = FindString(PBFunctionListLCase$, "/" + Expression$ + Chr(13))          If FIL            Expression$ = FastMid(PBFunctionList$, FIL + 1, Len(Expression$))            ctype = #PBBNativeFunction            found = 1          Else            ; On cherche l'expression dans les mots-clés du Basic.            For ne = 1 To ArraySize(PBBasicKeyword$())              If PBBasicKeywordLCase$(ne) = Expression$                ; On corrige la casse.                Expression$ = PBBasicKeyword$(ne)                ctype = #PBBBasicKeyword                found = 1                Break              EndIf            Next          EndIf        EndIf      EndIf    EndIf  EndIf  ;  If *FoundedDetails    If found      *FoundedDetails\ElementType = ctype      *FoundedDetails\ElementName$ = Expression$      ;      If ctype = #PBBVariable And ExistingElement        *FoundedDetails\TypeName$ = StringField(ELine$, #EL_VariableSpecies, Chr(9))      ElseIf ctype <> -1        *FoundedDetails\TypeName$ = GetTextFromCatalog(PBBTypeNames$(ctype))      EndIf    Else      *FoundedDetails\ElementType = -1      *FoundedDetails\ElementName$ = mExpression$      *FoundedDetails\TypeName$ = ""    EndIf  EndIf  ProcedureReturn ctypeEndProcedure;Procedure.s ParseArguments(ArgList$)  ;  ; Dans une liste d'arguments telle que arg1, arg2, arg"; etc.  ; cette procédure va remplacer les virgules par le caractère tabulation (Chr(9)).  ;  ; L'opération est conçue de sorte que si les arguments comportent eux-mêmes  ; des arguments (par exemple : arg1(a,b,c), arg2(d,e,f), arg3(g,h,i), etc.  ; on se retrouve avec arg1(a,b,c)Chr(9)arg2(d,e,f)Chr(9)arg3(g,h,i)Chr(9)etc.  ;  Protected InQuote = 0, NbPar = 0, Pos, CChar  ;  For Pos = 1 To Len(ArgList$)    CChar = PeekC(@ArgList$ + (Pos - 1) * SizeOf(CHARACTER))    If CChar = 34 ; Quote      If InQuote = 1 : InQuote = 0 : Else : InQuote = 1 : EndIf    EndIf    If InQuote = 0      If CChar = Asc("(")        NbPar + 1      ElseIf CChar = Asc(")")        NbPar - 1      EndIf      If CChar = Asc(",") And NbPar = 0        PokeC(@ArgList$ + (Pos - 1) * SizeOf(CHARACTER), 9)      EndIf    EndIf  Next  ProcedureReturn ArgList$EndProcedure;Procedure DeleteCommentsAndSpacesFromPBCode(*SearchString.string, CleanSpaces = #True, EraseAllComments = #False)  ;  ; Supprime les espaces superflus (si CleanSpaces vaut #True)  ; et les commentaires du code.  ; Si 'EraseAllComments' vaut #False, seules les lignes ne comportant que du commentaire seront supprimées.  ; Sinon, tous les commentaires seront supprimés.  ;  Protected mlen, PosInCode, pf, DoIt, posDepR, TestS$, nbg  ;  If CleanSpaces    ; La deuxième boucle pourrait faire le travail de la première,    ; mais on gagne du temps en supprimant les espaces 4 par 4 pour commencer.    Repeat      mlen = Len(*SearchString\s)      *SearchString\s = ReplaceString(*SearchString\s, "    ", " ")    Until mlen = Len(*SearchString\s)    ; On supprime les doubles espaces :    Repeat      mlen = Len(*SearchString\s)      *SearchString\s = ReplaceString(*SearchString\s, "  ", " ")    Until mlen = Len(*SearchString\s)    ; On supprime les espaces en début de ligne :    *SearchString\s = ReplaceString(*SearchString\s, Chr(13) + " ", Chr(13))    ; On supprime les doubles sauts de ligne :    Repeat      mlen = Len(*SearchString\s)      *SearchString\s = ReplaceString(*SearchString\s, Chr(13) + Chr(13), Chr(13))    Until mlen = Len(*SearchString\s)  EndIf  ;  ; On retire les commentaires.  PosInCode = 0  Repeat    PosInCode = FindString(*SearchString\s, ";", PosInCode + 1)    If PosInCode = 1  Or (PosInCode > 1 And (EraseAllComments Or FastMid(*SearchString\s, PosInCode - 1, 1) = Chr(13)))      DoIt = 1      posdepR = PosInCode      FastFindPrecReturn(*SearchString\s, posdepR)      If PosInCode - posdepR > 0        TestS$ = Trim(FastMid(*SearchString\s, posdepR, PosInCode - posdepR))        If TestS$          ;          ; On vérifie que le point-virgule trouvé n'est pas entre guillemets.          ;          nbg = CountString(TestS$, Chr(34))          If nbg & 1 ; Il y a un nombre impair de guillemets.            DoIt = 0            PosInCode + 2          EndIf        EndIf      Else        ; On enlève le retour chariot qui précède, s'il y en a un.        If PosInCode > 1 : PosInCode - 1 : EndIf      EndIf      If DoIt        pf = FindString(*SearchString\s, Chr(13), PosInCode + 1)        If pf          *SearchString\s = FastLeft(*SearchString\s, PosInCode - 1) + FastMid(*SearchString\s, pf)        EndIf      EndIf    ElseIf PosInCode      PosInCode = FindString(*SearchString\s, Chr(13), PosInCode + 1)    EndIf  Until PosInCode = 0  Repeat    mlen = Len(*SearchString\s)    *SearchString\s = ReplaceString(*SearchString\s, Chr(13) + Chr(13), Chr(13))  Until mlen = Len(*SearchString\s)  *SearchString\s = Trim(*SearchString\s)  If Left(*SearchString\s, 1) = Chr(13)    *SearchString\s = FastMid(*SearchString\s, 2)  EndIfEndProcedure;Procedure.s IncludeMacrosIntoProcedure(ElementName$, *ProcCode.String)  ;  ; Cette procédure va extraire le code de la procédure 'ElementName$'  ; et va produire un nouveau code incluant dans celui de la procédure  ; les codes des macros qui sont citées, exactement comme le fait le  ; compilateur de PureBasic, au moment de la compilation.  ;  Shared ListOfMacro$  ;  Protected *SearchString.String, ProcCodeLCase.String, mLenProcCode  Protected *MacroCode.String, MacroCode$  Protected LineP$, mPosInProcList,  PosInProcList  Protected LineM$, mPosInMacroList, PosInMacroList  Protected ExistingElement  Protected FileName$, ElementStartingPos, ElementEndingPos, ElementNameLCase$  Protected PosInCode, PARIL  Protected mExistingElement, EOFLP, StartCallingParam, CallingParamList$, EndCallingParam  Protected EOFLM, MacroParamList$, EOFLM2, MacroCodeLCase$, MacroParam$, MacroParamValue$  Protected CallingParam$, PosParam, EFName$  ;  ListOfMacro$ = Chr(9)  ;  If ElementName$ And *ProcCode    ;    ; On épure le nom de la procédure pour faciliter les recherches :    ElementName$ = PurifyElementName(ElementName$)    ; On recherche la procédure dans la liste des procédures :    CheckIfElementExistsInList(ListOfAllElements$(#PBBProcedure), ElementName$, #PBBProcedure)    If ExistingElement      mPosInProcList = ExistingElement      PosInProcList = FindString(ListOfAllElements$(#PBBProcedure), Chr(13), mPosInProcList)      If PosInProcList        ; On extrait la ligne de la liste des procédures :        LineP$ = FastMid(ListOfAllElements$(#PBBProcedure), mPosInProcList, PosInProcList - mPosInProcList)        FileName$           = StringField(LineP$, #EL_FileName, Chr(9))        ElementStartingPos  = Val(StringField(LineP$, #EL_StartingPos, Chr(9)))        ElementEndingPos    = Val(StringField(LineP$, #EL_EndingPos, Chr(9)))        ; On récupère le code de la procédure :        *SearchString = GetPointedElementContentFromFile(FileName$, ElementStartingPos, ElementEndingPos)        ;        ; On fait une copie du code, parce qu'on va peut-être le modifier :        *ProcCode\s = *SearchString\s        ProcCodeLCase\s = LCase(*ProcCode\s)        ;        Repeat          ;          ; On mémorise la longueur du code, et on va répéter tout ce qui suit          ; tant que l'on constatera une modification de *ProcCode\s.          mLenProcCode = Len(*ProcCode\s)          ; Il est possible, en effet, qu'une macro appelle une macro et il faut          ; donc tourner en boucle jusqu'à avoir épuisé les imbrications.          ;          ; Nous allons parcourir la liste des macros pour voir si on trouve le nom d'une macro          ; dans le code de la procédure.          PosInMacroList = 0          Repeat            mPosInMacroList = PosInMacroList + 1            PosInMacroList = FindString(ListOfAllElements$(#PBBMacro), Chr(13), mPosInMacroList)            If PosInMacroList              ; On extrait une ligne de la liste des macros :              LineM$ = FastMid(ListOfAllElements$(#PBBMacro), mPosInMacroList, PosInMacroList - mPosInMacroList)              ElementNameLCase$  = StringField(LineM$, #EL_ElementNameLCase, Chr(9))              ElementName$       = StringField(LineM$, #EL_ElementName, Chr(9))              FileName$          = StringField(LineM$, #EL_FileName, Chr(9))              ElementStartingPos = Val(StringField(LineM$, #EL_StartingPos, Chr(9)))              ElementEndingPos   = Val(StringField(LineM$, #EL_EndingPos, Chr(9)))              ;              PosInCode = 0              Repeat                PosInCode = FindInPBPointedCode(ProcCodeLCase, ElementNameLCase$, PosInCode + 1, #CheckAll | #CheckOneKeyWordOnly)                If PosInCode                  ; On ajoute le nom de la macro à la liste des macros trouvées                  ; dans le code :                  If FindString(ListOfMacro$, Chr(9) + ElementName$ + Chr(9)) = 0                    ListOfMacro$ + ElementName$ + Chr(9)                  EndIf                  ; On a trouvé le nom de la macro dans le code de la procédure.                  ; On cherche la fin de ligne :                  EOFLP = FindInPBPointedCode(ProcCodeLCase, ":," + Chr(13), PosInCode, #CheckOnlyComAndQuote)                  If EOFLP = 0 : EOFLP = Len(ProcCodeLCase\s) + 1 : EndIf                  ;                  ; Nous allons voir si l'appel de la macro se fait avec des paramètres :                  StartCallingParam = PosInCode + Len(ElementNameLCase$)                  ; On saute les espaces qui suivent éventuellement le nom de la macro :                  While PeekC(@ProcCodeLCase\s + (StartCallingParam - 1) * SizeOf(CHARACTER)) = 32 : StartCallingParam + 1 : Wend                  CallingParamList$ = ""                  If PeekC(@ProcCodeLCase\s + (StartCallingParam - 1) * SizeOf(CHARACTER)) = Asc("(")                    ; L'appel de la macro a des paramètres.                    StartCallingParam + 1                    EndCallingParam = EOFLP                    ;                    ; Depuis la fin de ligne, on remonte jusqu'à la parenthèse fermante :                    While EndCallingParam > StartCallingParam And PeekC(@ProcCodeLCase\s + (EndCallingParam - 1) * SizeOf(CHARACTER)) <> Asc(")") : EndCallingParam - 1 : Wend                    ; On extrait la liste des paramètres :                    CallingParamList$ = FastMid(*ProcCode\s, StartCallingParam, EndCallingParam - StartCallingParam)                    CallingParamList$ = ParseArguments(CallingParamList$)                    ;                  EndIf                  ; On récupère le code de la macro :                  *MacroCode = GetPointedElementContentFromFile(FileName$, ElementStartingPos, ElementEndingPos)                  ; On efface les commentaires et les espaces superflus :                  DeleteCommentsAndSpacesFromPBCode(*MacroCode, #True, #True)                  ;                  ; On cherche la fin de la première ligne :                  EOFLM = FindInPBPointedCode(*MacroCode, ":," + Chr(13), 1, #CheckOnlyComAndQuote)                  ;                  ; On cherche le début de la liste des paramètres :                  StartCallingParam = FindInPBPointedCode(*MacroCode, "(", 1, #CheckOnlyComAndQuote)                  If StartCallingParam > EOFLM : StartCallingParam = 0 : EndIf                  ;                  If CallingParamList$ And StartCallingParam = 0                    AlertInPBBWindow("In procedure IncludeMacrosIntoProcedure(), calling of " + ElementNameLCase$ + " is done with parametres, but this macro has no parametres!")                    ProcedureReturn                   EndIf                  ;                  MacroParamList$ = ""                  If StartCallingParam                    StartCallingParam + 1                    EndCallingParam = EOFLM                    ;                    ; Depuis la fin de ligne, on remonte jusqu'à la parenthèse fermante :                    While EndCallingParam > StartCallingParam And PeekC(@*MacroCode\s + (EndCallingParam - 1) * SizeOf(CHARACTER)) <> Asc(")") : EndCallingParam - 1 : Wend                    ; On extrait la liste des paramètres                    MacroParamList$ = FastMid(*MacroCode\s, StartCallingParam, EndCallingParam - StartCallingParam)                    MacroParamList$ = ParseArguments(MacroParamList$)                  EndIf                  ;                  EOFLM2 = FindInPBPointedCode(*MacroCode, "EndMacro", EOFLM) - 1                  If EOFLM2 = 0                    AlertInPBBWindow("In procedure IncludeMacrosIntoProcedure(), 'EndMacro' is missing in the code of " + ElementNameLCase$ + "!")                    ProcedureReturn                    EndIf                  While FastMid(*MacroCode\s, EOFLM2, 1) = Chr(13) Or FastMid(*MacroCode\s, EOFLM2, 1) = " "                    EOFLM2 - 1                  Wend                  ;                  If EOFLM2 < EOFLM + 2                     AlertInPBBWindow("In procedure IncludeMacrosIntoProcedure(), Macro code is missing: " + ElementNameLCase$ + ".")                    ProcedureReturn                    EndIf                  ; On supprime la première et la dernière ligne du code de la macro tout en faisant une copie :                  EOFLM + 1                  MacroCode$ = Trim(FastMid(*MacroCode\s, EOFLM, EOFLM2 - EOFLM + 1))                  ;                  ; Dans le code de la macro, on remplace les arguments de la macro                  ; par les arguments fournis lors de l'appel de la macro :                  If MacroParamList$                    MacroCodeLCase$ = LCase(MacroCode$)                    PARIL = 0                    Repeat                      PARIL + 1                      MacroParam$ = Trim(StringField(MacroParamList$, PARIL, Chr(9)))                      If MacroParam$                        ; Dans le code de la macro, on récupère la valeur par défaut                        ; de l'un des paramètres :                        MacroParamValue$ = Trim(StringField(MacroParam$, 2, "="))                        MacroParam$ = Trim(StringField(MacroParam$, 1, "="))                        CallingParam$ = Trim(StringField(CallingParamList$, PARIL, Chr(9)))                        ; Si une valeur de paramètre n'est pas fournie lors de l'appel,                        ; on utilise la valeur par défaut :                        If CallingParam$ = "" : CallingParam$ = MacroParamValue$ : EndIf                        PosParam = 0                        Repeat                          PosParam = FindInPBStringCode(MacroCodeLCase$, LCase(MacroParam$), PosParam + 1, #CheckAll | #CheckOneKeyWordOnly)                          If PosParam                            MacroCode$ = FastLeft(MacroCode$, PosParam - 1) + CallingParam$ + FastMid(MacroCode$, PosParam + Len(MacroParam$))                            MacroCodeLCase$ = LCase(MacroCode$)                            PosParam + Len(CallingParam$) - Len(MacroParam$)                          EndIf                        Until PosParam = 0                      EndIf                    Until MacroParam$ = ""                  EndIf                  ; Dans le code de la procédure, on remplace l'appel de la macro                  ; par le code de la macro :                  *ProcCode\s = FastLeft(*ProcCode\s, PosInCode - 1) + MacroCode$ + FastMid(*ProcCode\s, EOFLP)                  ProcCodeLCase\s = LCase(*ProcCode\s)                EndIf              Until PosInCode = 0              ;            EndIf          Until PosInMacroList = 0        Until mLenProcCode = Len(*ProcCode\s)      EndIf    Else      AlertInPBBWindow("IncludeMacrosIntoProcedure () --> The Procedure '" + ElementName$ + " cannot be found in Element List!")      *ProcCode\s = "Error"    EndIf    ; On enlève la toute première tabulation figurant    ; dans ListOfMacro$, qui ne figurait là que pour    ; faciliter les recherches :    ListOfMacro$ = Mid(ListOfMacro$, 2)    ;  EndIfEndProcedure;Structure VariableListings  ProcedureName.s  CompleteList.s  Unused.s  Unprotected.sEndStructure;#OperatorAsWord$ = ",If,ElseIf,While,Until,Select,Case,Default,To,ProcedureReturn,And,Or,Xor,Not,Protected,Global,Static,Shared";Procedure.s CheckVariable(VWord$, LineOfCode$, *Result.VariableListings, VarPos, ListOp$, Label$ = "")  ;  ; Cette procédure va tenter de déterminer si la valeur contenue  ; dans VWord$ est un nom de variable.  ;  ; LineOfCode$ est la ligne de code contenant VWord$,  ; *Result\CompleteList est la liste des variables déjà identifiées,  ; VarPos est la position à laquelle VWord$ figure dans LineOfCode$.  ;  Protected  mVWord$, Pos, PreceedingWord$, dTest  Protected FoundedDetails.LastSearchDetails  Protected pTest, VWordSimple$, VListLCase$, PosSimple, PosWithPoint, LenLine  Protected FollowingPar, TypeOfElement, VDeclare$, PosEOL, PosLastTab  ;  If VarPos And VWord$ And FindString("#\$%?" + Chr(34), Left(VWord$, 1)) = 0 And IsStringNum(VWord$) = #False And (VarPos = 1 Or FindString("#\$%?" + Chr(34), FastMid(LineOfCode$, VarPos - 1, 1)) = 0)    ;    ; On vérifie que le nom trouvé n'est pas entre guillemets ou en commentaire :    If VarPos = FindInPBStringCode(LineOfCode$, VWord$)      ; Si VWord$ est une variable structurée, on supprime le nom de champs qui suit      ; le nom de variable :      VWord$ = Trim(StringField(VWord$, 1, "\"))      ; On supprime aussi tous les caractères de séparation qui peuvent      ; être accolés au nom de variable :      mVWord$ = VWord$      For Pos = 1 To Len(ListOp$)        VWord$ = ReplaceString(VWord$, FastMid(ListOp$, Pos, 1), "")      Next      VWord$ = ReplaceString(VWord$, "@", "")      If VWord$        If FastLeft(mVWord$, 1) = "*"          ; Voir ci-dessous la note sur la gestion particulière du caractère "*".          ; On a peut-être supprimé ce caractère en retirant tous les caractères          ; séparateurs dans la boucle 'For Pos = 1 To Len(ListOp$)' qui figure          ; juste au-dessus. Si c'est le cas, on prépare le test qui va suivre :          VarPos + 1        EndIf        If VarPos > 1 And FastMid(LineOfCode$, VarPos - 1, 1) = "*"          ; Le caractère "*" pose un problème particulier à cause de sa double fonction :          ; il peut représenter l'opérateur de multiplication ou bien indiquer qu'une          ; variable est un pointeur.          ; On va essayer d'identifier sa fonction en regardant ce qu'il y a avant.          ; On saute "*" et on se positionne sur le caractère précédent :          pTest = VarPos - 2          ; On saute les espaces qui précèdent peut-être :          While pTest And PeekC(@LineOfCode$ + (pTest - 1) * SizeOf(CHARACTER)) = 32            pTest - 1          Wend          ;          ; On va regarder quel est le mot qui précède:          PreceedingWord$ = ""          If pTest            dTest = pTest            While dTest And PeekC(@LineOfCode$ + (dTest - 1) * SizeOf(CHARACTER)) <> 32              dTest - 1            Wend            dTest + 1            PreceedingWord$ = "," + LCase(Fastmid(LineOfCode$, dTest, pTest - dTest + 1)) + ","          EndIf          ;          If pTest = 0 Or FindString("(,@+-/*=&:~<>|[" + Chr(13), Chr(PeekC(@LineOfCode$ + (pTest - 1) * SizeOf(CHARACTER)))) Or (PreceedingWord$ And FindString(LCase(#OperatorAsWord$), PreceedingWord$))            ; Il y a un autre opérateur avant, ou bien un séparateur qui indique que le signe "*"            ; est à considérer comme un indicateur de pointeur. On intègre donc "*" au nom de la variable.            VWord$ = "*" + VWord$          EndIf        EndIf        ;        ; On retire le type de la variable, si elle en comporte un :        VWordSimple$ = Trim(LCase(StringField(VWord$, 1, ".")))        ;        ; On retire la mention qui précède ('Array', par exemple) :        If FindString(VWord$, " ")          Label$ + " " + StringField(VWord$, 1, " ")          VWord$ = StringField(VWord$, 2, " ")        EndIf        ;        ; On regarde si la variable figure déjà dans la liste :        VListLCase$ = LCase(*Result\CompleteList)        PosSimple = FindString(VListLCase$, Chr(9) + VWordSimple$ + Chr(9))        PosWithPoint = FindString(VListLCase$, Chr(9) + VWordSimple$ + ".")        If PosSimple = 0 And PosWithPoint = 0          ; La variable ne figure pas dans la liste.          ; On regarde si une parenthèse ouvrante figure à la suite.          pTest = VarPos + Len(vWord$)          ; On saute les espaces qui peuvent suivre le mot :          LenLine = Len(LineOfCode$)          While pTest < LenLine And PeekC(@LineOfCode$ + (pTest - 1) * SizeOf(CHARACTER)) = 32            pTest + 1          Wend          ;          If PeekC(@LineOfCode$ + (pTest - 1) * SizeOf(CHARACTER)) = Asc("(")            FollowingPar = 1          Else            FollowingPar = 0          EndIf          ;          ; On regarde si le mot n'est pas le nom d'une fonction native ou d'un mot          ; appartenant au vocabulaire du Basic. 'GetTypeOfExpression()' va également          ; vérifier s'il s'agit d'une variable globale :          TypeOfElement = GetTypeOfExpression(VWord$, FoundedDetails, #DoProgrammedSearch)          If TypeOfElement = -1 And FollowingPar = 0            ; Le nom n'a pas été trouvé dans les éléments.            ; On ne l'ajoute à la liste que dans le cas où il n'est            ; pas suivi par une parenthèse ouvrante.            ; -> Les tableaux et listes ne seront ajoutés à la liste que            ;    1- s'ils figurent dans la liste des variables globales            ;    2- au moment de leur déclaration par 'Dim' ou 'NewList'.            ;       (auquel cas, on ne l'ajoute pas ici, mais dans            ;        le procédure 'ListVariables()').            ; Dans tous les autres cas, on considère que les mots suivis            ; d'une parenthèse ouvrante ne sont pas des variables, mais            ; des procédures ou des fonctions.            If Label$              *Result\CompleteList + Label$ + Chr(9) + VWord$ + Chr(9) + "Unused" + Chr(13)            Else              *Result\CompleteList + Chr(9) + VWord$ + Chr(9) + "Used" + Chr(13)            EndIf            ;          ElseIf TypeOfElement = #PBBVariable And (FollowingPar = 0 Or FindString(FoundedDetails\TypeName$, "Array") Or FindString(FoundedDetails\TypeName$, "List") Or FindString(FoundedDetails\TypeName$, "Map"))            ; La variable est une variable Shared ou Global.            ; On ne l'ajoute à la liste que si elle n'est pas suivie d'une parenthèse ouvrante            ; ou bien si on a trouvé une variable 'Shared' ou 'Global' de même nom qui            ; s'avère être un tableau, une liste ou une map.            VDeclare$ = ReplaceString(FoundedDetails\TypeName$, " Var", "")            *Result\CompleteList + VDeclare$ + Chr(9) + VWord$ + Chr(9) + "Used" + Chr(13)          EndIf        ElseIf PosSimple And FindString(VWord$, ".")          ; La variable figure dans la liste, mais VWord$ a un type,          ; alors que la version enregistrée dans *Result\CompleteList n'en a pas.          ; On va mettre *Result\CompleteList à jour :          PosEOL = FindString(*Result\CompleteList, Chr(13), PosSimple + 1)          *Result\CompleteList = FastLeft(*Result\CompleteList, PosSimple) + VWord$ + Chr(9) + "Used" + FastMid(*Result\CompleteList, PosEOL)        ElseIf PosSimple Or PosWithPoint          ; La variable figure déjà dans la liste. On va signaler le fait          ; qu'elle est utilisée :          If PosWithPoint = 0 : PosWithPoint = PosSimple : EndIf          PosLastTab = FindString(*Result\CompleteList, Chr(9), PosWithPoint + 1)          PosEOL = FindString(*Result\CompleteList, Chr(13), PosLastTab)          *Result\CompleteList = FastLeft(*Result\CompleteList, PosLastTab) + "Used" + FastMid(*Result\CompleteList, PosEOL)        EndIf      EndIf    EndIf  EndIfEndProcedure;Procedure FindVarInCodeLine(LineOfCode$, ListOp$, *Result.VariableListings)  ;  ; On prépare des listes de séparateurs pour ce qui va suivre :  Protected ListPBSepLessPoint$ = ReplaceString(ListPBSep$, ".", "")            ListPBSepLessPoint$ = ReplaceString(ListPBSepLessPoint$, "\", "")  Protected ListPBSepLessStar$ = ReplaceString(ListPBSep$, "*", "")  Protected mPosInLine, PosInLine, BeforeSign, EBeforeSign, LenLine  Protected WordBefore$, AfterSign, EAfterSign, WordAfter$  ;  LenLine = Len(LineOfCode$)  mPosInLine = 0  Repeat    ; La méthode utilisée pour repérer les variables n'est pas subtile :    ; on recherche un opérateur et on regarde les deux mots qui figurent    ; de part et d'autre de cet opérateur. On regarde aussi tout ce qui figure    ; de part et d'autre des virgules ainsi que ce qui se trouve entre parenthèses.    ; On procèdera ensuite à un contrôle plus fin en faisant appel à la procédure    ; 'CheckVariable()'.    PosInLine = FirstOccurrenceOfChar(LineOfCode$, ListOp$, mPosInLine + 1)    If PosInLine      mPosInLine = PosInLine      If PosInLine > 1        ; On extrait le mot qui figure avant l'opérateur :        BeforeSign = PosInLine        ; On saute les espaces ou les autres caractères de séparation :        While BeforeSign > 1 And FindString(ListPBSep$, Chr(PeekC(@LineOfCode$ + (BeforeSign - 2) * SizeOf(CHARACTER))))          BeforeSign - 1        Wend        If FindString(FastMid(LineOfCode$, BeforeSign, PosInLine - BeforeSign), ")") = 0          ; Si l'opérateur est bordé d'une parenthèse fermante sur sa gauche,          ; on ne regarde pas au-delà. Ce serait inutile étant donné que notre          ; mode de recherche nous a déjà amené à regarder ce qu'il y avait          ; entre parenthèses.          EBeforeSign = BeforeSign          ; On remonte encore jusqu'à trouver un autre caractère de séparation :          While BeforeSign > 1 And FindString(ListPBSepLessPoint$, Chr(PeekC(@LineOfCode$ + (BeforeSign - 2) * SizeOf(CHARACTER)))) = 0            BeforeSign - 1          Wend          ; On extrait le mot qui précède :          WordBefore$ = FastMid(LineOfCode$, BeforeSign, EBeforeSign - BeforeSign)          ;          ; Et on vérifie s'il peut s'agir d'une variable :          CheckVariable(WordBefore$, LineOfCode$, *Result, BeforeSign, ListOp$)        EndIf      EndIf      ;      If FastMid(LineOfCode$, PosInLine, 1) <> ")" ; On ne regarde pas après la parenthèse fermante.        ; On saute les caractères de séparation (espaces ou autres) qui peuvent        ; figurer après l'opérateur :        AfterSign = PosInLine + 1        While AfterSign <= LenLine And FindString(ListPBSepLessStar$, Chr(PeekC(@LineOfCode$ + (AfterSign - 1) * SizeOf(CHARACTER))))          AfterSign + 1        Wend        ;        ; On avance encore jusqu'à trouver un caractère séparateur :        EAfterSign = AfterSign + 1        While EAfterSign <= LenLine And FindString(ListPBSepLessPoint$, Chr(PeekC(@LineOfCode$ + (EAfterSign - 1) * SizeOf(CHARACTER)))) = 0          EAfterSign + 1        Wend        ; On extrait le mot qui suit l'opérateur :        WordAfter$ = FastMid(LineOfCode$, AfterSign, EAfterSign - AfterSign)        ;        ; On teste le mot pour savoir s'il s'agit d'une variable :        CheckVariable(WordAfter$, LineOfCode$, *Result, AfterSign, ListOp$)      EndIf      ;    EndIf  Until PosInLine = 0EndProcedure;  Procedure ListVariables(ElementName$, *Result.VariableListings)  ;  ; Cette procédure dresse la liste des variables figurant dans la procédure  ; portant le nom de 'ElementName$'.  ;  ; Pour retourner des résultats fiables, elle nécessite que la liste des  ; variables 'Global' et 'Shared' ait déjà été établie.  ;  Protected AfterEqual$, EFName$  Protected ListOp$ = "=+-/*&|!<>%,()"  Protected PSO, ePSO, PosInCode, mPosInCode, LineOfCode$, PosCom  Protected KeyWordsListTest$, KeyWordsList$, VDeclare$, PosKL, KeyWord$  Protected CharAfter$, pS, VType$, NoVar, Var$, SVar$  Protected ExistingElement, mExistingElement, pf, ELine$  Protected PosInList, VLine$, VUsed$  ;  If ListCompletionAll(#PBBVariable) = #ListCompletion_Done        Protected ProcCode.String    ;    ; On commence par intégrer dans la procédure le code des macros auxquelles    ; la procédure fait peut-être appel. Ainsi, les variables figurant dans    ; les macros seront examinées au même titre que les autres :    IncludeMacrosIntoProcedure(ElementName$, ProcCode)    If ProcCode\s = "Error"      ProcedureReturn #False    EndIf    ;    ProcCode\s + Chr(13)    ;    *Result\ProcedureName = ElementName$    ;    ; Avant d'examiner le code pour en extraire les variables,    ; on va gérer le cas particulier de Sizeof() à qui on envoie    ; comme paramètre des noms de type ou de structure. Si Sizeof()    ; figure dans le code, son paramètre risque d'être considéré    ; comme un nom de variable. On va donc effacer cette mention :    ;    Repeat      PSO = FindInPBPointedCode(ProcCode, "SizeOf", 1)      If PSO        ePSO = PSO + 6        While PeekC(@ProcCode\s + (ePSO - 1) * SizeOf(CHARACTER)) = 32 : ePSO + 1 : Wend        If PeekC(@ProcCode\s + (ePSO - 1) * SizeOf(CHARACTER)) = Asc("(")          ePSO = FindString(ProcCode\s, ")", ePSO)          If ePSO            ePSO + 1            ProcCode\s = FastLeft(ProcCode\s, PSO - 1) + FastMid(ProcCode\s, ePSO)          EndIf        EndIf      EndIf    Until PSO = 0        *Result\CompleteList = ""    PosInCode = 0    Repeat      mPosInCode = PosInCode + 1      ; On extrait une ligne de code entre les caractères ":" et/ou Chr(13) :      ; 'FindInPBPointedCode()' nous garantit que ces caractères ne sont pas      ; trouvés entre guillemets ou en commentaire.      PosInCode = FindInPBPointedCode(ProcCode, ":," + Chr(13), mPosInCode, #CheckOnlyComAndQuote)      If PosInCode And (PosInCode - mPosInCode) > 1        LineOfCode$ = Trim(FastMid(ProcCode\s, mPosInCode, PosInCode - mPosInCode))        ;        ; On efface le commentaire qui figure éventuellement en fin de ligne :        PosCom = FindInPBStringCode(LineOfCode$, ";", 1, #CheckOnlyComAndQuote)        If PosCom          LineOfCode$ = Trim(FastLeft(LineOfCode$, PosCom - 1))        EndIf        ;        KeyWordsListTest$ = ",If,ElseIf,While,Until,Select,Case,ProcedureReturn,"        KeyWordsList$ = "Procedure,Protected,Static,Shared,Global,NewList,NewMap,Dim" + KeyWordsListTest$        VDeclare$ = ""        PosKL = 0        Repeat          PosKL + 1          KeyWord$ = StringField(KeyWordsList$, PosKL, ",")          If KeyWord$            If FastLeft(LineOfCode$, Len(KeyWord$)) = KeyWord$              CharAfter$ =  FastMid(LineOfCode$, Len(KeyWord$) + 1, 1)              If CharAfter$ = "." Or CharAfter$ = " "                LineOfCode$ = Trim(FastMid(LineOfCode$, Len(KeyWord$) + 1))                If FindString(KeyWordsListTest$, "," + KeyWord$ + ",")                  ; Dans les lignes ayant la forme de "If MyVar",                  ; la méthode de répérage des variables que nous                  ; utilisons ci-après sera inefficace, car de telles                  ; lignes ne comportent aucun opérateur figurant dans ListOp$.                  ; On force donc une vérification pour ce cas particulier.                  ;                  LineOfCode$ = "+" + LineOfCode$                  FindVarInCodeLine(LineOfCode$, ListOp$, *Result.VariableListings)                ElseIf KeyWord$ = "Procedure"                  VDeclare$ = "Parametre"                ElseIf KeyWord$ = "NewList"                  VDeclare$ = "List"                ElseIf KeyWord$ = "NewMap"                  VDeclare$ = "Map"                ElseIf KeyWord$ = "Dim"                  VDeclare$ = "Array"                Else                  VDeclare$ = KeyWord$                EndIf                Break              EndIf            EndIf          EndIf        Until KeyWord$ = ""        ;        If VDeclare$          If VDeclare$ = "Parametre"            ; On ne garde que ce qu'il y a à l'intérieur des parenthèses de la première ligne.            LineOfCode$ = FastMid(LineOfCode$, FindString(LineOfCode$, "(") + 1)            LineOfCode$ = Left(LineOfCode$, Len(LineOfCode$) - 1)          Else            ; On gère les déclarations de listes et de tableaux            ; en Static ou en Protected :            If FastLeft(LineOfCode$, 7) =  "NewList"              VDeclare$ + " List"              LineOfCode$ = Trim(FastMid(LineOfCode$, 8))            ElseIf FastLeft(LineOfCode$, 7) = "NewMap"              VDeclare$ + " Map"              LineOfCode$ = Trim(FastMid(LineOfCode$, 7))            ElseIf FastLeft(LineOfCode$, 3) = "Dim"              VDeclare$ + " Array"              LineOfCode$ = Trim(FastMid(LineOfCode$, 4))            EndIf          EndIf          ;          If Left(LineOfCode$, 1) = "."            ; Nous avons un liste de variables précédée d'un type ('.s', par exemple).            ; On récupère le type :            pS = FindString(LineOfCode$, " ")            If pS              VType$ = FastLeft(LineOfCode$, pS - 1)              ; Et on supprime la déclaration de type de LineOfCode$              LineOfCode$ = Trim(FastMid(LineOfCode$, pS + 1))            EndIf          Else            VType$ = ""          EndIf          ;          LineOfCode$ = ParseArguments(LineOfCode$)          NoVar = 0          Repeat            NoVar + 1            Var$ = StringField(LineOfCode$, NoVar, Chr(9))            If Var$              ;              AfterEqual$ = ""              If VDeclare$ <> "Parameter" And FindString(Var$, "=")                ; Si une variable est utilisée dans une déclaration de type 'Protected',                ; (c'est-à-dire, si elle figure après le signe "="), on va noter                ; son utilisation.                AfterEqual$ = FastMid(Var$, FindString(Var$, "="))              EndIf              ; Et, pour ce qui suit, on ne conserve que le nom de variable :              Var$ = Trim(StringField(Var$, 1, "="))              Var$ = Trim(StringField(Var$, 1, "("))                            ;              ; Si la variable figure dans la liste des éléments, on va récupérer              ; ses caractéristiques pour avoir quelque chose d'aussi complet que possible :              If FindString(VDeclare$, "Shared") Or FindString(VDeclare$, "Global")                SVar$ = PurifyElementName(Var$)                CheckIfElementExistsInList(ListOfAllElements$(#PBBVariable), SVar$, #PBBVariable)                If ExistingElement                  pf = FindString(ListOfAllElements$(#PBBVariable), Chr(13), ExistingElement)                  ELine$ = FastMid(ListOfAllElements$(#PBBVariable), ExistingElement, pf - ExistingElement)                  Var$ = StringField(ELine$, #EL_ElementName, Chr(9))                  VDeclare$ = ReplaceString(StringField(ELine$, #EL_VariableSpecies, Chr(9)), " Var", "")                EndIf              EndIf              If Var$                If Right(Var$, 1) = "$" : VType$ = "" : EndIf                CheckVariable(Var$ + VType$, Var$ + VType$, *Result, 1, ListOp$, VDeclare$)              EndIf              If AfterEqual$                FindVarInCodeLine(AfterEqual$, ListOp$, *Result.VariableListings)              EndIf            EndIf          Until Var$ = ""        Else          FindVarInCodeLine(LineOfCode$, ListOp$, *Result.VariableListings)        EndIf      EndIf    Until PosInCode = 0    ;    ; Toutes les variables qui n'ont pas été labellisées sont considérées comme 'unprotected' :    ;    *Result\CompleteList = Chr(13) + *Result\CompleteList    *Result\CompleteList = ReplaceString(*Result\CompleteList, Chr(13) + Chr(9), Chr(13) + "Unprotected" + Chr(9))    *Result\CompleteList = FastMid(*Result\CompleteList, 2)    ;    *Result\Unused = ""    *Result\Unprotected = ""    PosInList = 0    Repeat      PosInList + 1      VLine$ = StringField(*Result\CompleteList, PosInList, Chr(13))      If VLine$        VDeclare$ = StringField(VLine$, 1, Chr(9))        Var$ = StringField(VLine$, 2, Chr(9))        VUsed$ = StringField(VLine$, 3, Chr(9))        If VUsed$ = "Unused"          *Result\Unused + Var$ + ", "        EndIf        If VDeclare$ = "Unprotected"          *Result\Unprotected + Var$ + ", "        EndIf      EndIf    Until VLine$ = ""    If *Result\Unused      *Result\Unused = GetTextFromCatalog("UnusedVariables:") + " " + Fastleft(*Result\Unused, Len(*Result\Unused) - 2)    EndIf    If *Result\Unprotected      *Result\Unprotected = GetTextFromCatalog("UnprotectedVariables:") + " " + Fastleft(*Result\Unprotected, Len(*Result\Unprotected) - 2)    EndIf  Else    *Result\ProcedureName = ElementName$    *Result\CompleteList = ""    *Result\Unprotected = ""    *Result\Unused = ""    ProcedureReturn #False  EndIf  ;  ProcedureReturn #True  ;EndProcedure  ;Procedure.s GetImageNameFromSelectionPos(NoREGadget)  ;  ; Cette procédure examine le contenu RTF du caractère précédent le début de la sélection  ; pour voir si l'on y trouve le repère d'image qui est normalement situé juste avant une image-bouton.  ;  Protected PosInText, pf, ExpressionUnderCursor$  Protected ImageButtonName$ ; Valeur de retour.                             ;  ; On récupère la position du curseur dans le texte.  PosInText = TOM_GetStartPos(NoREGadget)  ;  If OSVersion() <= #PB_OS_Windows_Server_2008_R2    ; Le programme tourne sous Windows 7 ou sous une version antérieure.    ; Les boutons ne sont pas affichés sous la forme d'une image, mais    ; d'un ou plusieurs caractère(s).    If FindString(TOM_GetText(NoREGadget, "", max(0, PosInText - Len(#PBBLeftArrow$)), PosInText + Len(#PBBLeftArrow$)), #PBBLeftArrow$)      ProcedureReturn #PBBLeftArrowMarker$    ElseIf FindString(TOM_GetText(NoREGadget, "", max(0, PosInText - Len(#PBBRightArrow$)), PosInText + Len(#PBBRightArrow$)), #PBBRightArrow$)      ProcedureReturn #PBBRightArrowMarker$    EndIf  Else    ; On récupère le code RTF des 20 caractères précédents :    ExpressionUnderCursor$ = TOM_GetText(NoREGadget, "RTF", PosInText - 20, PosInText)    ;    PosInText = FindString(ExpressionUnderCursor$, #PBBRTFMarker$, 0)    If PosInText      ; On a trouvé un repère. Il s'agit bien d'un clic sur une image-bouton.      ; On extrait le nom du repère afin d'identifier le bouton.      ImageButtonName$ = ""      PosInText + Len(#PBBRTFMarker$)      pf = FirstOccurrenceOfChar(ExpressionUnderCursor$, " }\", PosInText)      If pf = 0 : pf = Len(ExpressionUnderCursor$) + 1 : EndIf      ImageButtonName$  = FastMid(ExpressionUnderCursor$, PosInText, pf - PosInText)      ProcedureReturn ImageButtonName$    EndIf  EndIfEndProcedure;Procedure ColorizeNativePBFunctions(NoREGadget, posdep = 0, pcolor = 0, *REContent.String = 0)  ;  ; On colorie les noms des fonctions natives de PureBasic  ;  Protected PosInCode, nl, pf, pfl, pfl2, RColor, REContent.String, PBKeyword$  Protected *TextFontObjet.ITextFont_Fixed  ;  If *REContent = 0    ; On crée un espace mémoire pour *REContent.    *REContent = @REContent.String    ;    *REContent\s = LCase(ReplaceString(TOM_GetText(NoREGadget, "", 0, -1), Chr(10), "") + Chr(13))    ; Voir les explications données dans la procédure 'ColorizeBasicKeyWords'.  EndIf  ;  If pcolor = 0    pcolor = GetValueFromBPPrefFile("PureKeywordColor")  EndIf  ;  nl = 0  pf = 0  Repeat    pfl = FindString(PBFunctionListLCase$, "/", pfl)    If pfl      nl + 1      pfl + 1      pfl2 = FindString(PBFunctionListLCase$, Chr(13), pfl)      PBKeyword$ = FastMid(PBFunctionListLCase$, pfl, pfl2 - pfl)      pfl = pfl2      PosInCode = posdep      Repeat        PosInCode = FindInPBPointedCode(*REContent, PBKeyword$, PosInCode + 1, #CheckAll | #CheckOneKeyWordOnly)        If PosInCode          pf = PosInCode + Len(PBKeyword$)          *TextFontObjet = TOM_GetTextFontObj(NoREGadget, PosInCode - 1, pf - 1)          *TextFontObjet\GetForeColor(@Rcolor)          If RColor <> pcolorNotUsed            *TextFontObjet\SetForeColor(pcolor)          EndIf          *TextFontObjet\Release()        EndIf      Until PosInCode = 0    EndIf  Until pfl = 0EndProcedure;Procedure ColorizeElementsNames(NoREGadget, posdep = 0, TitleColor = 0, MainPBBPanelState = 0, *REContent.String = 0, DontUnderline$ = "")  ;  ; On colorie et on souligne (dans certains cas) les noms des éléments (procédures, structures, macros, etc.)  ; Cette procédure est utilisée pour présenter le contenu de tous les REGAdgets,  ; à l'exception de la liste des fichiers.  ; 'NoREGadget' peut donc prendre de multiples valeurs.  ;  Protected  ElementParent$  Protected TypeOfElement, PosInCode, pd, pf, pEcolor, pList, mpList  Protected SStrLength, REContent.String  Protected *TextFontObjet.ITextFont_Fixed  Protected mListPBSep$, ElementNameLCase$, ELine$, pfd  Protected IsUnUsed ; Valeur de retour    ;  ; On ajoute à 'ListPBSep$' le Chr(160) qui est nécessaire pour le traitement  ; de ce qui est affiché dans "Trouvé dans..."  ; 'ListPBSep$' est une variable globale déclarée et définie  ; juste avant la procedure 'FindInPBCode()'.  ; Elle contient la liste des caractère utilisés comme séparateurs  ; dans la syntaxe de PureBasic.  mListPBSep$ = ListPBSep$  ListPBSep$ + Chr(160)  ;  If *REContent = 0    ; On crée un espace mémoire pour *REContent.    *REContent = @REContent.String    ;    *REContent\s = LCase(ReplaceString(TOM_GetText(NoREGadget, "", 0, -1), Chr(10), "") + Chr(13))    ; Voir les explications données dans la procédure 'ColorizeBasicKeyWords'.  EndIf  ;  SStrLength = Len(*REContent\s)  ;  For TypeOfElement = 0 To (#EndEnumPBBElementTypes - 1)    If ListOfAllElements$(TypeOfElement)      If TypeOfElement = #PBBConstante        pEcolor = GetValueFromBPPrefFile("ConstantColor")      Else        pEcolor = GetValueFromBPPrefFile("PureKeywordColor")      EndIf      plist = 0      mplist = -1      Repeat        ; mplist est un indicateur qui permet de faire une première passe de mise en couleur        ; concernant la mention que contient #OutOfElementsName.        ; Les passes suivantes concerneront toutes les valeurs contenues dans le tableau        ; ListOfAllElements$().        If mplist = -1 And TypeOfElement = #PBBProcedure          ElementNameLCase$ = LCase(#OutOfElementsName)          mplist = 0        Else          mplist = plist + 1          plist = FindString(ListOfAllElements$(TypeOfElement), Chr(13), mplist)          If plist            ELine$ = FastMid(ListOfAllElements$(TypeOfElement), mplist, plist - mplist)            ElementNameLCase$ = PurifyElementName(StringField(ELine$, #EL_ElementNameLCase, Chr(9)))            ElementParent$ = StringField(ELine$, #EL_Parent, Chr(9))          EndIf        EndIf        If plist Or mplist = 0          PosInCode = posdep          Repeat            PosInCode = FindInPBPointedCode(*REContent, ElementNameLCase$, PosInCode + 1, #CheckAll | #CheckOneKeyWordOnly)            If PosInCode              pf = PosInCode + Len(ElementNameLCase$)              If pf > SStrLength : pf = SStrLength + 1 : EndIf              If ElementNameLCase$ <> DontUnderline$  And FastMid(*REContent\s, PosInCode, pf - PosInCode) <> LCase(#OutOfElementsName)                ; On ne souligne pas le nom de l'élément dans le titre.                *TextFontObjet = TOM_GetTextFontObj(NoREGadget, PosInCode - 1, pf - 1)                *TextFontObjet\SetUnderline(#TomSingle)                *TextFontObjet\Release()              EndIf              pfd = pf              ;              While Mid(*REContent\s, pfd, 1) = " " : pfd + 1 : Wend              ; On vérifie que le nom de la procédure est bien suivi d'une parenthèse ouvrante :              If mplist = 0 Or TypeOfElement <> #PBBProcedure Or Mid(*REContent\s, pfd, 1) = "(" Or ElementNameLCase$ = DontUnderline$                pd = PosInCode                If MainPBBPanelState = #FoundInFilesPBBPanel                  ; Quand on est dans le panneau "Trouvé dans...",                  ; on colorie tout jusqu'à la fin de la ligne.                  pf = FindString(*REContent\s, Chr(13), pf)                  If pf = 0 : pf = SStrLength + 1 : EndIf                  ;                  ; On examine maintenant ce qui se trouve avant pour voir si l'élément                  ; est précédé de 'In Macro' ou 'In Structure', par exemple. Si c'est le cas,                  ; on va étendre la sélection afin de donner la même couleur à toute la séquence                  pd = PosInCode                  ; On saute l'espace ou les deux points qui précèdent :                  While pd > 1 And (FastMid(*REContent\s, pd - 1, 1) = " " Or FastMid(*REContent\s, pd - 1, 1) = ":" Or FastMid(*REContent\s, pd - 1, 1) = Chr(160)) : pd - 1 : Wend                   ; On saute le mot qui précède :                  While pd > 1 And FindString(ListPBSep$ + Chr(160), FastMid(*REContent\s, pd - 1, 1)) = 0 : pd - 1 : Wend                  If pd > 3 And FastMid(*REContent\s, pd - 3, 3) = "in" + Chr(160)                    pd = pd - 3                  Else                    pd = PosInCode                  EndIf                EndIf                *TextFontObjet = TOM_GetTextFontObj(NoREGadget, pd - 1, pf - 1)                If mplist = 0 Or ElementParent$ Or ListCompletionUsed(TypeOfElement) < #ListCompletion_Done                  ; Si l'exploration profonde n'est pas terminée, on affiche par défaut l'élément                  ; comme s'il était utilisé.                  If ElementNameLCase$ = DontUnderline$ And TitleColor                    *TextFontObjet\SetForeColor(TitleColor)                  Else                    *TextFontObjet\SetForeColor(pEcolor)                  EndIf                Else ; sinon on colore en gris :                  *TextFontObjet\SetForeColor(pcolorNotUsed)                  IsUnUsed = 1                EndIf                *TextFontObjet\Release()              EndIf            EndIf          Until PosInCode = 0        EndIf      Until (plist = 0 And mplist)    EndIf  Next  ;  ListPBSep$ = mListPBSep$  ;  ProcedureReturn IsUnUsedEndProcedure;Procedure ColorizeInQuote(NoREGadget, posdep = 0, pcolor = 0, *REContent.String = 0)  ;  ;On colorie les textes entre guillemets.  ;  Protected PosInCode, pg, pgf, mp, REContent.String  Protected *TextFontObjet.ITextFont_Fixed  ;  If *REContent = 0    ; On crée un espace mémoire pour *REContent.    *REContent = @REContent.String    ;    *REContent\s = LCase(ReplaceString(TOM_GetText(NoREGadget, "", 0, -1), Chr(10), "") + Chr(13))    ; Voir les explications données dans la procédure 'ColorizeBasicKeyWords'.  EndIf  ;  If pcolor = 0    pcolor = GetValueFromBPPrefFile("StringColor")  EndIf  ;  ;  ; On colorie les textes entre guillemets.  ;  PosInCode = posdep  Repeat    mp = PosInCode    PosInCode = FindString(*REContent\s, Chr(13), PosInCode + 1)    If PosInCode      pgf = mp      Repeat        pg = FindString(*REContent\s, Chr(34), pgf + 1)        If pg And pg < PosInCode          pg + 1          ; On regarde si nous ne sommes pas en commentaire :          If FindString(Mid(*REContent\s, pgf, pg - pgf), ";") = 0            pgf = FindString(*REContent\s, Chr(34), pg)            If pgf = 0 Or pgf > PosInCode : pgf = PosInCode : EndIf            *TextFontObjet = TOM_GetTextFontObj(NoREGadget, pg - 1, pgf - 1)            *TextFontObjet\SetForeColor(pcolor)            *TextFontObjet\Release()          Else            pg = 0          EndIf        EndIf      Until pg = 0 Or pg > PosInCode    EndIf  Until PosInCode = 0EndProcedure;Procedure ColorizeBasicKeyWords(NoREGadget, posdep = 0, pcolor = 0, *REContent.String = 0, ElementUnused = 0)  ; On colorie les mots clés de PureBasic (if, endif, while, wend, etc.)  ; et on les met en gras  ;  Protected ne, PosInCode, pf, mListPBSep$, SStrLength, REContent.String, SColor  Protected *TextFontObjet.ITextFont_Fixed  ;  If *REContent = 0    ; On crée un espace mémoire pour *REContent.    *REContent = @REContent.String    ;    *REContent\s = LCase(ReplaceString(TOM_GetText(NoREGadget, "", 0, -1), Chr(10), "") + Chr(13))    ; Explication concernant l'élimination des Chr(10) :    ; Lorsque l'on extrait une chaîne d'un RichEdit Gadget avec TOM_GetText()    ; ou une autre méthode, les fins de ligne comportent la suite de caractères    ; Chr(13)+Chr(10). Pourtant, lorsque l'on veut faire une sélection sur son    ; contenu, les fins de ligne ne comptent que pour un seul caractère.    ; Pour que les comptes soient justes, entre l'examen de la chaîne et les instructions    ; de type 'SetSelection()' ou TOM_GetTextFontObj(), il faut donc éliminer un des deux caractères reçus.    ;    ; Explications concernant '*REContent\s' : lorsque le paramètre '*REContent'    ; a une valeur non nulle, la chaîne utilisée est celle contenu par le pointeur.    ; Elle n'est alors ni rechargée à partir du gadget, ni dupliquée en mémoire.    ; Cela peut permettre de gagner du temps et de l'espace mémoire.    ;  EndIf  ;  If pcolor = 0    pcolor = GetValueFromBPPrefFile("BasicKeywordColor")  EndIf  ;  ; On allège la liste des séparateurs pour gagner du temps  ; et ajouter le Chr(160) qui est nécessaire pour le traitement  ; de ce qui est affiché dans "Trouvé dans..."  ; ListPBSep$ est une variable globale déclarée et définie  ; juste avant la procedure 'FindInPBCode()'.  ; Elle contient la liste des caractère utilisés comme séparateurs  ; dans la syntaxe de PureBasic.  mListPBSep$ = ListPBSep$  ListPBSep$ = " :;." + Chr(13) + Chr(160)  SStrLength = Len(*REContent\s)  ;  For ne = 1 To ArraySize(PBBasicKeywordLCase$())    PosInCode = posdep - 1    Repeat      PosInCode = FindInPBPointedCode(*REContent, PBBasicKeywordLCase$(ne), PosInCode + 1, #CheckAll | #CheckOneKeyWordOnly)      If PosInCode        pf = PosInCode + Len(PBBasicKeywordLCase$(ne))        If pf >= SStrLength : pf = SStrLength : EndIf        *TextFontObjet = TOM_GetTextFontObj(NoREGadget, PosInCode - 1, pf)        *TextFontObjet\SetBold(#TomTrue)        *TextFontObjet\GetForeColor(@SColor)        ;        If SColor <> pcolorNotUsed          If Mid(*REContent\s, pf, 2) = " ▷"            ;            ; Nous sommes sur un nom de type d'élément de la liste "Trouvé dans...".            ; Les caractères " ▷" (triangle orienté à droite) ont été placés par            ; la procédure 'SetListFoundInFiles()', pour indiquer l'emplacement            ; où l'expression recherchée (s'il s'agit d'un élément) à été déclarée.            ; Il faut tout colorier jusqu'à la fin de la ligne.            ;            *TextFontObjet\Release()            pf = FindString(*REContent\s, Chr(13), PosInCode)            If pf = 0 : pf = SStrLength + 1 : EndIf            *TextFontObjet = TOM_GetTextFontObj(NoREGadget, PosInCode - 1, pf)            ;            If ElementUnused              ;              ; Le paramètre 'ElementUnused' nous indique que l'élément en question              ; est inutilisé et qu'il faut le colorier en gris.              *TextFontObjet\SetForeColor(pcolorNotUsed)            Else              *TextFontObjet\SetForeColor(pColor)            EndIf          Else            *TextFontObjet\SetForeColor(pColor)          EndIf        EndIf        *TextFontObjet\Release()      EndIf    Until PosInCode = 0  Next  ; On n'oublie pas de rétablir ListPBSep$  ; pour l'usage général :  ListPBSep$ = mListPBSep$EndProcedure;Procedure ColorizeNativeConstants(NoREGadget, posdep = 0, pcolor = 0, *REContent.String = 0)  ;  ; On colorie les noms des constantes natives de PureBasic ou de Windows.  ; Les constantes définies dans le programme seront colorisées par la  ; procédure 'ColorizeElementsNames()'.  ;  Protected PosInCode, pf, REContent.String, ElementNameLCase$  Protected *TextFontObjet.ITextFont_Fixed  ;  If *REContent = 0    ; On crée un espace mémoire pour *REContent.    *REContent = @REContent.String    ;    *REContent\s = LCase(ReplaceString(TOM_GetText(NoREGadget, "", 0, -1), Chr(10), "") + Chr(13))    ; Voir les explications données dans la procédure 'ColorizeBasicKeyWords'.  EndIf  ;  If pcolor = 0    pcolor = GetValueFromBPPrefFile("ConstantColor")  EndIf  ;  PosInCode = posdep  Repeat    PosInCode = FindString(*REContent\s, "#", PosInCode + 1)    If PosInCode      pf = FirstOccurrenceOfCharPointed(*REContent, ListPBSep$, PosInCode + 1) ; On cherche la fin du nom de constante      If pf        ElementNameLCase$ = FastMid(*REContent\s, PosInCode , pf - PosInCode) ; On extrait le nom de constante        ; on vérifie que la position trouvée n'est pas entre guillemets, ni en commentaires        If PosInCode = FindInPBPointedCode(*REContent, ElementNameLCase$, PosInCode, #CheckAll | #CheckOneKeyWordOnly)          *TextFontObjet = TOM_GetTextFontObj(NoREGadget, PosInCode - 1, pf)          *TextFontObjet\SetForeColor(pcolor)          *TextFontObjet\Release()        EndIf      EndIf    EndIf  Until PosInCode = 0EndProcedure;Procedure ColorizeComments(NoREGadget, posdep = 0, pcolor = 0, *REContent.String = 0)  ;  ; On colorie les commentaires  ;  ;  Protected PosInCode, mp, pv, nbg, REContent.String  Protected *TextFontObjet.ITextFont_Fixed  ;  If *REContent = 0    ; On crée un espace mémoire pour *REContent.    *REContent = @REContent.String    ;    *REContent\s = ReplaceString(TOM_GetText(NoREGadget, "", 0, -1), Chr(10), "") + Chr(13)    ; Voir les explications données dans la procédure 'ColorizeBasicKeyWords'.  EndIf  ;  If pcolor = 0    pcolor = GetValueFromBPPrefFile("CommentColor")  EndIf  ;  PosInCode = posdep  Repeat    mp = PosInCode + 1    PosInCode = FindString(*REContent\s, Chr(13), mp)    If PosInCode      pv = mp      CC_FindSemicolon:       pv = FindString(*REContent\s, ";", pv)      If pv And pv < PosInCode        nbg = CountString(FastMid(*REContent\s, mp, pv - mp), Chr(34))        If nbg & 1 ; il y a un nombre impair de guillemets avant le point virgule          pv + 1   ; On va chercher le suivant.          Goto CC_FindSemicolon        EndIf        *TextFontObjet = TOM_GetTextFontObj(NoREGadget, pv - 1, PosInCode)        *TextFontObjet\SetForeColor(pcolor)        *TextFontObjet\Release()      EndIf    EndIf  Until PosInCode = 0EndProcedure;Procedure GetActivePBBPanel()  ;  ; Examine l'état des deux panneaux imbriqués (MainPanelGadget et ListsPGadget)  ; et retourne le numéro figurant dans l'énumération 'PBBPanel' en fonction  ; du panneau actuellement actif.  ;  Protected TypeOfElement  ;  For TypeOfElement = 0 To #EndEnumPBBPanels - 1    ; #ListPBBPanel est un panneau qui comporte d'autres panneaux    ; on poursuit donc l'exploration si l'on tombe sur lui.    If GetGadgetState(NoGadgetPBBPanel(TypeOfElement)) = NoPBBPanel(TypeOfElement) And TypeOfElement <> #ListPBBPanel      ProcedureReturn TypeOfElement    EndIf  NextEndProcedure;Procedure GetREGadgetNbrFromActivePBBPanel()  ;  ; Examine l'état des deux panneaux imbriqués (MainPanelGadget et ListsPGadget)  ; et retourne le numéro de gadget du RichEditGadget (EditorGadget) correspondant  ; au panneau actuellement actif.  ;  ProcedureReturn NoREGadgetOfPBBPanel(GetActivePBBPanel())EndProcedure;Procedure SetActivePBBPanel(NoPBBPanel)  ;  ; NoPBBPanel doit être l'une des valeurs de l'énumération 'PBBPanels'  ; (voir la déclaration de cette énumération au début du programme)  ;  ; #FilePBBPanel  ; #ListPBBPanel  ; #DetailPBBPanel  ; #FoundInFilesPBBPanel  ;  ; #ProcPBBPanel  ; #StructurePBBPanel  ; #MacroPBBPanel  ; ...  Protected TypeOfElement  ;  For TypeOfElement = 0 To #EndEnumPBBPanels - 1    If NoREGadgetOfPBBPanel(TypeOfElement) And TypeOfElement = NoPBBPanel      If TypeOfElement >= #ProcPBBPanel        ; Si nous sommes dans le PanelGadget 'ListsPGadget', qui est imbriqué        ; dans le PanelGadget 'MainPanelGadget', on positionne 'MainPanelGadget' sur #ListPBBPanel        SetGadgetState(NoGadgetPBBPanel(#ListPBBPanel), NoPBBPanel(#ListPBBPanel))      EndIf      SetGadgetState(NoGadgetPBBPanel(TypeOfElement), NoPBBPanel(TypeOfElement))    EndIf  NextEndProcedure  ;; ****************************************************************************;;                         Gestion des listes d'éléments;; ****************************************************************************;; Les 'éléments' correspondent aux différentes portions de code que l'on peut; isoler dans un code global. Les procédures, les macros et les structures,; par exemple, correspondent à cette notion d''élément'.; La liste complète de ce que nous définissons comme 'éléments' figure dans; l'énumération 'PBBTypes' qui figure dans le fichier des déclarations :;   #PBBProcedure;   #PBBStructure;   #PBBMacro;   #PBBEnumeration;   #PBBInterface;   #PBBLabel;   #PBBConstante;   #PBBVariable ;; Lorsqu'un fichier de code est ouvert dans PBBrowser, il est aussitôt; examiné afin de dresser la liste de ses éléments. Cette liste est; enregistrée dans le tableau global 'ListOfAllElements$()'.; Une deuxième phase d'exploration tente ensuite de déterminer quels; sont les éléments qui figurent dans le code sans être utilisés par; aucun autre, et quels sont ceux qui sont utilisés. La liste des; éléments utilisés est enregistrée dans le tableau ListOfUsedElements$().;; Les procédures ci-dessous sont chargée de créer et de mettre à jour; ces listes en cas de modifications dans les fichiers source.Procedure.s InsertValueIntoListLine(Line$, Value$, Field)  ;  ; Intègre une valeur dans une ligne de liste ('ListOfAllElements$()' ou 'ListOfUsedElements$()'),  ; en respectant l'organisation de données proposée par l'énumération 'StructureOfElementsLists'.  ;  Protected ps, mps, posInLine  Protected RLine$ ; Valeur de retour.  ;  If Line$ = ""    ; Il faut créer la ligne.    ; On place tous les repères afin que l'insertion    ; de la valeur se fasse au bon endroit.    For ps = 1 To #EL_EndOfLine - 1      Line$ + Chr(9)    Next  EndIf  ;  ps = 0  posInLine = 0  Repeat    mps = ps    ps = FindString(Line$, Chr(9), ps + 1)    posInLine + 1  Until posInLine = Field  RLine$ = FastLeft(Line$, mps) + Value$ + FastMid(Line$, ps)  ProcedureReturn RLine$EndProcedure;Procedure RecordElementInList(TypeOfElement, ElementName$, FileName$, CompleteElementDeclaration$, StartingLine, EndingLine, ElementStartingPos, ElementEndingPos, VariableSpecies$, PBBLComment$, PosInList = 0)  ;  Protected RLine$, PosInListF  ;  RLine$ = ""  RLine$ = InsertValueIntoListLine(RLine$, LCase(ElementName$), #EL_ElementNameLCase)  RLine$ = InsertValueIntoListLine(RLine$, ElementName$, #EL_ElementName)  RLine$ = InsertValueIntoListLine(RLine$, FileName$, #EL_FileName)  RLine$ = InsertValueIntoListLine(RLine$, CompleteElementDeclaration$, #EL_CompleteElementDeclaration)  RLine$ = InsertValueIntoListLine(RLine$, Str(StartingLine), #EL_StartingLine)  RLine$ = InsertValueIntoListLine(RLine$, Str(EndingLine), #EL_EndingLine)  RLine$ = InsertValueIntoListLine(RLine$, Str(ElementStartingPos), #EL_StartingPos)  RLine$ = InsertValueIntoListLine(RLine$, Str(ElementEndingPos), #EL_EndingPos)  RLine$ = InsertValueIntoListLine(RLine$, VariableSpecies$, #EL_VariableSpecies)  RLine$ = InsertValueIntoListLine(RLine$, PBBLComment$, #EL_Comment)  ;  If PosInList    ; Si l'argument PosInList est non nul, il faut remplacer une ligne existante :    PosInListF = FindString(ListOfAllElements$(TypeOfElement), Chr(13), PosInList)    ListOfAllElements$(TypeOfElement) = FastLeft(ListOfAllElements$(TypeOfElement), PosInList - 1) + RLine$ + FastMid(ListOfAllElements$(TypeOfElement), PosInListF)  Else    ; Sinon, on ajoute la ligne à la liste :    ListOfAllElements$(TypeOfElement) + RLine$ + Chr(13)  EndIf  ;EndProcedure;Procedure.s CheckListOfElementsIntegrity(Array ListToTest$(1), TypeOfElement)  ;  ; Procedure utilisée lors du déboguage, pour vérifier que  ; l'intégrité de la liste ListOf(All/Used)Elements$(TypeOfElement)  ; n'a pas été compromise par une mauvaise manipulation lors  ; de l'enregistrement des données.  ;  ; Cette procédure ne sera pas appelée lors du fonctionnement  ; normal de PBBrowser. Elle ne sert que pour le debogage.  ;  Protected error, PosInList, mPosInList, LineE$, FTest$  Protected *ElementCode.String, tx$  ;  If @ListToTest$() = @ListOfUsedElements$()    TestedList$ = "ListOfUsedElements$(" + PBBTypeNames$(TypeOfElement) + ")"  Else    TestedList$ = "ListOfAllElements$(" + PBBTypeNames$(TypeOfElement) + ")"  EndIf  ;  tx$ = "*********** CheckListOfElementsIntegrity ***********" + Chr(13)  tx$ + TestedList$ + Chr(13)  ;  error = 0  If ListToTest$(TypeOfElement)    ; Teste la présence d'un retour chariot (chr(13) à la fin de la liste :    If Right(ListToTest$(TypeOfElement), 1) <> Chr(13)      tx$ + "LAST CR IS MISSING !"      error = 1    EndIf    ;    If error = 0      ; Regarde si les noms de fichier enregistrés pour chaque élément pointent      ; bien vers de fichiers valides :      PosInList = 0      Repeat        mPosInList = PosInList + 1        PosInList = FindString(ListToTest$(TypeOfElement), Chr(13), mPosInList)        If PosInList          LineE$ = FastMid(ListToTest$(TypeOfElement), mPosInList, PosInList - mPosInList)          FSource$ = StringField(LineE$, #EL_FileName, Chr(9))          If FileSize(FSource$) < 1            tx$ + "Data error for " + StringField(LineE$, #EL_ElementName, Chr(9)) + Chr(13)            tx$ + "Line of element = " + LineE$ + Chr(13)            tx$ + "Invalid source file name : " + FSource$ + Chr(13)            error = 1            Break          ElseIf TypeOfElement < #PBBLabel            ElementStartingPos = Val(StringField(LineE$, #EL_StartingPos, Chr(9)))            ElementEndingPos = Val(StringField(LineE$, #EL_EndingPos, Chr(9)))            *ElementCode = GetPointedElementContentFromFile(FSource$, ElementStartingPos, ElementEndingPos, #False)            If Left(*ElementCode\s, Len(PBBTypeNames$(TypeOfElement))) <> PBBTypeNames$(TypeOfElement)              tx$ +  "Element positions are corrupted for " + StringField(LineE$, #EL_ElementName, Chr(9)) + " in " + GetFilePart(FSource$) + Chr(13)              tx$ +  "Expected value: " + PBBTypeNames$(TypeOfElement) + Chr(13)              tx$ +  "Found value: " + Left(*ElementCode\s, Len(PBBTypeNames$(TypeOfElement))) + Chr(13)              error = 1              Break            EndIf          EndIf        EndIf      Until PosInList = 0    EndIf  EndIf  If error    ProcedureReturn tx$  EndIfEndProcedure;Procedure.s RunCheckAllListsOfElementsIntegrity(Silence = 0)    ;  ; Procedure utilisée lors du déboguage, pour vérifier que  ; l'intégrité des tableaux ListOfAllElements$() et   ; ListOfUsedElements$() n'a pas été compromise par une  ; mauvaise manipulation lors de l'enregistrement des données.  ;  ; Cette procédure ne sera pas appelée lors du fonctionnement  ; normal de PBBrowser. Elle ne sert que pour le debogage.  ;  Protected Error = 0  For TypeOfElement = 0 To (#EndEnumPBBElementTypes - 1)    tx$ = CheckListOfElementsIntegrity(ListOfAllElements$(), TypeOfElement)    If tx$      Error = 1      Break    EndIf  Next  If Error = 0    For TypeOfElement = 0 To (#EndEnumPBBElementTypes - 1)      tx$ = CheckListOfElementsIntegrity(ListOfUsedElements$(), TypeOfElement)      If tx$        Error = 1        Break      EndIf    Next  EndIf  If Silence = 0    If Error = 0      AlertInPBBWindow("All is OK.")    Else      AlertInPBBWindow(tx$)    EndIf  EndIf  ProcedureReturn tx$EndProcedure;Procedure CompleteListOfAllElements(FileName$, TypeOfElement, PriorityMode, CLE_StartTime, *Limits.Point = 0)  ;  ; Voir l'énumération 'PBBTypes' pour connaître les valeurs possibles de 'TypeOfElement'.  ; Par exemple :  ; #PBBProcedure  ; #PBBStructure  ; #PBBMacro  ; #PBBEnumeration  ; #PBBInterface  ; #PBBLabel  ; #PBBConstante  ; ...  ;  ; Cette procédure, établi la liste des procédures, structures, macros, etc. définies dans le fichier 'FileName$'.  ; Elle retourne le résultat sous la forme d'un fichier texte dont chaque ligne respecte la structure proposée  ; par l'énumération 'StructureOfElementsLists' :  ; 'Nom de l'élément (de la structure, de la procédure, etc.)' + Chr(9)  ;       + 'Adresse du fichier contenant l'élément' + Chr(9)  ;       + 'Déclaration complète de l'élement (avec arguments, s'il y en a)'  + Chr(9)  ;       + 'N° de ligne du début dans le fichier'  + Chr(9)  ;       + 'N° de ligne de la fin dans le fichier' + Chr(9)  ;       + 'Élément parent' +Chr(9)                          (sera complété par 'CompleteListOfUsedElements()')  ;       + 'Énumération définissant la constante' +Chr(9)    (pour les constantes seulement)  ;       + 'Valeur de la constante' +Chr(9)                  (pour les constantes seulement)  ;       + 'Commentaire de l'élément' +Chr(9)                (si la déclaration est assortie d'un commentaire)  ;       + Chr(13)  ;  ; Cette procédure est conçue pour pouvoir tourner en tâche de fond  ; et s'interrompre au bout de 200 millisecondes écoulées depuis 'CLE_StartTime',  ; mais elle ira jusqu'au bout de l'exploration si PriorityMode = '#FinishCompletionNow'.  ;  ; Si 'PriorityMode' a une valeur différente de '#WorkInBackGround', une fenêtre d'attente sera affichée  ; pendant son exécution.  ;  Shared PBBLComment$ ; Utilisé pour récupérer le commentaire des déclarations  ;  Static *SearchString.String ; Contient la portion de code sur laquelle on est en train                              ; de travailler.  Static mTypeOfElement       ; Contient le dernier type d'élément sur lequel on a travaillé,                              ; pour ne pas devoir rechercher et traduire son nom à chaque fois.  Static PBBType$, PBBTypeTranslated$, PBBExtendedType$ ; Nom du type d'élément.  Static VariableSpecies  ;  Protected SStrLength ; Pour éviter de calculer trop souvent la longueur totale de la chaîne examinée,                       ; On ne le fait qu'une fois en début de procédure.  Protected PosInCode, pd, pf, pfe, LastCodeStartingPos, tp, mps, mpo, cont ; diverses positions dans le code.  Protected ExistingElement ; Utilisé pour tester si l'elément figure déjà dans la liste.  Protected ElementStartingPos, RealElement ; Résultats des vérifications pour les différents type d'éléments.  Protected ExtractLine$                    ; Pour travailler sur des extraits de code.  Protected EFName$, reboot  ;  ; Paramètres des éléments trouvés dans le code :  Protected ElementEndingPos, StartingLine, EndingLine, ElementName$, CompleteElementDeclaration$, UnNamed  ;  ; Autres variables :  Protected VariableSpecies$, FinishExam, VariableSubSpecies$, pp  Protected NbParenthesis, PosParenthesis, ppar, ElementNameLCase$, mExistingElement, ExtendedTypeName$  ;  If ListCompletionAll(TypeOfElement) < #ListCompletion_Done ; On ne refait pas le boulot s'il est déjà fait    If ListCompletionAll(TypeOfElement) = #ListCompletion_Undone      ; On démarre (ou on redémarre) à zéro pour cet élément.      ListOfAllElements$(TypeOfElement) = ""      PosInCode = 0    EndIf    ;    If FileName$      ; Le fichier a examiner (fichier de référence) a changé.      ListCompletionReference$(TypeOfElement) = FileName$      *SearchString = GetPointedCodeFromFile(FileName$)      If *Limits        PosInCode = *Limits\x - 1      Else        PosInCode = 0      EndIf      VariableSpecies = 1    Else      ; L'exploration a déjà commencé. On la poursuit.      PosInCode = ListCompletionStage(TypeOfElement)      FileName$ = ListCompletionReference$(TypeOfElement)    EndIf    ;    SStrLength = Len(*SearchString\s)    ;    If mTypeOfElement <> TypeOfElement Or PBBType$ = ""      PBBType$ = PBBTypeNames$(TypeOfElement)      PBBTypeTranslated$ = GetTextFromCatalog(PBBType$ + "s")      If TypeOfElement = #PBBEnumeration        ; Pour ce cas particulier, on recherchera les deux types d'énumération.        PBBExtendedType$ = "Enumeration,EnumerationBinary"      Else        PBBExtendedType$ = PBBType$      EndIf      mTypeOfElement = TypeOfElement    EndIf    ;    If TypeOfElement = #PBBVariable      ; L'identification des Variables est tout à fait particulière et nous la traitons entièrement à part.      ;      ; À proprement parler, une variable n'est d'ailleurs par un élément (organisé en 'Element'..... 'EndElement dans le code).      ;      ; Comme nous avons décidé de classer les variables en plusieurs catégories      ; (Global, Shared, Static, Protected, Local), cela nous oblige à mener plusieurs recherches pour      ; chacune de ces catégories. Par ailleurs, pour une seule déclaration de type 'Global', par exemple,      ; il peut y avoir plusieur variables  à enregistrer (séparées par des virgules).      ; L'élément 'Variable' est le seul à présenter des complications de ce genre.      ;      Repeat        VariableSpecies$ = StringField(#PBBVariableSpecies$, VariableSpecies, ",")        ;        Repeat          ManageWaitingWindow(PriorityMode, GetTextFromCatalog("LookingForElements") + " " + PBBTypeTranslated$ + ".", PBBTypeTranslated$)          PBBLComment$ = ""          FinishExam = 0          ;          PosInCode = FindString(*SearchString\s, VariableSpecies$, PosInCode + 1)          If *Limits And PosInCode > *Limits\y : PosInCode = 0 : EndIf          If PosInCode            CompleteElementDeclaration$ = ExtractSectionArroundExpression(*SearchString, VariableSpecies$, PosInCode, #True)            If CompleteElementDeclaration$              StartingLine = CountString(FastMid(*SearchString\s, 1, PosInCode), Chr(13)) + 1              EndingLine = StartingLine              ;              ElementStartingPos = Len(VariableSpecies$) + 1              VariableSubSpecies$ = "Var"              Repeat                While ElementStartingPos <= Len(CompleteElementDeclaration$) And (FastMid(CompleteElementDeclaration$, ElementStartingPos, 1) = " " Or FastMid(CompleteElementDeclaration$, ElementStartingPos, 1) = ",")                  If FastMid(CompleteElementDeclaration$, ElementStartingPos, 1) = ","                    VariableSubSpecies$ = "Var"                  EndIf                  ElementStartingPos + 1                Wend                If FastMid(CompleteElementDeclaration$, ElementStartingPos, 1) = "="                  Repeat                    pp = FindInPBStringCode(CompleteElementDeclaration$, "(", ElementStartingPos, #CheckOnlyComAndQuote | #CheckOneKeyWordOnly)                    ElementStartingPos = FindInPBStringCode(CompleteElementDeclaration$, ",", ElementStartingPos, #CheckOnlyComAndQuote | #CheckOneKeyWordOnly)                    If pp And ElementStartingPos And pp < ElementStartingPos                      ElementStartingPos = FindInPBStringCode(CompleteElementDeclaration$, ")", pp, #CheckOnlyComAndQuote | #CheckOneKeyWordOnly)                    EndIf                  Until pp = 0 Or ElementStartingPos = 0 Or pp > ElementStartingPos                ElseIf FastMid(CompleteElementDeclaration$, ElementStartingPos, 3) = "Dim"                  VariableSubSpecies$ = "Array"                  ElementStartingPos = FindString(CompleteElementDeclaration$, " ", ElementStartingPos)                ElseIf FastMid(CompleteElementDeclaration$, ElementStartingPos, 7) = "NewList"                  VariableSubSpecies$ = "List"                  ElementStartingPos = FindString(CompleteElementDeclaration$, " ", ElementStartingPos)                Else                  ElementEndingPos = FirstOccurrenceOfChar(CompleteElementDeclaration$, " ,:=" + Chr(13), ElementStartingPos)                  If ElementEndingPos  = 0 : FinishExam = 1 : ElementEndingPos = Len(CompleteElementDeclaration$) + 1 : EndIf                  ;                  If ElementEndingPos > ElementStartingPos                    ElementName$ = FastMid(CompleteElementDeclaration$, ElementStartingPos, ElementEndingPos - ElementStartingPos)                    ;                    NbParenthesis = 0                    PosParenthesis = 0                    Repeat                      PosParenthesis = FindInPBStringCode(ElementName$, "(", PosParenthesis + 1, #CheckOnlyComAndQuote | #CheckOneKeyWordOnly)                      If PosParenthesis : NbParenthesis + 1 : EndIf                    Until PosParenthesis = 0                    PosParenthesis = 0                    Repeat                      PosParenthesis = FindInPBStringCode(ElementName$, ")", PosParenthesis + 1, #CheckOnlyComAndQuote | #CheckOneKeyWordOnly)                      If PosParenthesis : NbParenthesis - 1 : EndIf                    Until PosParenthesis = 0                    ;                    If NbParenthesis > 0                      While NbParenthesis                        ElementEndingPos = FindInPBStringCode(CompleteElementDeclaration$, ")", ElementEndingPos, #CheckOnlyComAndQuote)                        If ElementEndingPos = 0                          ElementEndingPos = Len(CompleteElementDeclaration$)                          NbParenthesis = 0                          FinishExam = 1                        Else                          ElementEndingPos + 1                          NbParenthesis - 1                        EndIf                      Wend                      ElementName$ = FastMid(CompleteElementDeclaration$, ElementStartingPos, ElementEndingPos - ElementStartingPos)                    EndIf                    ;                    ppar = FindString(ElementName$, "(")                    If ppar                      ElementName$ = FastLeft(ElementName$, ppar - 1)                    EndIf                    ;                    ElementNameLCase$ = PurifyElementName(ElementName$)                    CheckIfElementExistsInList(ListOfAllElements$(TypeOfElement), ElementNameLCase$, TypeOfElement)                    ;                    If ExistingElement = 0                      ;                      RecordElementInList(TypeOfElement, ElementName$, FileName$, CompleteElementDeclaration$, StartingLine, EndingLine, PosInCode, PosInCode + Len(CompleteElementDeclaration$), VariableSpecies$ + " " + VariableSubSpecies$, PBBLComment$)                      ListOfAllElementsNbr(TypeOfElement) + 1                      ;                    EndIf                  EndIf                  ElementStartingPos = ElementEndingPos                EndIf                                Until ElementStartingPos = 0 Or FinishExam              :               PosInCode + Len(CompleteElementDeclaration$)              ;            Else              PosInCode + Len(VariableSpecies$)            EndIf          EndIf          If PosInCode = 0            VariableSpecies + 1          EndIf        Until PosInCode = 0 Or ((ElapsedMilliseconds() - CLE_StartTime > 200) And PriorityMode <> #FinishCompletionNow)      Until VariableSpecies = 3 Or ((ElapsedMilliseconds() - CLE_StartTime > 200) And PriorityMode <> #FinishCompletionNow)    Else      Repeat        ManageWaitingWindow(PriorityMode, GetTextFromCatalog("LookingForElements") + " " + PBBTypeTranslated$ + ".", PBBTypeTranslated$)        ElementStartingPos = 0        LastCodeStartingPos = PosInCode        PBBLComment$ = ""        If TypeOfElement = #PBBLabel          ;          ; L'identification des Labels est, elle aussi, particulière, mais comme          ; il n'y a qu'un label par ligne, on traite ce cas dans un flux commun          ; avec celui des autres éléments.          ;          PosInCode = FindString(*SearchString\s, ":", PosInCode + 1)          If *Limits And PosInCode > *Limits\y : PosInCode = 0 : EndIf          If PosInCode            ; On mémorise la position de fin de nom :            mps = PosInCode            ; On saute les espaces qui suivent            pf = PosInCode + 1            While pf <= SStrLength And PeekC(@*SearchString\s + (pf - 1) * SizeOf(CHARACTER)) = 32 : pf + 1 : Wend            ; Nous recherchons un label. Il faut donc que le ":" qui est placé à la fin            ; du nom de label figure en fin de ligne, sinon, cette ligne ne nous intéresse pas.            ; La fin de ligne peut être le bout de la chaîne '*SearchString\s' ou bien            ; un retour chariot (Chr(13)) ou bien ":".            ;            If pf > SStrLength Or FastMid(*SearchString\s, pf, 1) = ":" Or FastMid(*SearchString\s, pf, 1) = Chr(13)              ; Nous sommes bien en fin de ligne. Cherchons le premier séparateur qui précède              ; le nom du label éventuel.              While PosInCode > 1 And FindString(ListPBSep$, FastMid(*SearchString\s, PosInCode - 1, 1)) = 0 : PosInCode - 1 : Wend              If PosInCode And PosInCode < mps ; Le label doit être collé aux ":". S'il y a un séparateur juste avant, ce n'est pas un label.                ElementName$ = FastMid(*SearchString\s, PosInCode, mps - PosInCode)                ElementNameLCase$ = LCase(ElementName$)                CheckIfElementExistsInList(ListOfAllElements$(TypeOfElement), ElementNameLCase$, TypeOfElement)                ; Si cet élément n'est pas déjà recensé, s'il ne s'agit pas de "Else" et s'il ne s'agit pas d'un nom de module :                If ExistingElement = 0 And ElementName$ <> "Else" And FastMid(*SearchString\s, mps, 2) <> "::"                  ; On extrait la portion de ligne contenant l'expression,                  ; et on vérifie du même coup que l'expression trouvée                  ; n'est pas entre guillemets ou en commentaire.                  ExtractLine$ = ExtractSectionArroundExpression(*SearchString, ElementName$, PosInCode, #True)                  If ExtractLine$ = ElementName$  ; On vérifie que l'on n'a rien entre le début de Ligne et le label.                    ElementName$ + ":"                    CompleteElementDeclaration$ = ElementName$                    RealElement = 0                    ElementStartingPos = PosInCode                    ElementEndingPos = mps                  EndIf                EndIf              EndIf              PosInCode = mps            EndIf          EndIf        ElseIf TypeOfElement = #PBBConstante          ;          ; L'identification des Constantes est, elle aussi, particulière,          ; mais on peut traiter ce cas dans un flux commun avec celui des autres éléments.          ;          PosInCode = FindString(*SearchString\s, "#", PosInCode + 1)          If *Limits And PosInCode > *Limits\y : PosInCode = 0 : EndIf          If PosInCode            pd = PosInCode - 1            ; On saute les espaces qui précèdent.            If pd              FastSkipPrecSpaces(*SearchString\s, pd)            EndIf            ; Seules les déclarations de constantes nous intéressent ici.            ; Il faut donc que le "#" soit placé en début de ligne, sinon cela            ; ne nous intéresse pas.            ;            If pd = 0 Or FastMid(*SearchString\s, pd, 1) = ":" Or FastMid(*SearchString\s, pd, 1) = Chr(13)              pf = PosInCode + 1              ; On cherche la fin du nom de constante.              cont = 1              Repeat                If pf <= SStrLength And FindString(" :=;" + Chr(13), FastMid(*SearchString\s, pf, 1)) = 0                  pf + 1                Else                  cont = 0                EndIf              Until cont = 0              ; On mémorise la position de fin de nom.              pfe = pf              ; On saute les espaces qui suivent le nom.              While pfe <= SStrLength And PeekC(@*SearchString\s + (pfe - 1) * SizeOf(CHARACTER)) = 32 : pfe + 1 : Wend              ; Seuls une fin de ligne, un commentaire, ou le caractère "=" sont possibles après le nom              ; de la constante, lors de sa déclaration.              If pfe > SStrLength Or FindString(":=;" + Chr(13), FastMid(*SearchString\s, pfe, 1))                ElementName$ = FastMid(*SearchString\s, PosInCode, pf - PosInCode)                ElementNameLCase$ = LCase(ElementName$)                CheckIfElementExistsInList(ListOfAllElements$(TypeOfElement), ElementNameLCase$, TypeOfElement)                If ExistingElement = 0 ; Si cet élément n'est pas déjà recensé...                  ; On va, à la fois extraire le tronçon de code où figure la constante,                  ; et vérifier que ce que nous venons de trouver n'est pas entre guillemets ou en commentaire :                  CompleteElementDeclaration$ = ExtractSectionArroundExpression(*SearchString, ElementName$, PosInCode, #True)                  If CompleteElementDeclaration$                    RealElement = 0                    ElementStartingPos = PosInCode                    PosInCode + Len(ExtractLine$)                    ElementEndingPos = PosInCode - 1                  EndIf                EndIf              EndIf            EndIf          EndIf        Else          ;          ; À partir d'ici, on gère de la même façon tous les éléments de type 'Element'....'EndElement'.          ;          UnNamed = 0          PosInCode = FindInPBPointedCode(*SearchString, PBBExtendedType$, PosInCode)          If *Limits And PosInCode > *Limits\y : PosInCode = 0 : EndIf          If PosInCode            mpo = PosInCode            PosInCode + Len(PBBType$)            mps = PosInCode            ; Si l'élement a un nom, il y a obligatoirement un espace entre la déclaration            ; du type de l'élément (Procédure, Structure, Macro, etc.) et le nom de l'élément.            PosInCode = FindString(*SearchString\s, " ", PosInCode)            If PosInCode = 0 : PosInCode = SStrLength + 1 : EndIf            If TypeOfElement = #PBBProcedure              ; #PBBProcedure est le type le plus commun, alors gagnons du temps              ; en cherchant le seul séparateur possible entre le nom de procédure              ; et ce qui suivra ;              pf = FindString(*SearchString\s, "(", PosInCode)            Else              ; Nous allons vérifier que l'élément a bien un nom, car les énumérations              ; n'en ont pas forcément :              ;              ; On commence par étendre la zone contenant le type,              ; pour le cas où on a 'Procedure.s', par exemple.              ExtendedTypeName$ = ""              If PosInCode - mps > 0 And mps <= SStrLength                ExtendedTypeName$ = FastMid(*SearchString\s, mps, PosInCode - mps)              EndIf              tp = FirstOccurrenceOfChar(ExtendedTypeName$, ":;" + Chr(13))              If tp                ; Juste après le type de l'élément, on a trouvé une fin de ligne ou un commentaire,                ; avant même de trouver un espace. Donc l'élément n'a pas de nom.                PosInCode = mps + tp                pf = PosInCode              Else                ; Nous allons chercher le début du nom :                While PosInCode <= SStrLength And PeekC(@*SearchString\s + (PosInCode - 1) * SizeOf(CHARACTER)) = 32 : PosInCode + 1 : Wend                ; Puis la fin du nom :                pf = FirstOccurrenceOfCharPointed(*SearchString, " :(;" + Chr(13), PosInCode)              EndIf            EndIf            ElementName$ = ""            If pf - PosInCode > 0              ElementName$ = Trim(FastMid(*SearchString\s, PosInCode, pf - PosInCode))            EndIf            If ElementName$ = ""              If PosInCode > SStrLength : PosInCode = SStrLength : EndIf              StartingLine = CountString(FastMid(*SearchString\s, 1, mpo), Chr(13)) + 1              ElementName$ = "UnNamed - Line " + Str(StartingLine)              UnNamed = 1            EndIf            ;            RealElement = 1            ElementNameLCase$ = LCase(ElementName$)            CheckIfElementExistsInList(ListOfAllElements$(TypeOfElement), ElementNameLCase$, TypeOfElement)            If ExistingElement = 0 ; Si cet élément n'est pas déjà rencensé...              ElementStartingPos = mpo            EndIf          EndIf        EndIf        If ElementStartingPos          If ElementStartingPos > SStrLength : ElementStartingPos = SStrLength : EndIf ; Au cas où...          If UnNamed = 0            StartingLine = CountString(FastMid(*SearchString\s, 1, ElementStartingPos), Chr(13)) + 1          EndIf          If RealElement            ElementEndingPos = FindInPBPointedCode(*SearchString, "End" + PBBType$, pf, #CheckAll | #CheckOneKeyWordOnly)            If ElementEndingPos              ElementEndingPos + Len("End" + PBBType$)            Else              ElementEndingPos = SStrLength + 1            EndIf            EndingLine = StartingLine + CountString(FastMid(*SearchString\s, ElementStartingPos, ElementEndingPos - ElementStartingPos), Chr(13)) + 1            If UnNamed              CompleteElementDeclaration$ = ExtractSectionArroundExpression(*SearchString, PBBType$, ElementStartingPos, #True)            Else              CompleteElementDeclaration$ = ExtractSectionArroundExpression(*SearchString, ElementName$, ElementStartingPos, #True)            EndIf          Else            EndingLine = StartingLine          EndIf          ;          ; On positionne ElementEndingPos à la fin de la ligne comprenant la fin de l'élément,          ; afin d'englober un éventuel commentaire qui suivrait :          ElementEndingPos = FirstOccurrenceOfCharPointed(*SearchString, ":" + Chr(13), ElementEndingPos)          If ElementEndingPos = 0 : ElementEndingPos = SStrLength + 1 : EndIf          ;          RecordElementInList(TypeOfElement, ElementName$, FileName$, CompleteElementDeclaration$, StartingLine, EndingLine, ElementStartingPos, ElementEndingPos, "", PBBLComment$)          ListOfAllElementsNbr(TypeOfElement) + 1          ;        EndIf        ;        reboot = 0        If PosInCode = 0  And PriorityMode = #FinishCompletionNow And TypeOfElement = #PBBVariable          VariableSpecies + 1          If StringField(#PBBVariableSpecies$, VariableSpecies, ",")            reboot = 1          EndIf        EndIf        ;      Until reboot = 0 And (PosInCode = 0 Or ((ElapsedMilliseconds() - CLE_StartTime > 200) And PriorityMode <> #FinishCompletionNow))      ;    EndIf    ;    If PosInCode > 0 ; l'exploration a été interrompue, on la reprendra plus tard.      ListCompletionAll(TypeOfElement) = #ListCompletion_Pending      ListCompletionStage(TypeOfElement) = PosInCode    Else      ListCompletionAll(TypeOfElement) = #ListCompletion_StageCompleted    EndIf    ;  EndIf  ;EndProcedure;Procedure DeleteLinesBeginningBy(ToErase$, *SearchString.string)  ;  ; Supprime de *SearchString\s les lignes qui commencent par 'ToErase$'.  ;  Protected PosInCode, pf, pRd  ;  PosInCode = 0  Repeat    PosInCode = FindString(*SearchString\s, ToErase$, PosInCode + 1)    If PosInCode      pRd = PosInCode      pf = PosInCode + Len(ToErase$)      ; Le mot recherché doit être suivi d'un caractère séparateur.      If pf <= Len(*SearchString\s) And FindString(ListPBSep$, FastMid(*SearchString\s, pf, 1))        While pRd > 1 And FastMid(*SearchString\s, pRd - 1, 1) <> Chr(13) And FastMid(*SearchString\s, pRd - 1, 1) <> ":" : pRd - 1 : Wend        ; On vérifie que 'ToErase$' se trouve bien en début de ligne ou juste après ":"        If Trim(FastMid(*SearchString\s, pRd, PosInCode - pRd)) = ""          ; On cherche jusqu'où on va supprimer ce qui suit :          pf = FirstOccurrenceOfCharPointed(*SearchString, Chr(13) + ":", pf)          *SearchString\s = FastLeft(*SearchString\s, pRd - 1) + FastMid(*SearchString\s, pf)          PosInCode = pRd - 2        Else          PosInCode = pf        EndIf      Else        PosInCode = pf      EndIf    EndIf  Until PosInCode = 0EndProcedure;Procedure TakeOffOneElementContentFromCode(TypeNames$, *SearchString.String)  ;  ; La compilation de code 'hors-éléments' servira à la procédure SetAllListsOfUsedElements()  ; pour déterminer quels éléments sont utilisés ou non.  ;  ; Cette procédure retire le contenu d'un élément donné (TypeName$) du code contenu  ; dans *SearchString, afin de générer un contenu 'hors-éléments'.  ;  Protected PosInCode, pf  ;  PosInCode = 0  Repeat    PosInCode = FindInPBPointedCode(*SearchString, TypeNames$, PosInCode, #CheckAll | #CheckOneKeyWordOnly)    If PosInCode      pf = FindInPBPointedCode(*SearchString, "end" + TypeNames$, PosInCode + 1, #CheckAll | #CheckOneKeyWordOnly)      If pf        pf + Len("end" + TypeNames$) + 1        If pf < Len(*SearchString\s)          *SearchString\s = FastLeft(*SearchString\s, PosInCode - 1) + FastMid(*SearchString\s, pf)        Else          *SearchString\s = FastLeft(*SearchString\s, PosInCode - 1)        EndIf      Else        *SearchString\s = FastLeft(*SearchString\s, PosInCode - 1)      EndIf    EndIf  Until PosInCode = 0  ;EndProcedure;Procedure SetDeclarePositionsForProc(FileName$, *SearchString.String, PosInCode = 0, EndPos = 0)  ;  ; Recherche les mentions "Declare" dans le code contenu dans *SearchString,  ; et met à jour le tableau ListOfAllElements$() avec les positions des  ; mentions trouvées.  ;  Protected CompleteElementDeclaration$, PosInLine, mPosInLine  Protected ElementNameLCase$, ExistingElement, mExistingElement  Protected pnR, LineP$, DeclareLine, EFName$  ;  Repeat    PosInCode = FindString(*SearchString\s, "declare", PosInCode + 1)    If EndPos And PosInCode > EndPos : PosInCode = 0 : EndIf    ;    If PosInCode      CompleteElementDeclaration$ = ExtractSectionArroundExpression(*SearchString, "declare", PosInCode, #True)      PosInCode + 7      ; On vérifie que "declare" figure au début de la ligne :      If Left(CompleteElementDeclaration$, 7) = "declare"        ; Le nom de procédure doit être précédé d'un espace :        PosInLine = FindString(CompleteElementDeclaration$, " ", 7)        If PosInLine          mPosInLine = PosInLine + 1          ; Le nom de procédure doit être suivi d'un espace ou d'une parenthèse ouvrante :          PosInLine = FirstOccurrenceOfChar(CompleteElementDeclaration$, "( ", mPosInLine)          If PosInLine            ; Tout semble bon. On recherche la procédure dans la liste des éléments :            ElementNameLCase$ = FastMid(CompleteElementDeclaration$, mPosInLine, PosInLine - mPosInLine)            CheckIfElementExistsInList(ListOfAllElements$(#PBBProcedure), ElementNameLCase$, #PBBProcedure)            If ExistingElement              ; On extrait la ligne concernant la procédure :              pnR = FindString(ListOfAllElements$(#PBBProcedure), Chr(13), ExistingElement)              LineP$ = FastMid(ListOfAllElements$(#PBBProcedure), ExistingElement, pnR - ExistingElement)              DeclareLine = CountString(FastMid(*SearchString\s, 1, PosInCode), Chr(13)) + 1              LineP$ = InsertValueIntoListLine(LineP$, FileName$ + "/" + Str(DeclareLine), #EL_DeclarationDetails)              ;              ; On réintègre la ligne modifiée dans la liste des procédures :              ListOfAllElements$(#PBBProcedure) = FastLeft(ListOfAllElements$(#PBBProcedure), ExistingElement - 1) + LineP$ + FastMid(ListOfAllElements$(#PBBProcedure), pnR)              ;                ; L'information que nous venons d'ajouter à la liste sera exploitée par 'FillDetailREGadget'              ; qui fera figurer une mention 'Déclarée dans XXXXXXXX à la ligne XX' dans le descriptif              ; de la procédure.            EndIf          EndIf        EndIf      EndIf    EndIf  Until PosInCode = 0EndProcedure;Procedure EvaluateConstantesValue(EnumerationName$, SourceFile$, ElementStartingPos, ElementEndingPos)  ;  ; Cette procedure examine le code d'une énumération figurant dans  ; SourceFile$ aux positions ElementStartingPos et ElementEndingPos.  ;  ; Elle détaille les constantes qui y figurent et leur attribue une  ; valeur lorsque cela est possible.  ;  Protected *SearchString.String , ValConst, PosInEnum, mPosInEnum  Protected LineC$, ppv, pEqual, pVal$, pc, pcf  Protected ElementNameLCase$, ExistingElement, mExistingElement  Protected EF, LineCR$, pValR$, CompleteElementDeclaration$  Protected EFName$, pnR, LineE$  ;  ; On extrait le code correspondant à l'énumération.  *SearchString = GetPointedElementContentFromFile(SourceFile$, ElementStartingPos, ElementEndingPos, #False)  ;  ; On examine le code de l'énumération, ligne par ligne :  ValConst = -1  PosInEnum = FindString(*SearchString\s, Chr(13), 1)  Repeat    mPosInEnum = PosInEnum + 1    PosInEnum = FindString(*SearchString\s, Chr(13), PosInEnum + 1)    If PosInEnum      ; On récupère les déclarations de constantes qui figurent      ; dans l'énumération :      LineC$ = Trim(FastMid(*SearchString\s, mPosInEnum, PosInEnum - mPosInEnum))      If LCase(Left(Trim(LineC$), 14)) <> "endenumeration"        ; On enlève le commentaire éventuel.        ppv = FindString(LineC$, ";")        If ppv : LineC$ = FastLeft(LineC$, ppv - 1) : EndIf        LineC$ = Trim(LineC$)        ; On regarde si la constante se voit attribuer une valeur :        pEqual = FindString(LineC$, "=")        If pEqual          ; On regarde si l'on parvient à interpréter cette valeur :          pVal$ = Trim(Mid(LineC$, pEqual + 1))          ; On regarde si la valeur de la constante est calculée à partir          ; de la valeur d'autres constantes. Si c'est le cas, on essaye          ; de remplacer les noms de constantes par leurs valeurs.          pc = 0          Repeat            ; On cherche un nom de constante dans la définition de la valeur :            pc = FindString(pVal$, "#", pc + 1)            If pc              pcf = pc + 1              While FindString("+-*/() ", Mid(pVal$, pcf, 1)) = 0 And pcf <= Len(pVal$) : pcf + 1 : Wend              ElementNameLCase$ = LCase(FastMid(pVal$, pc, pcf - 1))              CheckIfElementExistsInList(ListOfAllElements$(#PBBConstante), ElementNameLCase$, #PBBConstante)              If ExistingElement                ; On a trouvé un nom de constante dans la définition de la valeur.                ; On va remplacer le nom de cette constante par sa valeur.                EF = FindString(ListOfAllElements$(#PBBConstante), Chr(13), ExistingElement)                LineCR$ = FastMid(ListOfAllElements$(#PBBConstante), ExistingElement, EF - ExistingElement)                pValR$ = StringField(LineCR$, #EL_Value, Chr(9))                If pValR$ And pValR$ <> "UnResolved"                  pVal$ = ReplaceString(pVal$, FastMid(pVal$, pc, pcf - 1), pValR$)                EndIf              EndIf            EndIf          Until pc = 0          ValConst = EvaluateExpression(pVal$)          If ValConst = 0 And FastLeft(pVal$, 1) <> "0"            ValConst = -123456789 ; Valeur non interprétable.          EndIf          LineC$ = Trim(FastLeft(LineC$, pEqual - 1))        ElseIf ValConst <> -123456789          ; Si une valeur interprétable a été trouvée dans les lignes          ; qui précèdent, on l'incrémente :          If FindString(CompleteElementDeclaration$, "EnumerationBinary")            If ValConst = -1              ValConst = 1            Else              ValConst * 2            EndIf          Else            ValConst + 1          EndIf        EndIf        ; On cherche la constante dans la liste des constantes :        ElementNameLCase$ = LCase(LineC$)        CheckIfElementExistsInList(ListOfAllElements$(#PBBConstante), ElementNameLCase$, #PBBConstante)        If ExistingElement          ; On extrait la ligne concernant la constante :          pnR = FindString(ListOfAllElements$(#PBBConstante), Chr(13), ExistingElement)          LineE$ = FastMid(ListOfAllElements$(#PBBConstante), ExistingElement, pnR - ExistingElement)          If ValConst <> -123456789            ; Si on a une valeur pour la constante, on l'enregistre dans le champs '#EL_Value'.            LineE$ = InsertValueIntoListLine(LineE$, Str(ValConst), #EL_Value)          Else            LineE$ = InsertValueIntoListLine(LineE$, "UnResolved", #EL_Value)          EndIf          ;          ; On enregistre le nom de l'énumération à laquelle la constante appartient :          LineE$ = InsertValueIntoListLine(LineE$, EnumerationName$, #EL_DeclarationDetails)          ;          ; On réintègre la ligne modifiée dans la liste des constantes :          ListOfAllElements$(#PBBConstante) = FastLeft(ListOfAllElements$(#PBBConstante), ExistingElement - 1) + LineE$ + FastMid(ListOfAllElements$(#PBBConstante), pnR)          ;            ; Les informations que nous venons d'ajouter à la liste sera exploitée par 'FillDetailREGadget'          ; qui fera figurer une mention donnant la valeur de la constante et l'énumération à laquelle          ; elle appartient, dans le descriptif de la constante.        EndIf      EndIf    EndIf  Until PosInEnum = 0EndProcedure;Procedure SetOneListOfAllElements(TypeOfElement, PriorityMode = #WorkInBackGround, OneFileOnly$ = "", *Limits.Point = 0)  ;  ; Cette procédure établit la liste complète des éléments  ; définis et contenus dans la liste de fichiers 'PBBListOfFiles$' et l'enregistre dans le tableau  ; ListOfAllElements$() sous la forme d'une suite de lignes structurées comme ceci :  ; 'Nom de l'élement (de la structure, de la procédure, etc.' + Chr(9)  ;       + 'Adresse du fichier' + Chr(9)  ;       + 'Déclaration complète de l'élement (avec arguments, s'il y en a)'  + Chr(9)  ;       + 'N° de ligne du début dans le fichier'  + Chr(9)  ;       + 'N° de ligne de la fin dans le fichier' + Chr(9)  ;       + 'Élément parent' +Chr(9) + Chr(13)  ;  ; CompleteListOfFiles doit avoir été appelée avant d'appeler cette procédure  ; afin que la variable globale PBBListOfFiles$ soit renseignées.  ;  ; Cette procédure est conçue pour pouvoir travailler en tâche de fond et s'interrompre au bout de 200 millisecondes,  ; mais elle ira jusqu'au bout de l'exploration si PriorityMode = '#FinishCompletionNow'.  ;  ; Si le paramètre 'OneFileOnly$' est renseigné, l'exploration sera limité au fichier dont  ; le nom figure dans ce paramètre. Cette option est utilisée pour les mises à jour partielles.  ;  ; Pour accomplir entièrement sa tâche, cette procédure est découpée en deux étapes distinctes  ; qui seront signalées dans le code :  ; • Étape 1 : On appelle à répétition 'CompleteListOfAllElements()' pour chaque fichier et pour  ;             pour chaque élément, jusqu'à avoir tout exploré.  ; • Étape 2 : On ré-examine les fichiers du code pour voir si les procédures font  ;             l'objet d'une mention 'Declare' avant leur définition.  ; • Étape 3 : Pour le cas particulier des constantes, nous allons regarder si elles  ;             sont déclarées à l'intérieur d'énumérations. Si c'est le cas, nous en  ;             déduirons la valeur qui leur est attribuée.  ;             Nous en profiterons pour mémoriser les noms des énumérations auxquelles  ;             les constantes appartiennent (lorsque c'est le cas). Plus tard, cela  ;             nous permettra de décider si une énumération est utilisée ou non.  ;             (on décidera que c'est le cas si l'une de ses constantes, au moins,  ;              est utilisée).  ; • Étape 4 : Pour le cas particulier des variables 'Shared', il faudra explorer  ;             le code 'hors-procédure'. Davantage d'explications figurent sous  ;             la mention 'Étape 4', ci dessous.  ;  Shared PBBLComment$  ;  Static PosInFileList, PosInEnumList, PosInVarList  ;  Protected LineC$, LineE$, FileName$, *SearchString.String, mPosInEnumList  Protected CLE_StartTime, PosInCode, EndPos, ElementName$, SourceFile$  Protected ElementStartingPos, ElementEndingPos, CompleteElementDeclaration$  Protected cont, PosInConstList, mPosInConstList, ElementNameLCase$  Protected EnumStartingPos, EnumEndingPos, mPosInVarList, OFileName$  Protected VariableSpecies$, VariableSubSpecies$, ElementStartingLine  Protected AddTypePos, AddTypeEndPos, pp, ReplaceDefinition  Protected *SearchStringCS.string, ElementEndingLine, EnumerationName$    Protected LineV$  ;  ;  If PBBListOfFiles$ = ""    SetListOfFiles(FileName$, #FinishCompletionNow) ; On recense tous les fichiers inclus dans 'FileName$'                                                   ; (ainsi que les fichiers inclus dans les fichiers inclus).  EndIf  ;  If PBBListOfFiles$ = ""    ; L'application a démarré sans aucun fichier à explorer.    ListCompletionAll(TypeOfElement) = #ListCompletion_Done  EndIf  ;  If ListCompletionAll(TypeOfElement) < #ListCompletion_Done ; Pas la peine de tout refaire si on l'a déjà fait.    ;    CLE_StartTime = ElapsedMilliseconds()    ;    ; ---------------------------------------    ;                Étape 1    ; ---------------------------------------    ;    ; On complète les listes.    ;    If ListCompletionAll(TypeOfElement) < #ListCompletion_StageCompleted      If ListCompletionAll(TypeOfElement) = #ListCompletion_Undone        ; On démarre ou on redémarre à zéro. Il faut initialiser certaines choses :        PosInFileList = 0        PosInEnumList = 0        ListOfAllElements$(TypeOfElement) = ""        ListCompletionReference$(TypeOfElement) = ""      EndIf      ;      Repeat        If OneFileOnly$          CompleteListOfAllElements(OneFileOnly$, TypeOfElement, PriorityMode, CLE_StartTime, *Limits)          FileName$ = ""        ElseIf ListCompletionAll(TypeOfElement) = #ListCompletion_Pending          ; Puisque nous sommes en 'Pending' (poursuite d'une exploration déjà commencée),          ; CompleteListOfAllElements() a mémorisé le nom du fichier en cours d'examen et          ; il est inutile de le lui renvoyer.          ; Nous faisons donc appel à cette procédure avec le premier paramètre vide :          CompleteListOfAllElements("", TypeOfElement, PriorityMode, CLE_StartTime)          FileName$ = "Loop" ; La valeur "Loop" est un leurre pour que la boucle se poursuive.        ElseIf ListCompletionAll(TypeOfElement) = #ListCompletion_Undone Or ListCompletionAll(TypeOfElement) = #ListCompletion_StageCompleted          PosInFileList + 1          LineC$ = StringField(PBBListOfFiles$, PosInFileList, Chr(13))          If LineC$            FileName$ = StringField(LineC$, 1, Chr(9))            CompleteListOfAllElements(FileName$, TypeOfElement, PriorityMode, CLE_StartTime)          Else            FileName$ = ""          EndIf        EndIf      Until FileName$ = "" Or (ListCompletionAll(TypeOfElement) = #ListCompletion_Pending)      ;      If FileName$ = ""        If TypeOfElement = #PBBVariable          ; Comme on ne passe par ici qu'une seule fois,          ; on initialise les variables qui seront nécessaire à l'accomplissement          ; de l'étape 4 qui figure ci-dessous :          PosInVarList = 0        ElseIf TypeOfElement = #PBBProcedure          ; Pour l'étape 2          PosInFileList = 0        EndIf      EndIf    EndIf    ;    ;    If ListCompletionAll(TypeOfElement) = #ListCompletion_StageCompleted      ;      If TypeOfElement = #PBBProcedure        ; ---------------------------------------        ;                Étape 2        ; ---------------------------------------        ;        ; Pour compléter les informations disponibles à propos des        ; procédures, nous allons regarder si elles font l'objet        ; d'une mention 'Declare', quelque part dans le code.        ;        ; On va parcourir la liste des fichiers pour y rechercher les mentions 'Declare' :        ;        If OneFileOnly$          *SearchString = GetPointedCodeFromFile(OneFileOnly$, #True)          If *Limits            PosInCode = *Limits\x            EndPos    = *Limits\y          Else            PosInCode = 0            EndPos    = 0          EndIf          SetDeclarePositionsForProc(OneFileOnly$, *SearchString.String, PosInCode, EndPos)        Else          Repeat            PosInFileList + 1            ; On extrait une ligne de la liste des fichiers :            LineC$ = StringField(PBBListOfFiles$, PosInFileList, Chr(13))            If LineC$              FileName$ = StringField(LineC$, 1, Chr(9))              *SearchString = GetPointedCodeFromFile(FileName$, #True)              PosInCode = 0              SetDeclarePositionsForProc(FileName$, *SearchString)            EndIf          Until LineC$ = "" Or ((ElapsedMilliseconds() - CLE_StartTime > 200) And PriorityMode <> #FinishCompletionNow)          ;          If LineC$            ProcedureReturn #Completion_Uncomplete          EndIf        EndIf         ;      ElseIf TypeOfElement = #PBBConstante        ; ---------------------------------------        ;                Étape 3        ; ---------------------------------------        ;        ; Pour le cas particulier des constantes, nous allons regarder si elles        ; sont déclarées à l'intérieur d'énumérations. Si c'est le cas, nous en        ; déduirons la valeur qui leur est attribuée.        ;        ; On parcourt toutes les énumérations identifiées au cours        ; de l'exploration :        ;        Repeat          mPosInEnumList = PosInEnumList + 1          PosInEnumList = FindString(ListOfAllElements$(#PBBEnumeration), Chr(13), PosInEnumList + 1)          If PosInEnumList            ; On extrait une ligne de la liste des énumérations :            LineE$ = FastMid(ListOfAllElements$(#PBBEnumeration), mPosInEnumList, PosInEnumList - mPosInEnumList)            ElementName$                = StringField(LineE$, #EL_ElementName, Chr(9))            SourceFile$                 = StringField(LineE$, #EL_FileName, Chr(9))            ElementStartingPos          = Val(StringField(LineE$, #EL_StartingPos, Chr(9)))            ElementEndingPos            = Val(StringField(LineE$, #EL_EndingPos, Chr(9)))            CompleteElementDeclaration$ = StringField(LineE$, #EL_CompleteElementDeclaration, Chr(9))            ;            cont = 0            If OneFileOnly$              If OneFileOnly$ = SourceFile$                If *Limits                  If (ElementStartingPos >= *Limits\x And ElementStartingPos <= *Limits\y) Or (ElementEndingPos >= *Limits\x And ElementEndingPos <= *Limits\y) Or (*Limits\x >= ElementStartingPos And *Limits\x <= ElementEndingPos)                    cont = 1                  EndIf                Else                  cont = 1                EndIf              EndIf            Else              cont = 1            EndIf            ;            If cont              EvaluateConstantesValue(ElementName$, SourceFile$, ElementStartingPos, ElementEndingPos)            EndIf          EndIf        Until PosInEnumList = 0 Or ((ElapsedMilliseconds() - CLE_StartTime > 200) And PriorityMode <> #FinishCompletionNow)        ;        If PosInEnumList          ProcedureReturn #Completion_Uncomplete        EndIf        ;        If OneFileOnly$          ; Dans le cas où nous sommes en train de faire une mise à jour partielle des données,          ; nous venons de vérifier si la partie de code modifiée comportait des énumérations          ; et s'il fallait mettre à jour leurs constantes.          ; Cette vérification étant partielle, nous n'avons cependant pas encore regardé          ; si la partie de code modifiée comportait des constantes dont la valeur est          ; fixée dans une énumération figurant hors de la zone modifiée.          ; Nous allons donc le faire :          ;          PosInConstList = 0          Repeat            mPosInConstList = PosInConstList + 1            PosInConstList = FindString(ListOfAllElements$(#PBBConstante), Chr(13), PosInConstList + 1)            If PosInConstList              ; On extrait une ligne de la liste des constantes :              LineC$ = FastMid(ListOfAllElements$(#PBBConstante), mPosInConstList, PosInConstList - mPosInConstList)              ElementNameLCase$           = StringField(LineC$, #EL_ElementNameLCase, Chr(9))              SourceFile$                 = StringField(LineC$, #EL_FileName, Chr(9))              ElementStartingPos          = Val(StringField(LineC$, #EL_StartingPos, Chr(9)))              ElementEndingPos            = Val(StringField(LineC$, #EL_EndingPos, Chr(9)))              ;              cont = 0              If OneFileOnly$ = SourceFile$                If *Limits                  If (ElementStartingPos >= *Limits\x And ElementStartingPos <= *Limits\y) Or (ElementEndingPos >= *Limits\x And ElementEndingPos <= *Limits\y) Or (*Limits\x >= ElementStartingPos And *Limits\x <= ElementEndingPos)                    cont = 1                  EndIf                Else                  cont = 1                EndIf              EndIf              ;              If cont                ; La constante figure dans la partie modifiée du fichier 'OneFileOnly$'.                ; On va chercher si elle figure dans une énumération :                PosInEnumList = 0                Repeat                  mPosInEnumList = PosInEnumList + 1                  PosInEnumList = FindString(ListOfAllElements$(#PBBEnumeration), Chr(13), PosInEnumList + 1)                  If PosInEnumList                    ; On extrait une ligne de la liste des énumérations :                    LineE$ = FastMid(ListOfAllElements$(#PBBEnumeration), mPosInEnumList, PosInEnumList - mPosInEnumList)                    EnumerationName$         = StringField(LineE$, #EL_ElementName, Chr(9))                    SourceFile$              = StringField(LineE$, #EL_FileName, Chr(9))                    EnumStartingPos          = Val(StringField(LineE$, #EL_StartingPos, Chr(9)))                    EnumEndingPos            = Val(StringField(LineE$, #EL_EndingPos, Chr(9)))                    *SearchString = GetPointedElementContentFromFile(SourceFile$, EnumStartingPos, EnumEndingPos, #True)                    ;                    If FindInPBPointedCode(*SearchString, ElementNameLCase$)                      EvaluateConstantesValue(EnumerationName$, SourceFile$, EnumStartingPos, EnumEndingPos)                    EndIf                  EndIf                Until PosInEnumList = 0              EndIf            EndIf          Until PosInConstList = 0        ;        EndIf        ;      ElseIf TypeOfElement = #PBBVariable        ;        ; ---------------------------------------------------        ;                       Étape 4        ; ---------------------------------------------------        ;        ; Pour le cas particulier des variables, il nous faut résoudre un problème        ; qui leur est propre : les variables 'Shared' peuvent avoir été définies        ; dans le code principal avant d'être déclarées comme 'Shared' par une ou        ; plusieurs procédures.        ;        ; L'exploration qui vient d'avoir lieu et qui a recensée les variables        ; 'Shared', ne s'est basée que sur les informations figurant à l'intérieur        ; des procédures et macro. Il est donc possible que le type de ces variables        ; (array, list ou structured) n'ait pas encore pu être établi.        ;        ; Voici un exemple de programme où il est impossible de connaître le type        ; de 'MyString' sans le chercher en dehors des procédures :        ;        ;               MyString.string\s = "This is a test"        ;               Procedure test()        ;                 Shared MyString  ; Le type de 'MyString' n'est pas indiqué ici.        ;                 Debug MyString\s ; Pourtant, ce programme fonctionne.        ;               EndProcedure        ;               test()        ;        ; Pour être sûr de récupérer le type des variables 'Shared', il nous faut        ; donc ré-examiner le code pour voir s'il contient des informations        ; qui nous permettrons de compléter notre liste.        ;        Repeat          mPosInVarList = PosInVarList + 1          PosInVarList = FindString(ListOfAllElements$(#PBBVariable), Chr(13), PosInVarList + 1)          If PosInVarList            ; On extrait une ligne de la liste des variables :            LineV$ = FastMid(ListOfAllElements$(#PBBVariable), mPosInVarList, PosInVarList - mPosInVarList)            ElementName$        = StringField(LineV$, #EL_ElementName, Chr(9))            ElementNameLCase$   = StringField(LineV$, #EL_ElementNameLCase, Chr(9))            OFileName$          = StringField(LineV$, #EL_FileName, Chr(9))            VariableSpecies$    = StringField(LineV$, #EL_VariableSpecies, Chr(9))            ElementStartingPos  = Val(StringField(LineV$, #EL_StartingPos, Chr(9)))            ElementStartingLine = Val(StringField(LineV$, #EL_StartingLine, Chr(9)))            ;            ; On regarde si les informations sur la variable sont susceptibles d'être complétées :            ;            If Left(VariableSpecies$, 6) = "Shared" And (FindString(ElementName$, ".") = 0 Or FindString(VariableSpecies$, " Var"))              ; La ligne qui déclarait la variable en 'Shared' ne spécifiait pas forcément le type              ; de la variable (s'il s'agit d'une variable structurée) ni le fait qu'il s'agit peut-être              ; d'un tableau ou d'une liste. Ce sont ces information que nous allons chercher              ; dans le début du code.                            ; On va parcourir la liste des fichiers pour y rechercher la variable :              ;              PosInFileList = 0              Repeat                PosInFileList + 1                ; On extrait une ligne de la liste des fichiers :                LineC$ = StringField(PBBListOfFiles$, PosInFileList, Chr(13))                If LineC$                  FileName$ = StringField(LineC$, 1, Chr(9))                  *SearchString = GetPointedCodeFromFile(FileName$, #True)                  ; En toute logique, c'est la toute première fois que la variable                  ; sera citée dans le code qu'elle sera définie de la façon                  ; la plus complète possible. On ne procède donc qu'à une seule                  ; recherche à l'intérieur de chacun des fichiers :                  PosInCode = FindInPBPointedCode(*SearchString, ElementNameLCase$, 1, #CheckAll | #CheckOneKeyWordOnly)                  ;                  ; On ne continue que si on a trouvé la variable dans un fichier différent de celui où                  ; on l'avait précédemment repérée, ou bien à une position antérieure dans le code :                  If PosInCode And (OFileName$ <> FileName$ Or PosInCode < ElementStartingPos)                    CompleteElementDeclaration$ = ExtractSectionArroundExpression(*SearchString, ElementNameLCase$, PosInCode, #True)                    ;                    ReplaceDefinition = 0                    ;                    AddTypePos = 0                    AddTypeEndPos = 0                    If FindString(ElementNameLCase$, ".") = 0                      pp = PosInCode + Len(ElementNameLCase$)                      If FastMid(*SearchString\s, pp, 1) = "."                        ; Nous avons trouvé une définition de type que notre variable n'avait pas.                        ReplaceDefinition = 1                      ElseIf Left(CompleteElementDeclaration$, 7) = "define."                        AddTypePos = 8                        AddTypeEndPos = AddTypePos                        While AddTypeEndPos <= Len(CompleteElementDeclaration$) And FindString(ListPBSep$, PeekS(@CompleteElementDeclaration$ + (AddTypeEndPos - 1) * SizeOf(CHARACTER), 1)) = 0                          AddTypeEndPos + 1                        Wend                        ReplaceDefinition = 1                      EndIf                    EndIf                    If Left(CompleteElementDeclaration$, 3) = "dim"                      VariableSubSpecies$ = "Array"                      ReplaceDefinition = 1                    ElseIf Left(CompleteElementDeclaration$, 7) = "newlist"                      VariableSubSpecies$ = "List"                      ReplaceDefinition = 1                    Else                      VariableSubSpecies$ = "Var"                    EndIf                    ;                    If ReplaceDefinition                      pp = PosInCode + Len(ElementNameLCase$)                      While FindString(",:=\(" + Chr(13), FastMid(*SearchString\s, pp, 1)) = 0 : pp + 1 : Wend                      ;                      ; La recherche a été menée sur le code en version LCase.                      ; On récupère la version avec majuscules :                      *SearchStringCS.string = GetPointedCodeFromFile(FileName$)                      ElementName$ = Trim(FastMid(*SearchStringCS\s, PosInCode, pp - PosInCode))                      ;                      ElementStartingLine = CountString(FastMid(*SearchString\s, 1, PosInCode), Chr(13)) + 1                      ElementEndingLine = ElementStartingLine                      ; On refait une recherche portant sur la déclaration en entier, (et pas seulement                      ; sur le nom de la variable) pour déterminer où elle se situe dans le code, afin                      ; d'obtenir ElementStartingPos et ElementEndingPos.                      ElementStartingPos = FindInPBPointedCode(*SearchString, CompleteElementDeclaration$, 1, #CheckAll | #CheckOneKeyWordOnly)                      ElementEndingPos = ElementStartingPos + Len(CompleteElementDeclaration$)                      ; Et on récupère sa copie avec les majuscules :                      CompleteElementDeclaration$ = Trim(FastMid(*SearchStringCS\s, ElementStartingPos, Len(CompleteElementDeclaration$)))                      ; Si on est tombé sur 'Define', on ajoute le type donné par 'Define' :                      If AddTypePos And FindString(ElementName$, ".") = 0                        ElementName$ + "." + FastMid(CompleteElementDeclaration$, AddTypePos, AddTypeEndPos - AddTypePos)                      EndIf                                            RecordElementInList(#PBBVariable, ElementName$, FileName$, CompleteElementDeclaration$, ElementStartingLine, ElementEndingLine, ElementStartingPos, ElementEndingPos, "Shared " + VariableSubSpecies$, PBBLComment$, mPosInVarList)                    EndIf                  EndIf                EndIf              Until LineC$ = ""            EndIf          EndIf        Until PosInVarList = 0 Or ((ElapsedMilliseconds() - CLE_StartTime > 200) And PriorityMode <> #FinishCompletionNow)        ;        If PosInVarList          ProcedureReturn #Completion_Uncomplete        EndIf        ;              EndIf      ;      ; L'exploration est terminée pour cet élément.      ListCompletionAll(TypeOfElement) = #ListCompletion_Done      If ListOfAllElements$(TypeOfElement) = ""        ListOfAllElements$(TypeOfElement) = "No " + PBBTypeNames$(TypeOfElement)      EndIf      ProcedureReturn #Completion_Completed      ;    Else      ; L'exploration est inachevée.      ProcedureReturn #Completion_Uncomplete    EndIf    ;  EndIf  ProcedureReturn #Completion_CompletedEndProcedure;Procedure SetAllListsOfAllElements(PriorityMode = #WorkInBackGround, OneFileOnly$ = "", *Limits = 0)  ;  ; Cette parcourt toutes les listes d'élements et complète celles  ; qui ne sont pas encore complétées.  ;  ; Cette procédure est conçue pour pouvoir travailler en tâche de fond  ; et s'interrompre au bout de 200 millisecondes,mais elle ira jusqu'au  ; bout de l'exploration si PriorityMode = '#FinishCompletionNow'.  ;  Protected TypeOfElement  ;  For TypeOfElement = 0 To (#EndEnumPBBElementTypes - 1)    If OneFileOnly$      ListCompletionAll(TypeOfElement) = #ListCompletion_Pending    EndIf    If ListCompletionAll(TypeOfElement) < #ListCompletion_Done      If SetOneListOfAllElements(TypeOfElement, PriorityMode, OneFileOnly$, *Limits) = #Completion_Uncomplete        ProcedureReturn #Completion_Uncomplete      EndIf    EndIf  Next  ProcedureReturn #Completion_CompletedEndProcedure;Procedure.s MemorizeRefAndPos(RefList$, RefElement, plu)  ;  ; Cette procédure est exclusivement appelée par 'CompleteListOfUsedElements()'  ;  ; Elle mémorise le RefElement et la position d'interruption  ; dans une chaîne de caractère comportant déjà (éventuellement)  ; d'autre couples du même genre.  ;  Protected nl, RefLine$, replace  Protected nRef$ ; Valeur de retour.  ;  nl = 0  nRef$ = ""  replace = 0  Repeat    nl + 1    RefLine$ = StringField(RefList$, nl, Chr(13))    If RefLine$      If Val(StringField(RefLine$, 1, Chr(9))) = RefElement        nRef$ + Str(RefElement) + Chr(9) + Str(plu) + Chr(13)        replace = 1      Else        nRef$ + RefLine$ + Chr(13)      EndIf    EndIf  Until RefLine$ = ""  If replace = 0    nRef$ + Str(RefElement) + Chr(9) + Str(plu) + Chr(13)  EndIf  ProcedureReturn nRef$EndProcedure;Procedure GetStartingPosForThisRefType(RefElement, TypeOfElement)  ;  ; Cette procédure n'est appelée que par 'CompleteListOfUsedelements()'.  ; Elle va récupérer la dernière position où l'exploration s'était interrompue  ; pour le même élément de référence (RefElement).  ;  Protected nl = 0, RefLine$  Protected PosInRefElementsList = 0 ; Valeur de retour.  ;  Repeat    nl + 1    RefLine$ = StringField(ListCompletionReference$(TypeOfElement), nl, Chr(13))    If RefLine$      If RefElement = Val(StringField(RefLine$, 1, Chr(9)))        PosInRefElementsList = Val(StringField(RefLine$, 2, Chr(9)))        Break      EndIf    EndIf  Until RefLine$ = ""  ProcedureReturn PosInRefElementsListEndProcedure;Procedure FindElementInCode(*SearchString.String, LineE$, TypeOfElement)  ;  ; Recherche dans le code contenu dans *SearchString si l'élément  ; défini par LineE$ y figure.  ; *SearchString doit être en version LCase.  ;  Protected ElementName$, ElementNameLCase$, CompleteElementDeclaration$  Protected PosInCode, ExtractLine$, pf, SStrLength, pEqual, AttribConstName$  Protected ExistingElement, mExistingElement, EFName$  ;  ; On vérifie si l'élément a déjà été recensé comme utilisé (inutile de continuer si c'est le cas).  If StringField(LineE$, #EL_Parent, Chr(9)) = ""    ;    ElementName$ = StringField(LineE$, #EL_ElementName, Chr(9))    ElementNameLCase$ = PurifyElementName(ElementName$)    CompleteElementDeclaration$ = StringField(LineE$, #EL_CompleteElementDeclaration, Chr(9))    ;    PosInCode = 0    CLOU_SearchElementAgain:     PosInCode = FindString(*SearchString\s, ElementNameLCase$, PosInCode + 1)    If PosInCode      ; On extrait la portion de code contenant ElementName$ et on vérifie      ; du même coup que l'expression est encadrée de séparateurs corrects      ; et qu'elle ne figure pas dans des guillemets ou en commentaire :      ExtractLine$ = ExtractSectionArroundExpression(*SearchString, ElementNameLCase$, PosInCode, #False, #CheckAll)      If ExtractLine$ = "" Or ExtractLine$ = LCase(CompleteElementDeclaration$)        ; Les séparateurs ne sont pas corrects ou l'expression n'est pas        ; dans le code. Ou bien, si ExtractLine$ = CompleteElementDeclaration$,        ; nous sommes tombés sur la déclaration de l'élément, ce qui ne nous        ; intéresse pas ici : nous cherchons à savoir s'il est utilisé dans        ; une équation ou par un autre élément.        ; On cherche la prochaine occurrence.        Goto CLOU_SearchElementAgain      EndIf    EndIf    ;    If PosInCode      ;      ; ElementNameLCase$ a été trouvé dans le code contenu par *SearchString\s.      ;      ; On procède à des vérifications additionnelles :      ;      SStrLength = Len(*SearchString\s)      ;      If TypeOfElement = #PBBProcedure        ; Pour les procédures, on vérifie que le nom de la procédure        ; est bien suivi d'une parenthèse ouvrante.        pf = PosInCode + Len(ElementNameLCase$)        ; On saute les espaces qui suivent :        While pf <= SStrLength And PeekC(@*SearchString\s + (pf - 1) * SizeOf(CHARACTER)) = 32 : pf + 1 : Wend        If pf >= SStrLength Or FastMid(*SearchString\s, pf, 1) <> "("          Goto CLOU_SearchElementAgain        EndIf      ElseIf TypeOfElement = #PBBStructure        ; Pour les structures, on vérifie que le nom de la structure        ; est bien précédé d'un backslash ou d'un point.        If PosInCode > 1 And PosInCode <= SStrLength And FastMid(*SearchString\s, PosInCode - 1, 1) <> "\" And FastMid(*SearchString\s, PosInCode - 1, 1) <> "."          Goto CLOU_SearchElementAgain        EndIf      ElseIf TypeOfElement = #PBBConstante         ; Pour les constantes, on cherche le signe "=" qui précède :        pEqual = FindString(ExtractLine$, "=", 1, 0)        If pEqual And FastLeft(ExtractLine$, 1) = "#"          ; Nous sommes dans le cas particulier d'une constante (ElementNameLCase$) qui est utilisée          ; pour définir la valeur d'une autre constante (pAttribConst).          ; Dans ce cas, pour décider si la constante ElementNameLCase$ est réellement utilisée,          ; il faut savoir savoir si pAttribConst est elle-même utilisée.          AttribConstName$ = LCase(Trim(FastMid(ExtractLine$, 1, pEqual - 1)))          CheckIfElementExistsInList(ListOfUsedElements$(#PBBConstante), AttribConstName$, #PBBConstante)          If ExistingElement = 0            ; ElementNameLCase$+" dépend de "+AttribConstName$+", mais "+AttribConstName$+" n'est pas utilisée."            Goto CLOU_SearchElementAgain          EndIf        EndIf      ElseIf TypeOfElement = #PBBLabel        pf = PosInCode + Len(ElementNameLCase$)        If Mid(*SearchString\s, pf, 1) = ":"          ; Nous sommes tombés sur la déclaration du label.          ; Ce n'est pas ce que nous cherchons.          Goto CLOU_SearchElementAgain        EndIf      EndIf    EndIf  Else    PosInCode = 0  EndIf  ProcedureReturn PosInCodeEndProcedure;Procedure CompleteListOfUsedElements(TypeOfElement, PriorityMode = #WorkInBackGround, RefElement = #PBBProcedure, ListPos$ = "")  ; Cette procédure va parcourir la liste des éléments utilisés (tableau ListOfUsedElements$(RefElement))  ; ainsi que tout le code situé hors-éléments, pour l'ensemble des fichiers listés par SetListOfFile().  ;  ; À chaque fois que l'élément sera cité dans ce corpus de recherche, il sera noté comme utilisé  ; et ajouté à ListOfUsedElements$(TypeOfElement) sous la forme proposée  ; par l'énumération 'StructureOfElementsLists' :  ; 'Nom de l'élément (de la structure, de la procédure, etc.)' + Chr(9)  ;       + 'Adresse du fichier contenant l'élément' + Chr(9)  ;       + 'Déclaration complète de l'élement (avec arguments, s'il y en a)'  + Chr(9)  ;       + 'N° de ligne du début dans le fichier'  + Chr(9)  ;       + 'N° de ligne de la fin dans le fichier' + Chr(9)  ;       + 'Élément parent' +Chr(9)  ;       + 'Énumération définissant la constante' +Chr(9)    (pour les constantes seulement)  ;       + 'Valeur de la constante' +Chr(9)                  (pour les constantes seulement)  ;       + 'Commentaire de l'élément' +Chr(9)                (si la déclaration est assortie d'un commentaire)  ;       + Chr(13)  ;  ; Cette procédure est conçue pour pouvoir tourner en tâche de fond  ; et s'interrompre au bout de 200 millisecondes écoulées depuis 'CLE_StartTime'.   ; Si 'PriorityMode' a une valeur différente de '#WorkInBackGround', une fenêtre d'attente sera affichée  ; pendant son exécution.  ;  ; Cette procédure n'est appelée que par 'ExecuteSerialCompletionsForUsedElements()' qui n'est elle-même  ; appelée que par 'SetAllListsOfUsedElements()'. Alors, bien sûr, il serait possible de regrouper ces  ; trois procédures en une seule, mais comme elles sont assez longues, les choses m'ont semblées plus  ; claires en les séparant.  ;  ; Pour que les recherches soit faites sans tenir compte de la casse (puisque PureBasic y est insensible  ; et qu'il est techniquement possible de saisir des noms de procédures, macros, structure, etc. sans  ; respecter toujours la même casse), cette procédure va se baser sur la version 'LCase()' des fichiers  ; examinés. Cette version est générée par la procédure 'GetCodeFromFile()' qui peut délivrer une version  ; préservant la casse si son deuxième paramètre est '#False' ou tout en minuscule, si son deuxième paramètre  ; est '#True'.  ; Les procédures SetAllListsOfAllElements(), SetOneListOfAllElement() et CompleteListOfAllElements()  ; utilisent les versions 'CaseSafe' des fichiers, afin que toutes les déclarations d'éléments récupérées  ; affichent une bonne présentation dans les listes, et dans le panneau 'Détails'.  ; La présente procédure, par contre, utilise la version LCase() de ces mêmes fichiers, afin de pouvoir  ; effectuer des recherches FindString() rapides, ne nécessitant pas le paramètre '#PB_String_NoCase'.  ; Pour information : Une recherche FindString(MyString$, ToSearch$, StartPos, #PB_String_NoCase) est  ; en moyenne huit fois plus lente qu'une recherche FindString(MyString$, ToSearch$, StartPos)  ;  ; En résumé : CompleteListOfAllElements()  examine les fichiers d'origine.  ;             CompleteListOfUsedElements() examine une version des fichiers en minuscules.  ;  Global ObsoleteCode = 0  ;  Static mRefElement, mPosInRefElementsList, mParent$ ; Dernier élément de référence avec lequel on a travaillé,                                                      ; et dernière position dans la liste des éléments de référence.  Static mTypeOfElement          ; Dernier type d'élément sur lequel on a travaillé.  Static PBBTypeTranslated$      ; On mémorise le nom du type d'élément pour ne pas avoir                                 ;       à le rechercher et à le retraduire à chaque fois.  Static *SearchString.string    ; Code en cours d'examen.  ;  Static PosInElementList        ; Position courante dans la liste des éléments 'TypeOfElement'.  ;  Protected mPosInElementList    ; Position précédente dans la liste des éléments 'TypeOfElement'.  Protected LineE$               ; Ligne de la liste 'TypeOfElement' en cours d'examen.  ;  Protected PosInRefElementsList ; Position courante dans la liste des élément de référence.  Protected RefElementListLine$  ; Ligne de l'élément de référence en cours d'examen.  Protected SearchStringMem.String  ;  Protected SourceFile$          ; Fichier source du code en cours d'examen.  Protected ElementStartingPos, ElementEndingPos ; Infos sur l'élément en cours d'examen.  ;  Protected PosInCode, pf        ; Positions dans la portion de code en cours d'examen.  ;  ; Autres variables :  Protected tx$, plp, plpf, Parent$, PosFileName, OFileName$, *SourceCode.String  Protected pd, Extract$, RealPosInCode, mLenLineP, CLE_StartTime  ;  ;  If ListCompletionAll(TypeOfElement) < #ListCompletion_Done    ; On s'assure que tous les éléments ont déjà été inventoriés,    ; et si cela n'a pas déjà été fait, on le fait en mode prioritaire.    SetOneListOfAllElements(TypeOfElement, #FinishCompletionNow)  EndIf  ;  PosInRefElementsList = 0  ;  ; On regarde si nous sommes en cours de travail (en tâche de fond)  ; où si nous commençons l'examen à zéro pour cet élément.  ; La valeur qui figure dans ListCompletionUsed() détermine  ; l'échantillon des éléments de référence (les codes qui seront  ; examinés pour voir si l'élément est utilisé ou non).  ;  Select ListCompletionUsed(TypeOfElement)    Case #ListCompletion_RebootFromTabRef      ; Nous sommes en mise à jour partielle et nous n'examinons qu'une partie      ; des éléments de références. Les positions de départ sont enregistrées      ; dans ListCompletionReference$(). Nous les récupérons à l'aide de la      ; procédure GetStartingPosForThisRefType() :      PosInRefElementsList = GetStartingPosForThisRefType(RefElement, TypeOfElement)      ;    Case #ListCompletion_Pending, #ListCompletion_DoublePending, #ListCompletion_StageCompleted      ; Nous sommes en cours d'examen (à cause des interruptions toutes les      ; 200 ms).      If mTypeOfElement = TypeOfElement And mRefElement = RefElement        ; Rien n'a changé depuis le dernier passage.        ; On se contente de reprendre là où on s'était arrêté :        PosInRefElementsList = mPosInRefElementsList      Else        ; Le type d'élément a examiné à changé, ou bien l'élément de référence        ; a changé.        ; On va récupérer la dernière position où l'exploration s'était interrompue        ; pour le même élément principal et le même élément de référence (RefElement).        PosInRefElementsList = GetStartingPosForThisRefType(RefElement, TypeOfElement)      EndIf    Case #ListCompletion_Undone, #ListCompletion_ExamAll      ; Il faut examiner tous les éléments de référence, en partant du code      ; hors-élément.      ; On passera par ici dans les cas suivants :      ; • Lors du démarrage du programme;      ; • Lors d'une réinitialisation des listes (après un clic sur le bouton situé      ;   à gauche de "Statistiques");      ; • Au début d'une mise à jour partielle des listes (en cas de modification      ;   de l'un des fichiers du code source). ListCompletionUsed(TypeOfElement) = #ListCompletion_ExamAll;      ; • Lors du redémarrage de l'exploration profonde, à la suite d'une mise à jour      ;   partielle des listes, si l'exploration n'était pas terminée avant la mise      ;   à jour (on redémarre alors à zéro pour cet élément).      ;      ; On initialise ce qui doit l'être :      ;      ; Pour tous les éléments, il faut commencer par examiner le code 'hors-éléments',      ; et c'est ce qui va se passer si on démarre à -1.      PosInRefElementsList = -1      ;      If ListCompletionUsed(TypeOfElement) = #ListCompletion_Undone        ;        ; Nous sommes dans le cas d'un reset complet des listes.        ListOfUsedElements$(TypeOfElement) = ""        ListCompletionStepsCompleted(TypeOfElement) = 1      EndIf      ;      ListCompletionReference$(TypeOfElement) = ""      *SearchString = 0  EndSelect  ;  CLE_StartTime = ElapsedMilliseconds()  ;  If mTypeOfElement <> TypeOfElement Or PBBTypeTranslated$ = ""    PBBTypeTranslated$ = GetTextFromCatalog(PBBTypeNames$(TypeOfElement) + "s")    mTypeOfElement = TypeOfElement  EndIf  ;  Repeat    If ListCompletionUsed(TypeOfElement) <> #ListCompletion_DoublePending      *SearchString = 0      If PosInRefElementsList = -1        ; On commence par examiner le code hors-éléments, ensuite on examinera        ; le code de chaque élément.        *SearchString = @OutOfElementContent        ; OutOfElementContent\s est une compilation de tous les fichiers débarrassés        ; des procédures, structures, macros, et autres éléments de type Element->EndElement.        ; OutOfElementContent\s est en version 'LCase'.        ;        PosInRefElementsList = 0        mPosInRefElementsList = -1        mParent$ = #OutOfElementsName + "/"      Else        ; Nous allons maintenant parcourir les codes des procédures, macros ou structures utilisées        ; et regarder si l'une d'elles fait usage de l'un des éléments.        ;        ; Par exemple : pour compléter la liste des procédures, nous allons        ; examiner le code des macros pour voir s'il y a des appels de        ; procédure.        ; C'est 'RefElement' qui défini l'élément de référence dont nous allons        ; examiner le code.        ;        If PosInRefElementsList And FastMid(ListOfUsedElements$(RefElement), PosInRefElementsList, 1) <> Chr(13)          ; Cela ne peut, en principe, pas arriver.          ; Ce qui suit est destiné au debogage :          tx$ = "Program error in 'CompleteListOfUsedElement()': PosInRefElementsList is not pointing to an element in ListOfUsedElements$()." + Chr(13)          tx$ + "PosInRefElementsList = " + Str(PosInRefElementsList) + Chr(13)          tx$ + "Len(ListOfUsedElements$(RefElement)) = " + Str(Len(ListOfUsedElements$(RefElement))) + Chr(13)          tx$ + "Char under position is:" + Str(Asc(FastMid(ListOfUsedElements$(RefElement), PosInRefElementsList, 1)))          tx$ + "Text at position is :" + FastMid(ListOfUsedElements$(RefElement), PosInRefElementsList, 30)        EndIf        ;        mPosInRefElementsList = PosInRefElementsList + 1        ;        If TypeOfElement = #PBBEnumeration And RefElement = #PBBConstante          ; Nous sommes dans le cas où l'on cherche à savoir si l'une des constantes          ; d'une énumération est utilisée, afin de décider si l'énumération est utilisée.          ; Comme toutes les constantes n'appartiennent pas forcément à une énumération,          ; nous devons gérer ce cas particulier afin que *SearchString\s contienne toujours          ; quelque chose tant que l'exploration n'est pas terminée.          SearchStringMem\s = ""          Repeat            PosInRefElementsList = FindString(ListOfUsedElements$(RefElement), Chr(13), mPosInRefElementsList)            If PosInRefElementsList              RefElementListLine$ = FastMid(ListOfUsedElements$(RefElement), mPosInRefElementsList, PosInRefElementsList - mPosInRefElementsList)              SearchStringMem\s = LCase(StringField(RefElementListLine$, #EL_DeclarationDetails, Chr(9)))              If SearchStringMem\s                mParent$ = StringField(RefElementListLine$, #EL_ElementName, Chr(9)) + "/" + Str(RefElement) + "/" + StringField(RefElementListLine$, #EL_FileName, Chr(9)) + "/" + StringField(RefElementListLine$, #EL_StartingLine, Chr(9))              Else                mPosInRefElementsList = PosInRefElementsList + 1              EndIf            Else              SearchStringMem\s = ""            EndIf          Until PosInRefElementsList = 0 Or SearchStringMem\s          *SearchString = SearchStringMem        Else          ;          PosInRefElementsList = FindString(ListOfUsedElements$(RefElement), Chr(13), mPosInRefElementsList)          If PosInRefElementsList            RefElementListLine$ = FastMid(ListOfUsedElements$(RefElement), mPosInRefElementsList, PosInRefElementsList - mPosInRefElementsList)            ;            ; On récupère le contenu de l'élément.            If RefElement < #PBBLabel              ; S'il s'agit d'un "véritable" élement (procédure, macro, structure, énumération ou interface),              ; on va lire le code dans le fichier d'origine, en précisant cependant (dernier paramètre = #True)              ; que l'on veut la version 'LCase' du code.              SourceFile$         = StringField(RefElementListLine$, #EL_FileName, Chr(9))              ElementStartingPos  = Val(StringField(RefElementListLine$, #EL_StartingPos, Chr(9)))              ElementEndingPos    = Val(StringField(RefElementListLine$, #EL_EndingPos, Chr(9)))              *SearchString = GetPointedElementContentFromFile(SourceFile$, ElementStartingPos, ElementEndingPos, #True)            Else              ; Sinon, on utilise sa déclaration en version LCase().              SearchStringMem\s = LCase(StringField(RefElementListLine$, #EL_CompleteElementDeclaration, Chr(9)))              *SearchString = SearchStringMem            EndIf            ;            If *SearchString\s = "" Or *SearchString\s = "Error"              ; Cela ne peut, en principe, pas arriver.              ProcedureReturn #Completion_Error            EndIf            ;            mParent$ = StringField(RefElementListLine$, #EL_ElementName, Chr(9)) + "/" + Str(RefElement) + "/" + SourceFile$ + "/" + StringField(RefElementListLine$, #EL_StartingLine, Chr(9))            ; Pour chaque élément utilisé, mParent$ permettra de retrouver, en cas de besoin,            ; la raison pour laquelle on a décidé qu'il était utilisé.            ; En résumé : si mParent$ est utilisé, alors, ses 'enfants', c'est-à-dire tous            ; les éléments qui comporte ce parent dans la ligne de ListOfUsedElements$() qui            ; les concerne (dans le champs #EL_Parent), seront considérés comme utilisés.            ; mParent$ est une variable 'Static', afin que son contenu soit préservé lorsque l'examen            ; de *SearchString\s s'opère en plusieurs passes successives (puisque chaque passe s'interrompt            ; au bout de 200 ms).            ;          ElseIf PosInRefElementsList - mPosInRefElementsList = 0            alert("ProgramError in 'CompleteListOfUsedelements()'." + Chr(13) + "PosInRefElementsList = " + Str(PosInRefElementsList))            *SearchString = 0          Else            *SearchString = 0          EndIf        EndIf      EndIf      ;      plp = FindString(ListPos$, "P" + Chr(9) + Str(TypeOfElement) + Chr(9))      If plp = 0        PosInElementList = 0      Else        ; Nous sommes dans le cas d'une mise à jour partielle, sans doute suite à une modification        ; d'un fichier. Pour gagner du temps, nous n'allons vérifier la liste des éléments qu'à        ; partir de la position enregistrée dans ListPos$ :        plp + Len("P" + Chr(9) + Str(TypeOfElement) + Chr(9))        plpf = FindString(ListPos$, Chr(13), plp)        PosInElementList = Val(FastMid(ListPos$, plp, plpf - plp))      EndIf    EndIf    ;    ; Examen du code    ;    ; Pour savoir si un élément est utilisé, on parcours la liste des éléments ('ListOfAllElements$(TypeOfElement)')    ; et on regarde si on trouve l'un d'eux à l'intérieur du code que nous avons récupéré à l'étape précédente.    ;    If *SearchString And *SearchString\s      ManageWaitingWindow(PriorityMode, GetTextFromCatalog("LookingForUsedElements") + " " + PBBTypeTranslated$ + ".", PBBTypeTranslated$ + " " + GetTextFromCatalog("used"))      ;      Repeat ; On parcourt ListOfAllElements$(TypeOfElement) ligne par ligne.        mPosInElementList = PosInElementList + 1        PosInElementList = FindString(ListOfAllElements$(TypeOfElement), Chr(13), mPosInElementList)        If PosInElementList          ; On extrait la ligne de la liste ListOfAllElements$() :          LineE$ = FastMid(ListOfAllElements$(TypeOfElement), mPosInElementList, PosInElementList - mPosInElementList)          ;          PosInCode = FindElementInCode(*SearchString, LineE$, TypeOfElement)          If PosInCode            ;            ; Nous allons ajouter l'élément dans la liste ListOfUsedElements$()            ; en recopiant la ligne qui le concernait et qui figurait dans ListOfAllElements$().            ; Cette ligne a été mémorisée dans la variable 'LineE$'.            ;            ; Il faut également ajuster le champs '#EL_Parent' pour y intégrer le nom et le type du 'parent',            ; c'est-à-dire de l'élément référent qui nous a amené à décider que cet élément            ; était utilisé.            ;            Parent$ = mParent$            If mParent$ = #OutOfElementsName + "/"              ; Dans le cas où l'élement de référence n'existe pas, parce que l'élément              ; est utilisé dans une zone 'hors élément' (corps principal du programme),              ; on va tenter de retrouver la ligne du code qui nous a amené à décider que              ; l'élément en cours d'examen est utilisé.              ;              ; C'est moins simple qu'il n'y paraît, car nous avons fait notre trouvaille              ; dans le code 'OutOfElementContent\s', qui est une compilation de tous les              ; fichiers du code, débarrassé de leurs éléments. La position obtenue ne              ; correspond donc pas à celle du code d'origine.              ; Nous allons extraire la ligne encadrant 'PosInCode' et chercher sa               ; position dans le code source original.              ;              ; Recherche du fichier source :              ; (cette adresse est enregistrée par la procédure 'SettAllListsOfUsedElements()'              ; lorsqu'elle établit le contenu de 'OutOfElementContent').              PosFileName = FindString(*SearchString\s, Chr(13) + ";¤", PosInCode)              If PosFileName = 0                Alert("CompleteListOfUsedElements: Program error / FileName is missing in OutOfElementContent\s")              Else                PosFileName + 3                pf = FindString(*SearchString\s, Chr(13), PosFileName)                OFileName$ = FastMid(*SearchString\s, PosFileName, pf - PosFileName)                *SourceCode.String = GetPointedCodeFromFile(OFileName$, #True)              EndIf              ;              ; Extraction de la ligne où l'élément est cité :              pd = PosInCode              pf = FindString(*SearchString\s, Chr(13), pd)              If pf = 0 : pf = Len(*SearchString\s) + 1 : EndIf              While pd And FastMid(*SearchString\s, pd, 1) <> Chr(13) : pd - 1 : Wend              Extract$ = FastMid(*SearchString\s, pd, pf - pd)              ;              ; Recherche de la ligne extraite dans le fichier source :              RealPosInCode = FindString(*SourceCode\s, Extract$)              If RealPosInCode = 0                Alert("CompleteListOfUsedElements: Program error / Unable to find extract into source code: ''" + Extract$ + "''." + Chr(13) + Chr(13) + *SourceCode\s)              Else                ; Calcul du numéro de ligne où se trouve la ligne de référence :                Parent$ = mParent$ + OFileName$ + "/" + Str(CountString(FastMid(*SourceCode\s, 1, RealPosInCode), Chr(13)) + 1)              EndIf            Else              ; Quand la référence a été trouvée dans le code d'un élément,              ; on ajoute simplement le numéro de ligne où elle a été trouvée              ; au numéro de ligne où démarrait l'élément :              ;              ; On récupère d'abord les 3 premières valeurs de mParent$ :              Parent$ = StringField(mParent$, 1, "/") + "/" + StringField(mParent$, 2, "/") + "/" + StringField(mParent$, 3, "/") + "/"              ; Et on ajoute le numéro de ligne à la quatrième valeur :              Parent$ + Str(Val(StringField(mParent$, 4, "/")) + CountString(FastMid(*SearchString\s, 1, PosInCode), Chr(13)))            EndIf            ;            mLenLineP = Len(LineE$)            LineE$ = InsertValueIntoListLine(LineE$, Parent$, #EL_Parent)            ;            ; À présent, on réintègre la ligne dans la liste des éléments :            ListOfAllElements$(TypeOfElement) = FastLeft(ListOfAllElements$(TypeOfElement), mPosInElementList - 1) + LineE$ + FastMid(ListOfAllElements$(TypeOfElement), PosInElementList)            PosInElementList - mLenLineP + Len(LineE$)            ; et on l'ajoute à la liste des éléments utilisés :            ListOfUsedElements$(TypeOfElement) + LineE$ + Chr(13)            ;          EndIf        EndIf      Until PosInElementList = 0 Or ((ElapsedMilliseconds() - CLE_StartTime > 200) And PriorityMode <> #FinishCompletionNow)      ;      If PosInElementList = 0        ; On annule tout de suite le double-pending si l'examen du code est terminé,         ; comme ça, s'il nous reste du temps, on enchaînera sur un nouveau contenu.        ListCompletionUsed(TypeOfElement) = #ListCompletion_Pending      EndIf    EndIf  Until *SearchString = 0 Or *SearchString\s = "" Or ((ElapsedMilliseconds() - CLE_StartTime > 200) And PriorityMode <> #FinishCompletionNow)  ;  If ListCompletionAll(TypeOfElement) = #ListCompletion_Printed    ; La liste a déjà été affichée. On demande à la réafficher,    ; afin que les éléments utilisés se distinguent des non-utilisés.    ListCompletionAll(TypeOfElement) = #ListCompletion_Done  EndIf  ;  mRefElement = RefElement  ;  If *SearchString And *SearchString\s    ; Nous nous sommes interrompus en cours de travail.    If PosInElementList <> 0      ; L'interruption a lieu alors que la liste des éléments n'est pas entièrement explorée.      ; Nous sommes en 'DoublePending'.      ListCompletionUsed(TypeOfElement) = #ListCompletion_DoublePending    Else      ; La liste des éléments a été entièrement explorée, mais celle des éléments de référence n'a pas      ; été entièrement parcourue. Nous sommes en 'pending'.      ListCompletionUsed(TypeOfElement) = #ListCompletion_Pending    EndIf    ;    ; Nous allons enregistrer PosInRefElementsList, car l'examen de la liste des éléments de référence    ; n'est pas terminé.    ListCompletionReference$(TypeOfElement) = MemorizeRefAndPos(ListCompletionReference$(TypeOfElement), RefElement, PosInRefElementsList)    ;    mPosInRefElementsList = PosInRefElementsList    ;    ProcedureReturn #Completion_Uncomplete  Else    ; Nous avons terminé une passe d'exploration, mais il y en a    ; peut-être d'autres à faire (voir ExecuteSerialCompletionForUsedElements()).    ListCompletionUsed(TypeOfElement) = #ListCompletion_StageCompleted    ListCompletionStepsCompleted(TypeOfElement) = 2    ; Nous allons enregistrer mPosInRefElementsList, car l'examen de la liste des éléments de référence    ; est terminé, et PosInRefElementsList vaut logiquement zéro. Mais si plusieurs passes sont effectuées    ; avec le même type d'élément de référence, on ne veut pas reprendre à chaque fois à zéro, mais examiner    ; seulement les nouveaux éléments de références ajoutés à la liste.    ; mPosInRefElementsList nous indiquera par conséquent quel était le dernier élément figurant dans la    ; liste au cours de cette passe.    ListCompletionReference$(TypeOfElement) = MemorizeRefAndPos(ListCompletionReference$(TypeOfElement), RefElement, mPosInRefElementsList)  EndIf  ProcedureReturn #Completion_CompletedEndProcedure;Procedure ExecuteSerialCompletionsForUsedElements(StagesToComplete$, PriorityMode, ListPos$ = "", DontLoop = #False)  ;  ; Cette fonctionne comme une sorte d'interpréteur qui va lancer 'CompleteListOfUsedElements()'  ; à plusieurs reprises, en fonction de ce que contient 'StagesToComplete$'  ; et qui va répéter les opérations jusqu'à ce que les listes d'élements  ; à compléter n'intègrent plus de nouvelles lignes.  ;  ; 'StagesToComplete$' est une sorte de "programme" que cette procédure  ; devra exécuter ligne par ligne, puis recommencer jusqu'à qu'il n'y ait plus  ; de modification(s) résultant d'un cycle.   ;  ; La difficulté provient du fait que cette procédure est conçue pour  ; s'exécuter en tâche de fond et pour s'interrompre toutes les 200 millisecondes.  ;  ; Compte tenu de la puissance de la machine sur laquelle elle tourne,  ; il est impossible de savoir à l'avance à quelle étape le processus  ; va s'interrompre. Mais quand la procédure est à nouveau appelée, il faut  ; qu'elle reprenne l'exploration à l'endroit exact où elle l'avait laissée.  ;  ; Ce sont essentiellement les variables 'Static' ci-dessous qui vont nous  ; permettre de nous repositionner où il le faut.  ; Mais la valeur de 'ListCompletionUsed(ElementToComplete)' nous servira  ; également de repère, selon qu'elle est à '#ListCompletion_UnDone',  ; '#ListCompletion_Pending', '#ListCompletion_StageCompleted' ou '#ListCompletion_Done'.  ;  ; Enfin, la procédure 'CompleteListOfUsedElements()' va également nous retourner  ; une valeur qui nous dira dans quelles conditions elle a interrompu son travail :  ; Cette valeur sera #Completion_Uncomplete ou #Completion_Completed, selon le cas.  ;  ; Pour certains types d'éléments (les énumérations, en tout cas), il n'est pas  ; utile d'effectuer plusieurs cycles. C'est pourquoi le paramètre 'DontLoop' existe.  ; Si DontLoop vaut #True, un seul cycle est effectué.  ;  Static ListIncreased   ; Si au moins une ligne est ajoutée à l'une des listes                         ; concernées par le cycle, cette valeur passera à #True.  Shared StageMustReboot ; Si en fin de cycle, on constate que ListIncreased                         ; vaut true, StageMustReboot sera positionné à #True                         ; pour relancer le cycle. Cette variable est 'Shared'                         ; afin de permettre une relance forcée du cycle, lors                         ; des mises à jour partielles des listes.  ;  Static Initialized, PosInStagesToComplete  ;  Protected ProgramLine$, ElementToComplete, ElementToComplete$, RefElement  Protected MemLen, CompletionState, Pos  ;  If Initialized = 0 : Initialized = 1 : StageMustReboot = #True : EndIf  ;  Repeat    If StageMustReboot = #True      StageMustReboot = #False      ; Nous allons redémarrer un cycle et nous ne repasserons pas par ici      ; avant la fin de ce cycle.      ;      PosInStagesToComplete = 1      ListIncreased   = #False      ;    EndIf    ; Le cycle commence véritablement ici :    Repeat      ; Nous repasserons par ici à chaque appel de cette procédure, jusqu'à ce que      ; la ligne de 'programme' StagesToComplete$ en cours d'exécution soit entièrement exécutée.      ;      ; On recharge les paramètres de la ligne en cours d'exécution.      ProgramLine$ = StringField(StagesToComplete$, PosInStagesToComplete, Chr(13))      If ProgramLine$        ElementToComplete = Val(StringField(ProgramLine$, 1, Chr(9)))        RefElement = Val(StringField(ProgramLine$, 2, Chr(9)))        ;        If DontLoop = #False And ListIncreased = #False          ; On mémorise la longueur de la liste ListOfUsedElements$() afin de pouvoir          ; détecter des ajouts au cours de l'examen qui va suivre :          MemLen = Len(ListOfUsedElements$(ElementToComplete))        EndIf        ;        ; Nous sommes ici au centre de cette procédure dont le rôle consiste à appeler        ; CompleteListOfUsedElements() à répétition, avec les divers paramètres contenus        ; dans 'StagesToComplete$'.        CompletionState = CompleteListOfUsedElements(ElementToComplete, PriorityMode, RefElement, ListPos$)        ;        If DontLoop = #False And ListIncreased = #False And MemLen <> Len(ListOfUsedElements$(ElementToComplete))          ; Un ou plusieurs éléments ont été ajoutés à la liste          ListIncreased = #True        EndIf        ;        If CompletionState <> #Completion_Completed          ; 200 ms viennent de s'écouler et CompleteListOfUsedElements() s'est interrompue.          ; Néanmoins, CompleteListOfUsedElements() a mémorisé la position où elle s'est interrompue          ; et elle reprendra l'exploration au même endroit lors du prochain appel.          ProcedureReturn CompletionState        EndIf        ; Si nous arrivons jusqu'ici, c'est que CompleteListOfUsedElements() a complété la passe        ; que nous lui avons demander de faire. Tous les élements de 'RefElement' ont été examinés        ; afin de décider si les les éléments de 'ElementToComplete' sont utilisés ou non.      EndIf      ; On avance à la ligne suivante de 'StagesToComplete$'      PosInStagesToComplete + 1    Until ProgramLine$ = ""    ;    ; Le cycle est terminé.    ;    If ListIncreased = #True      StageMustReboot = #True      ; StageMustReboot ne prend la valeur #True qu'une fois      ; le cycle terminé, alors que ListIncreased peut valoir #True      ; en cours de cycle. Cette nuance est essentielle, car,      ; en raison des interruptions toutes les 200 ms, il peut      ; arriver que cette procédure soit appellée à de nombreuses      ; reprises avant qu'un cycle ne soit achevé et il faut que      ; StageMustReboot reste à #False jusque_là.    EndIf    ;  Until StageMustReboot = #False  ;  ; Toutes les listes concernées par le "programme" ont été complétées.  ; On va le signaler en donnant à ListCompletionUsed(ElementToComplete)  ; la valeur '#ListCompletion_Done' pour chacune d'elles.  Pos = 1  Repeat    ProgramLine$ = StringField(StagesToComplete$, Pos, Chr(13))    If ProgramLine$      ElementToComplete$ = StringField(ProgramLine$, 1, Chr(9))      ListCompletionUsed(Val(ElementToComplete$)) = #ListCompletion_Done    EndIf    Pos + 1  Until ProgramLine$ = ""  ;  StageMustReboot = #True ; On réinitalise ce drapeau pour le prochain 'programme'.  ;  ; On retourne la valeur #Completion_Uncomplete dans tous les cas,  ; pour que SetAllListsOfUsedElements() aille jusqu'au bout de ses programmes.  ProcedureReturn #Completion_UncompleteEndProcedure;Procedure TakeOffAllElementsFromCode(*SearchString.String, toe = 0, TimeSOOEC = 0)  ;  ; Épure le code contenu dans *SearchString pour en retirer  ; les procédures, macros, structures, énumérations et interfaces.  ;  ; On ne retire pas les DataSection, car elles peuvent contenir  ; des 'VTable' qui permettent de décider si une procédure est  ; utilisée ou non.  ; Il est tentant de retirer tous les commentaires et espaces inutiles  ; du code de 'OutOfElementContent\s', afin d'accélérer les recherches  ; qui porteront sur ce code. Mais, après tests, il s'avère que le temps  ; consacré à ce nettoyage est supéreur au temps gagné.  ; Cela n'est donc pas fait.  ;  Repeat    If toe <= #PBBInterface      ; On retire les procédures, les macros, les structures,      ; les énumérations et les interfaces.      TakeOffOneElementContentFromCode(LCase(PBBTypeNames$(toe)), *SearchString)    ElseIf toe = #PBBInterface + 1      ; On retire les lignes commençant par "Declare" :      DeleteLinesBeginningBy(LCase("Declare"), *SearchString)    ElseIf toe = #PBBInterface + 2      ; On retire les lignes commençant par "Prototype" :      DeleteLinesBeginningBy(LCase("Prototype"), *SearchString)    EndIf    toe + 1  Until (toe > #PBBInterface + 2) Or (TimeSOOEC And (ElapsedMilliseconds() - TimeSOOEC) > 200)  ProcedureReturn toeEndProcedure;Procedure SetAllListsOfUsedElements(PriorityMode = #WorkInBackGround, ListPos$ = "")  ;  ; Cette procédure établi la liste des éléments utilisés en posant comme règle  ; qu'un élément est considéré comme "utilisé" à parti du moment où il est cité  ; dans le code d'un autre élément, déjà identifié comme "utilisé".  ; Exemple : une procédure appelée dans le corps du fichier principal ('hors-éléments') appelle  ; elle-même d'autres procédures qui seront alors considérées comme "utilisées".  ;  ; Pour accomplir sa tâche, cette procédure est découpée en deux étapes qui seront signalées  ; dans le code :  ; • Étape 1 : On remplit la variable 'OutOfElementContent\s' avec l'ensemble du code de tous  ;             le fichiers, puis on élimine de cette compilation tous les éléments qui y figuraient.  ; • Étape 2 : On appelle 'ExecuteSerialCompletionsForUsedElements()' en lui fournissant à   ;             chaque fois une liste de tâches à accomplir jusqu'à plus soif. Par exemple, pour  ;             décider si une procédure est utilisée, il faut regarder si elle est citée par une  ;             autre procédure ou une macro quelconque qui seraient elles-mêmes utilisées.  ;             Mais pour savoir si une macro est utilisée, il faut regarder si elle est citée  ;             par une procédure quelconque qui serait elle-même utilisée. On comprends donc  ;             qui va falloir effectuer quelques tours de manège pour venir à bout de tout ça.  ;  ;  Shared SettingOutOfElementContent  ;  Static SearchString.string, PosInFileList, mfilename$, toe ; Variables utilisées lors de 'SettingOutOfElementContent'.  ;  Protected lineC$, FileName$, TimeSOOEC  Protected StagesToComplete$, ReturnValue  ;  If OutOfElementContent\s = ""  And SettingOutOfElementContent = #False    SettingOutOfElementContent = #True    PosInFileList = 1    toe = 0    mfilename$ = ""  EndIf  ;  ;  ; ---------------------------------------------------  ;                       Étape 1  ; ---------------------------------------------------  ;  ; On commence par renseigner la variable globale 'OutOfElementContent\s' avec une compilation  ; de tout ce qui figure en dehors des procédures, macros, structures, énumérations et Datasections  ; dans l'ensemble des fichiers figurant dans PBBListOfFiles$.  ;  ; Cette compilation servira à la procédure SetAllListsOfUsedElements()  ; pour déterminer quels éléments sont utilisés ou non.  ;  If SettingOutOfElementContent = #True    TimeSOOEC = ElapsedMilliseconds()    Repeat      lineC$ = StringField(PBBListOfFiles$, PosInFileList, Chr(13))      If lineC$        FileName$ = StringField(lineC$, 1, Chr(9))        If FileName$          If mfilename$ <> filename$            mfilename$ = filename$            SearchString\s = GetStringCodeFromFile(FileName$, #True) + Chr(13)          EndIf          toe = TakeOffAllElementsFromCode(SearchString, toe, TimeSOOEC)          ;          If toe > #PBBInterface + 2            toe = 0            ; On concatène les chaînes nettoyées de leurs éléments.            ;            ; À la fin de chaque chaîne, on fait figurer le nom du fichier source.            ; Cela permettra à 'CompleteListOfUsedElement()' de repositionner            ; les parties de code permettant de décider si un élément est utilisé.            ; Cela permettra aussi à 'UpdataListOfElement()' de mettre à jour            ; OutOfElementContent quand un fichier a été modifié :            OutOfElementContent\s + SearchString\s + Chr(13) + ";¤" + filename$ + Chr(13)            PosInFileList + 1          EndIf        EndIf      EndIf    Until lineC$ = "" Or (ElapsedMilliseconds() - TimeSOOEC) > 200    ;    If lineC$ = ""      SettingOutOfElementContent = #False    EndIf    ProcedureReturn #Completion_Uncomplete  EndIf  ;  ; ---------------------------------------------------  ;                       Étape 2  ; ---------------------------------------------------  ;  Repeat    If ListCompletionUsed(#PBBProcedure) < #ListCompletion_Done      ; On va travailler simultanément sur les procédures et les macros      ; dont on va compléter les listes 'ListOfUsedElements()'      StagesToComplete$ = Str(#PBBProcedure) + Chr(9) + Str(#PBBProcedure) + Chr(9) + Chr(13)      StagesToComplete$ + Str(#PBBMacro)     + Chr(9) + Str(#PBBProcedure) + Chr(9) + Chr(13)      StagesToComplete$ + Str(#PBBProcedure) + Chr(9) + Str(#PBBMacro)     + Chr(9) + Chr(13)      StagesToComplete$ + Str(#PBBMacro)     + Chr(9) + Str(#PBBMacro)     + Chr(9) + Chr(13)      ;      ; La première ligne ordonne de compléter la liste des procédures utilisées      ; par d'autres procédures. Au début, la liste est vide, mais CompleteListOfUsedElements()      ; va examiner le code 'hors-éléments' (c'est à dire hors-procédures, dans ce cas), et si      ; une seule procédure est appelée par le fichier principal, cela suffira pour identifier      ; toutes les procédures qu'elle appelle. Et ainsi de suite.      ; La deuxième ligne ordonne de compléter la liste des macros utilisées par les      ; procédures identifiées comme utilisées.      ; La troisième ligne ordonne de compléter la liste des procédures avec celles qui sont      ; appelées par des macros.      ; La quatrième ligne ordonne de compléter la liste des macros avec celles qui sont      ; appelées par d'autres macros.      ; Ces quatre examens vont tourner en boucle jusqu'à ce qu'aucun nouvel élément ne soit      ; identifié comme étant utilisé.      ReturnValue = ExecuteSerialCompletionsForUsedElements(StagesToComplete$, PriorityMode, ListPos$)      ;    ElseIf ListCompletionUsed(#PBBVariable) < #ListCompletion_Done      StagesToComplete$ = Str(#PBBVariable) + Chr(9) + Str(#PBBProcedure) + Chr(9) + Chr(13)      StagesToComplete$ + Str(#PBBVariable) + Chr(9) + Str(#PBBMacro)     + Chr(9) + Chr(13)      ;       ReturnValue = ExecuteSerialCompletionsForUsedElements(StagesToComplete$, PriorityMode, ListPos$)      ;    ElseIf ListCompletionUsed(#PBBStructure) < #ListCompletion_Done      StagesToComplete$ = Str(#PBBStructure) + Chr(9) + Str(#PBBProcedure) + Chr(9) + Chr(13)      StagesToComplete$ + Str(#PBBStructure) + Chr(9) + Str(#PBBMacro)     + Chr(9) + Chr(13)      StagesToComplete$ + Str(#PBBStructure) + Chr(9) + Str(#PBBStructure) + Chr(9) + Chr(13)      ; Il peut arriver qu'une structure, qu'on appellera 'StructA', ne soit utilisée      ; que par une autre structure, qu'on appellera 'StructB'.      ; Dans un tel cas, la première passe d'exploration ne notera pas 'StructA'      ; comme utilisée. On procède donc à des passes répétitives.      ReturnValue = ExecuteSerialCompletionsForUsedElements(StagesToComplete$, PriorityMode, ListPos$)      ;    ElseIf ListCompletionUsed(#PBBConstante) < #ListCompletion_Done      StagesToComplete$ = Str(#PBBConstante) + Chr(9) + Str(#PBBProcedure) + Chr(9) + Chr(13)      StagesToComplete$ + Str(#PBBConstante) + Chr(9) + Str(#PBBMacro)     + Chr(9) + Chr(13)      StagesToComplete$ + Str(#PBBConstante) + Chr(9) + Str(#PBBConstante) + Chr(9) + Chr(13)      ; On comprend facilement qu'on puisse demander à CompleteListOfUsedElements()      ; d'explorer le code des procédures pour voir si l'une d'elles utilise une constante.      ; Mais il peut sembler étrange de lui demander d'explorer le 'code' des constantes,      ; comme c'est le cas dans la troisième ligne qui figure ci-dessus.      ; Pourtant, il peut arriver qu'une constante ne soit utilisée que pour attribuer      ; une valeur à une autre constante. Comme par exemple :      ;           #ConstantA = #ConstanteB + 1      ; Dans un tel cas, #ConstanteB ne sera considérée comme "utilisée" que si      ; #ConstanteA est elle-même utilisée.      ;      ; Pour gérer ce cas de figure, les lignes où les constantes sont déclarées sont      ; stockées dans le tableau ListOfUsedElements$(), en même temps que les noms et      ; les emplacement de sa déclaration. Quand on demande à CompleteListOfUsedElements()      ; d'examiner le 'code' d'une constante, il examine sa déclaration.      ;       ReturnValue = ExecuteSerialCompletionsForUsedElements(StagesToComplete$, PriorityMode, ListPos$)      ;    ElseIf ListCompletionUsed(#PBBLabel) < #ListCompletion_Done      ;      ; On va examiner les procédures et les macros pour déterminer quels labels      ; sont utilisés. Inutile de faire plusieurs passes. On donne donc la valeur      ; #True à DontLoop (dernier paramètre de ExecuteSerialCompletionsForUsedElements()).      ;       StagesToComplete$ = Str(#PBBLabel) + Chr(9) + Str(#PBBProcedure) + Chr(9) + Chr(13)      StagesToComplete$ + Str(#PBBLabel) + Chr(9) + Str(#PBBMacro)     + Chr(9) + Chr(13)      ;       ReturnValue = ExecuteSerialCompletionsForUsedElements(StagesToComplete$, PriorityMode, ListPos$, #True)      ;    ElseIf ListCompletionUsed(#PBBEnumeration) < #ListCompletion_Done      ; La procédure SetOneListOfAllElements() a enregistré dans la liste des constantes      ; le nom de l'énumération à laquelle chacune d'elles appartient (si elle appartient      ; à une énumération, bien entendu).      ; On va donc demander à CompleteListOfUsedElements() d'examiner les constantes et de      ; déclarer une énumération comme 'utilisée' si l'une de ses constantes est utilisée.      ; Inutile de faire plusieurs passes. On donne donc la valeur #True      ; à DontLoop (dernier paramètre de ExecuteSerialCompletionsForUsedElements()).      ;      StagesToComplete$ = Str(#PBBEnumeration) + Chr(9) + Str(#PBBConstante) + Chr(9) + Chr(13)      ;       ReturnValue = ExecuteSerialCompletionsForUsedElements(StagesToComplete$, PriorityMode, ListPos$, #True)      ;    Else      ;      ReturnValue = #Completion_Completed      ;    EndIf  Until ReturnValue = #Completion_Completed Or ReturnValue = #Completion_Error Or PriorityMode <> #FinishCompletionNow  ;  ProcedureReturn ReturnValueEndProcedure;; **********************************************************************************;;         Procédures liées à la mise à jour partielle des listes d'éléments;; **********************************************************************************;Procedure FindStartOfDifference(*OldContent.String, *NewContent.String, EndExam = 0)  ;  ; Recherche la position où les chaînes *OldContent\s et *NewContent\s  ; présentent des différences.  ;  ; On commence par découper la chaîne en tronçons que l'on examine un par un.  ; Lorsque qu'un tronçon diffère d'une chaîne à l'autre, on le redécoupe en  ; tronçons que l'on examine un par un, et ainsi de suite, jusqu'à trouver  ; la position ou commence les différences.  ;  Protected  StartExam, maxpos, BlockDivider, mDiff, Diff, Fork, Pos  ;  StartExam = 1  If EndExam = 0    EndExam = Len(*OldContent\s) + 1  EndIf  maxpos = EndExam  BlockDivider = EndExam / 1000 ; On part, à priori, sur des tronçons de 1000 caractères.  If BlockDivider < 6 : BlockDivider = 6 : EndIf ; Mais on découpe au minimum 6 tronçons.  mDiff = 0  Repeat    Diff = 0    Fork = (EndExam - StartExam + 1) / BlockDivider    If Fork > 1      For Pos = 1 To (BlockDivider + 1) ; Il faut faire une passe excédentaire à cause de l'arrondi sur 'Fork'.        If FastMid(*OldContent\s, StartExam, Fork) <> FastMid(*NewContent\s, StartExam, Fork)          Diff = 1          mDiff = 1          Break        EndIf        StartExam + Fork      Next      If Diff        EndExam = StartExam + Fork        If EndExam > maxpos : EndExam = maxpos : EndIf      EndIf    EndIf  Until Diff = 0  If mDiff    ; On termine la recherche en comparant caractère par caractère, jusqu'à trouver    ; le premier qui diffère.    While FastMid(*OldContent\s, StartExam, 1) = FastMid(*NewContent\s, StartExam, 1) And StartExam < maxpos      StartExam + 1    Wend    ;    If StartExam <= maxpos      ProcedureReturn StartExam    EndIf  EndIf  ProcedureReturn 0EndProcedure;Procedure FindIDENotations(*Content.String)  ;  ; On examine les 1000 derniers caractères de la chaîne  ; pour repérer la position des annotations de l'IDE.  ;  ; On va remonter dans le code jusqu'à ce qu'on trouve  ; autre chose que des lignes commençant par ";".  ;  Protected ExamString$, ns, nst  ;  ExamString$ = ReverseString(FastMid(*Content\s, Len(*Content\s) - 1000, 1000))  ns = 0  nst = 2 ; Si la chaîne complète se termine par un retour-chariot, on le saute.  Repeat    nst = FindString(ExamString$, Chr(13), nst)    If nst And FastMid(ExamString$, nst - 1, 1) = ";"      nst + 1 : ns = nst - 1    Else      nst = 0    EndIf  Until nst = 0  If FindString(FastMid(*Content\s, Len(*Content\s) - ns), "IDE Options") = 0    ;     alert("FindIDENotations Error : ''IDE Options'' is not in text." + Chr(13) + FastMid(*Content\s, Len(*Content\s) - ns))    ProcedureReturn - 1  EndIf  ProcedureReturn Len(*Content\s) - nsEndProcedure;Dim ULOE_mPosInElementList(#EndEnumPBBElementTypes);Procedure RegisterElementAsUnused(PosInList, TypeOfElement, *mParentList.String = 0)  ;  ; Efface le champs #EL_Parent d'un élément figurant dans 'ListOfAllElements$(TypeOfElement)'  ; et supprime ce même élément de la liste 'ListOfUsedElements$(TypeOfElement)'  ;  Shared ULOE_mPosInElementList()  ;  Protected pf, LineE$, Parent$, mLenLineE, ElementName$, ElementNameLCase$  Protected EFName$, ExistingElement, mExistingElement  ;  If PosInList    ; On commence par chercher les bornes de l'élément à l'intérieur de la liste 'ListOfAllElements$(TypeOfElement)' :    ; Cherche la borne de fin :    pf = FindString(ListOfAllElements$(TypeOfElement), Chr(13), PosInList)    ; Cherche la borne de début, au cas où PosInList ne pointerait pas sur le début de l'élément :    While PosInList And FastMid(ListOfAllElements$(TypeOfElement), PosInList, 1) <> Chr(13) : PosInList - 1 : Wend    PosInList + 1    ; Extrait la ligne correspondant à l'élément :    LineE$ = FastMid(ListOfAllElements$(TypeOfElement), PosInList, pf - PosInList)    Parent$ = StringField(LineE$, #EL_Parent, Chr(9))    If Parent$      mLenLineE = Len(LineE$)      ElementName$ = StringField(LineE$, #EL_ElementName, Chr(9))      ElementNameLCase$ = StringField(LineE$, #EL_ElementNameLCase, Chr(9))      ; On supprime la référence au parent et on rejette l'élément en fin de liste.      ; Ainsi, il fera partie des éléments ré-examinés lorsque nous      ; mettrons la liste à jour pour ré-intégrer les éléments utilisés :      LineE$ = InsertValueIntoListLine(LineE$, "", #EL_Parent)      ListOfAllElements$(TypeOfElement) = FastLeft(ListOfAllElements$(TypeOfElement), PosInList - 1) + FastMid(ListOfAllElements$(TypeOfElement), pf + 1) + LineE$ + Chr(13)      PosInList - mLenLineE + Len(LineE$)      ULOE_mPosInElementList(TypeOfElement) - mLenLineE - 1      ;      ; On supprime aussi l'élément de la liste des éléments utilisés.      CheckIfElementExistsInList(ListOfUsedElements$(TypeOfElement), ElementNameLCase$, TypeOfElement)      If ExistingElement        pf = FindString(ListOfUsedElements$(TypeOfElement), Chr(13), ExistingElement)        ListOfUsedElements$(TypeOfElement) = FastLeft(ListOfUsedElements$(TypeOfElement), ExistingElement - 1) + FastMid(ListOfUsedElements$(TypeOfElement), pf + 1)      EndIf      If *mParentList        ; Cet élément servait peut-être à décider si un autre        ; élément était utilisé. On ajoute son nom et son type        ; à la liste de vérification :        *mParentList\s + ElementName$ + "/" + Str(TypeOfElement) + Chr(13)      EndIf    EndIf    ;  EndIf  ProcedureReturn PosInListEndProcedure;Procedure UpdateUsedElementListFromAllElementList(PosInList, TypeOfElement)  ;  ; Met à jour la liste ListOfUsedElements$(TypeOfElement) avec la définition  ; de l'élément contenue dans ListOfAllElements$(TypeOfElement)  ;  Protected pf, LineE$, ElementNameLCase$, EFName$, ExistingElement, mExistingElement  ;  If PosInList    ; On commence par chercher les bornes de l'élément à l'intérieur de la liste 'ListOfAllElements$(TypeOfElement)' :    ; Cherche la borne de fin :    pf = FindString(ListOfAllElements$(TypeOfElement), Chr(13), PosInList)    ; Cherche la borne de début, au cas où PosInList ne pointerait pas sur le début de l'élément :    While PosInList And FastMid(ListOfAllElements$(TypeOfElement), PosInList, 1) <> Chr(13) : PosInList - 1 : Wend    PosInList + 1    ; Extrait la ligne correspondant à l'élément :    LineE$ = FastMid(ListOfAllElements$(TypeOfElement), PosInList, pf - PosInList)    ElementNameLCase$ = StringField(LineE$, #EL_ElementNameLCase, Chr(9))    ; On recherche l'élément dans la liste des éléments utilisés.    CheckIfElementExistsInList(ListOfUsedElements$(TypeOfElement), ElementNameLCase$, TypeOfElement)    If ExistingElement      pf = FindString(ListOfUsedElements$(TypeOfElement), Chr(13), ExistingElement)      ; On met à jour 'ListOfUsedElements$(TypeOfElement)'      ListOfUsedElements$(TypeOfElement) = FastLeft(ListOfUsedElements$(TypeOfElement), ExistingElement - 1) + LineE$ + FastMid(ListOfUsedElements$(TypeOfElement), pf)    EndIf    ;  EndIf  ProcedureReturn ExistingElementEndProcedure;Procedure UpdateListOfElements(*OldContent.String, *NewContent.String, FileName$)  ;  ; Pour éviter de relancer une exploration complètes des fichiers à chaque fois  ; que l'un d'eux est modifié, nous allons isoler la partie du code qui a été  ; modifiée, puis nous mettrons à jour nos données en fonction de ce qui a changé.  ;  ; Concrètement, cela implique de :  ; • Mettre à jour la chaîne 'OutOfElementContent\s' qui comporte une compilation  ;   de tous les fichiers débarrassés de leurs éléments, pour ne conserver que le  ;   code 'hors éléments' (hors procédures, macros, structure, etc.)  ; • Mettre à jour les positions de début et de fin des éléments dans le code,  ;   pour tous les éléments qui se situent après la partie modifiée.  ; • Supprimer les éléments qui ne figurent plus dans la partie modifiée.  ; • Noter comme 'non-utilisés' tous les élements qui étaient utilisés par du  ;   code appartenant à la partie modifiée.  ; • Créer ou recréer les éléments qui appartiennent désormais à la partie  ;   modifiée (certains ont peut-être été supprimés pour de bon, d'autres  ;   ont peut-être été ajoutés).  ; • Revérifier l'utilisation des éléments en fonction du nouveau code.  ;  Shared ULOE_mPosInElementList() ; Cette liste va permettre de mémoriser la position dans                             ; ListOfAllElements$(), juste avant les éléments ajoutés                             ; par l'examen.  Shared BackgroundTasksCompletion ; Pour savoir si l'exploration profonde est terminée.  Shared StageMustReboot ; Pour réinitialiser 'ExecuteSerialCompletionsForUsedElements()'  ;  Protected Dim ULOE_mPosInUsedElementList(#EndEnumPBBElementTypes) ; Cette liste va permettre                             ; de mémoriser la position dans ListOfUsedElements$()                             ; juste avant les éléments ajoutés par l'examen.  ;  Protected mParentList.String, NewOutOfElementContent.String  Protected ROldContent.String, RNewContent.String  Protected NewCodeLCase.String  ;  Protected MissingInOld$, AddedInNew$  Protected ModOldEndPos, ModNewEndPos, ModStartPos, ModStartingLine, ModOldEndingLine, ModNewEndingLine  Protected ElementStartingPos, ElementEndingPos, ElementStartingLine, ElementEndingLine  Protected EndExamOld, EndExamNew  Protected PosInPLList, PosInList, PosInCode, PosInAEList, PosInElementList, mPosInElementList  Protected LineE$, mLenLineE, LineUsedElement$, LineNewElement$  Protected ExistingElement, mExistingElement  Protected Parent$, mParent$, ElementNameLCase$, UsedElementPos, UsedElementEndPos  Protected UnModified$, OtherModified$, NewMParentList$, NoLigneRef, mLen, ListPos$, nRef$  Protected EFName$, mPosInList  Protected p, mp, TypeOfElement, pf, pf2, pd, pd2, DiffInverse, tx$  ;  ;  ; Nous allons déterminer quelle partie du fichier a été modifiée.  ;  EndExamOld = FindIDENotations(*OldContent)  If EndExamOld = -1    ; Le fichier que l'on était censé avoir en mémoire n'est    ; apparamment pas un fichier de code PureBasic !    ; C'est peut-être un fichier vide, si l'utilisateur l'a    ; supprimé en cours d'examen.    BackgroundTasksCompletion = #BackgroundTasksMustRestart    ProcedureReturn #False  EndIf  ;  ModStartPos = FindStartOfDifference(*OldContent, *NewContent, EndExamOld)  If ModStartPos And ModStartPos < EndExamOld    ;    ; Le fichier a vraiment été modifié.    ;    ; ______________________________________________________________________________________________________    ;    ;    ; On détermine la fin de la zone modifiée :    ;    ROldContent.String\s = ReverseString(FastMid(*OldContent\s, ModStartPos, EndExamOld - ModStartPos + 1))    EndExamNew = FindIDENotations(*NewContent.String)    If EndExamNew = -1      ; Le fichier que l'on vient de lire n'est      ; apparamment pas un fichier de code PureBasic !      ; C'est peut-être un fichier vide, si l'utilisateur l'a      ; supprimé en cours d'examen.      BackgroundTasksCompletion = #BackgroundTasksMustRestart      ProcedureReturn #False    EndIf    RNewContent.String\s = ReverseString(FastMid(*NewContent\s, ModStartPos, EndExamNew - ModStartPos + 1))    ;    DiffInverse = FindStartOfDifference(ROldContent, RNewContent)    If DiffInverse = 0      tx$ = "UpdateListOfElements: Program error / No difference ending position." + Chr(13)      tx$ + "Beginning of differences: " + ReplaceString(Mid(*OldContent\s, ModStartPos, 100) + "...", Chr(13), "¶") + Chr(13)      tx$ + "String tested for searching of end position: " + ReplaceString(ReverseString(ROldContent\s), Chr(13), "¶") + Chr(13)      Alert(tx$)    EndIf    ModOldEndPos = EndExamOld - DiffInverse + 2    ModNewEndPos = EndExamNew - DiffInverse + 2    ;    ; On élargit la partie modifiée pour englober au moins une ligne complète :    While ModStartPos > 2 And FastMid(*OldContent\s, ModStartPos - 1, 1) <> Chr(13) : ModStartPos - 1 : Wend    While ModOldEndPos < Len(*OldContent\s) And FastMid(*OldContent\s, ModOldEndPos + 1, 1) <> Chr(13) : ModOldEndPos + 1 : ModNewEndPos + 1 : Wend    ;    ; ______________________________________________________________________________________________________    ;    ; On commence par mettre à jour OutOfElementContent\s avec le code du fichier modifié :    ;    NewOutOfElementContent\s = LCase(*NewContent\s)    ;    ; On débarrasse le contenu de la plupart de ses éléments :    TakeOffAllElementsFromCode(NewOutOfElementContent)    ;    ; On cherche la position de l'ancien contenu dans OutOfElementContent\s :    p = 0    Repeat      mp = p      p = FindString(OutOfElementContent\s, Chr(13) + ";¤", p + 1)    Until p = 0 Or FastMid(OutOfElementContent\s, p + 3, Len(FileName$)) = FileName$    ;    If p = 0      ; Il est impossible que p soit égal à 0,      ; sauf erreur de conception du programme.      Alert("UpdateListOfElements() : Program error / Unable to found " + FileName$ + " in OutOfElementContent\s" + Chr(13) + OutOfElementContent\s)      BackgroundTasksCompletion = #BackgroundTasksMustRestart      ProcedureReturn #False    Else      ;      ; On remplace le contenu :      If mp        ; On va à la fin du nom de fichier du fichier précédent :        mp = FindString(OutOfElementContent\s, Chr(13), mp + 1)      EndIf      ; On intègre le nouveau contenu en conservant son nom de fichier      ; qui figure à la position 'p'.      OutOfElementContent\s = Left(OutOfElementContent\s, mp) + NewOutOfElementContent\s + FastMid(OutOfElementContent\s, p)    EndIf    ;    ; ______________________________________________________________________________________________________    ;    ;    If BackgroundTasksCompletion <> #BackgroundTasksCompleted      ; L'exploration profonde est en cours. Notre mise à jour partielle      ; risque de mettre du désordre dans sa progression. Nous allons      ; conserver les listes d'éléments qui ont déjà été complétées, et      ; faire en sorte que l'exploration reparte à zéro pour les autres :      For TypeOfElement = 0 To (#EndEnumPBBElementTypes - 1)        If ListCompletionUsed(TypeOfElement) < #ListCompletion_Done          ; Si l'exploration profonde d'un élément n'était pas entièrement          ; terminée, on annule ce qui est déjà fait          ; et on signale aux processus de mise à jour partielle          ; qu'il n'est pas utile de s'intéresser à cet élément          ; puisqu'il sera entièrement revalidé lorsque l'exploration          ; profonde reprendra.          ListCompletionUsed(TypeOfElement) = #ListCompletion_DoNot          ;          ; On supprime les références à ces éléments en tant que parents          ; qui ont peut-être été enregistrés dans ListOfAllElements$()          pf = 0          Repeat ; On parcourt ListOfAllElements$(TypeOfElement) ligne par ligne.            pd = pf + 1            pf = FindString(ListOfAllElements$(TypeOfElement), Chr(13), pd)            If pf              RegisterElementAsUnused(pd, TypeOfElement)            EndIf          Until pf = 0        EndIf      Next    EndIf    ; ______________________________________________________________________________________________________    ;    ; Le repérage de la partie modifiée et de sa nouvelle version est terminé.    ; On peut procéder à la mise à jour des listes ListOfAllElements$() et ListOfUsedElements$()    ;    If (ModOldEndPos > ModStartPos And ModStartPos < EndExamOld) Or (ModNewEndPos > ModStartPos And ModStartPos < EndExamNew)      ModStartingLine = CountString(FastMid(*OldContent\s, 1, ModStartPos), Chr(13)) + 1      ModOldEndingLine = ModStartingLine + CountString(FastMid(*OldContent\s, ModStartPos, ModOldEndPos - ModStartPos), Chr(13)) + 1      ModNewEndingLine = ModStartingLine + CountString(FastMid(*NewContent\s, ModStartPos, ModNewEndPos - ModStartPos), Chr(13)) + 1      ; La position des éléments dans le code a peut-être changé,      ; suite aux modifications que l'on vient de déceler dans le code.      ; On va mettre à jour ListOfAllElements$() pour y faire figurer      ; les nouvelles positions.      ;      mParentList\s = ""      For TypeOfElement = 0 To (#EndEnumPBBElementTypes - 1)        pf = 0        Repeat          pd = pf + 1          pf = FindString(ListOfAllElements$(TypeOfElement), Chr(13), pd)          If pf = 0            pf = -1          Else            ; On extrait une ligne définissant un élément dans ListOfAllElements$()            LineE$ = FastMid(ListOfAllElements$(TypeOfElement), pd, pf - pd)            mLenLineE = Len(LineE$)            ; On vérifie que l'élément est défini dans le fichier qui vient d'être modifié :            If StringField(LineE$, #EL_FileName, Chr(9)) = FileName$              ; On regarde si l'élément figure après la partie modifiée :              ElementStartingPos = Val(StringField(LineE$, #EL_StartingPos, Chr(9)))              ElementEndingPos = Val(StringField(LineE$, #EL_EndingPos, Chr(9)))              ElementStartingLine = Val(StringField(LineE$, #EL_StartingLine, Chr(9)))              ;              If ElementStartingPos >= ModOldEndPos                ;                ; On met à jour les position de début et de fin de l'élément dans le code :                ElementStartingPos = ElementStartingPos + ModNewEndPos - ModOldEndPos                ElementStartingLine = CountString(FastMid(*NewContent\s, 1, ElementStartingPos), Chr(13)) + 1                ElementEndingPos = ElementEndingPos + ModNewEndPos - ModOldEndPos                ElementEndingLine = ElementStartingLine + CountString(FastMid(*NewContent\s, ElementStartingPos, ElementEndingPos - ElementStartingPos), Chr(13)) + 1                LineE$ = InsertValueIntoListLine(LineE$, Str(ElementStartingPos), #EL_StartingPos)                LineE$ = InsertValueIntoListLine(LineE$, Str(ElementEndingPos), #EL_EndingPos)                LineE$ = InsertValueIntoListLine(LineE$, Str(ElementStartingLine), #EL_StartingLine)                LineE$ = InsertValueIntoListLine(LineE$, Str(ElementEndingLine), #EL_EndingLine)                ;                ; On réintègre la ligne de définition mise à jour dans ListOfAllElements$() :                ListOfAllElements$(TypeOfElement) = FastLeft(ListOfAllElements$(TypeOfElement), pd - 1) + LineE$ + FastMid(ListOfAllElements$(TypeOfElement), pf)                pf - mLenLineE + Len(LineE$)                ;                If ListCompletionUsed(TypeOfElement) <> #ListCompletion_DoNot                  ; Si l'élément était utilisé, on met également ses positions à jour dans ListOfUsedElements$()                  UpdateUsedElementListFromAllElementList(pd, TypeOfElement)                EndIf                ;              ElseIf ElementStartingLine < ModStartingLine And ElementEndingPos >= ModStartPos                ;                ; Le début de l'élément est situé au-dessus de la zone modifiée, mais la fin                ; figure à l'intérieur ou après la zone modifiée. Il faut simplement ajuster sa                ; position de fin :                ElementEndingPos = ElementEndingPos + ModNewEndPos - ModOldEndPos                ElementEndingLine = ElementStartingLine + CountString(FastMid(*NewContent\s, ElementStartingPos, ElementEndingPos - ElementStartingPos), Chr(13)) + 1                LineE$ = InsertValueIntoListLine(LineE$, Str(ElementEndingPos), #EL_EndingPos)                LineE$ = InsertValueIntoListLine(LineE$, Str(ElementEndingLine), #EL_EndingLine)                ;                ; On réintègre la ligne de définition mise à jour dans ListOfAllElements$() :                ListOfAllElements$(TypeOfElement) = FastLeft(ListOfAllElements$(TypeOfElement), pd - 1) + LineE$ + FastMid(ListOfAllElements$(TypeOfElement), pf)                pf - mLenLineE + Len(LineE$)                ;                If ListCompletionUsed(TypeOfElement) <> #ListCompletion_DoNot                  ; Si l'élément était utilisé, on met également ses positions à jour dans ListOfUsedElements$()                  UpdateUsedElementListFromAllElementList(pd, TypeOfElement)                EndIf                ;              ElseIf (ElementStartingPos >= ModStartPos And ElementStartingPos <= ModOldEndPos) Or (ElementEndingPos >= ModStartPos And ElementEndingPos =< ModOldEndPos) Or (ModStartPos >= ElementStartingPos And ModStartPos =< ElementEndingPos) Or (ModOldEndPos >= ElementStartingPos And ModOldEndPos =< ElementEndingPos)                ; L'élément chevauche ou est inclus dans la zone modifiée.                ; Nous allons le supprimer.                ; Il sera éventuellement réintégré et mis-à-jour lors de l'analyse                ; du code modifié qui aura lieu un peu plus loin.                ;                ListOfAllElements$(TypeOfElement) = FastLeft(ListOfAllElements$(TypeOfElement), pd - 1) + FastMid(ListOfAllElements$(TypeOfElement), pf + 1)                pf - mLenLineE - 1                pd = pf + 1                ;                If StringField(LineE$, #EL_Parent, Chr(9))                  ; L'élément était noté comme 'Utilisé'. On ne supprime pas                  ; tout de suite sa copie dans la liste ListOfUsedElements$(TypeOfElement).                  ; Il devra fait l'objet d'un examen détaillé quand nous                  ; aurons terminé le repérage des éléments concernés par                  ; les modifications.                  mParentList\s + StringField(LineE$, #EL_ElementName, Chr(9)) + "/" + Str(TypeOfElement) + Chr(13)                EndIf                ;              EndIf            EndIf          EndIf        Until pf = -1        ;        ; On mémorise la position finale de chaque liste d'éléments :        ULOE_mPosInElementList(TypeOfElement) = Len(ListOfAllElements$(TypeOfElement))        ;      Next      ;      ; ___________________________________________________________________________________      ;      ; La suppression et la mise à jour des positions des éléments qui figuraient      ; dans l'ancien code est terminée.      ;      ; Nous allons maintenant utiliser le nouveau code pour créer / recréer      ; les éléments qu'il comporte :      ;      ;      If ModOldEndPos > ModStartPos And ModStartPos < EndExamOld        MissingInOld$ = FastMid(*OldContent\s, ModStartPos, ModOldEndPos - ModStartPos + 1)      EndIf      If ModNewEndPos > ModStartPos And ModStartPos < EndExamNew        AddedInNew$   = FastMid(*NewContent\s, ModStartPos, ModNewEndPos - ModStartPos + 1)        ; On demande une ré-exploration du fichier modifié entre les bornes ModStartPos et ModNewEndPos        ; afin d'intégrer les éléments définis dans la partie modifiée dans ListOfAllElements$().        ;        Protected Limits.Point\x = ModStartPos        Limits\y = ModNewEndPos        ;        SetAllListsOfAllElements(#FinishCompletionNow, FileName$, @Limits)        ;                     ; ______________________________________________________________________________________        ;        ; Mise à jour des références des éléments utilisés (#EL_Parent et ListOfUsedElements$())        ; ______________________________________________________________________________________        ;        ;        ; L'examen du nouveau code à permis de créer ou de recréer des éléments.        ;        ; Nous allons examiner en détail les éléments qui avaient été supprimés        ; et qui étaient notés comme 'utilisés'. S'ils ont été recréés, nous         ; allons remettre à jour leur champs #EL_Parent. S'ils n'ont pas été        ; recréés, nous allons les supprimer de la liste ListOfUsedElements$().        ;        ;        PosInPLList = 0        Repeat          PosInPLList + 1          mParent$ = StringField(mParentList\s, PosInPLList, Chr(13))          If mParent$            ElementNameLCase$ = LCase(StringField(mParent$, 1, "/"))            TypeOfElement     = Val(StringField(mParent$, 2, "/"))            ; On cherche la référence à l'élément dans la liste ListOfUsedElements$() :            CheckIfElementExistsInList(ListOfUsedElements$(TypeOfElement), ElementNameLCase$, TypeOfElement)            If ExistingElement = 0              AlertInPBBWindow("Program error : " + StringField(mParent$, 1, "/") + " had a parent but no ListOfUsedElements$() element corresponding.", "Error in UpdateListOfElement")            Else              UsedElementPos = ExistingElement              UsedElementEndPos = FindString(ListOfUsedElements$(TypeOfElement), Chr(13), UsedElementPos)            EndIf            ;            ; On cherche la référence à l'élément dans la liste actuelle des éléments :            CheckIfElementExistsInList(ListOfAllElements$(TypeOfElement), ElementNameLCase$, TypeOfElement)                        If ExistingElement              ; L'élément avait été supprimé, mais il a été recréé.              ; On met à jour son champs #EL_Parent en le récupérant              ; dans ListOfUsedElements$()              LineUsedElement$ = FastMid(ListOfUsedElements$(TypeOfElement), UsedElementPos, UsedElementEndPos - UsedElementPos)              Parent$ = StringField(LineUsedElement$, #EL_Parent, Chr(9))              ;              ; On extrait la ligne définissant l'élément dans ListOfAllElements$()              pf = FindString(ListOfAllElements$(TypeOfElement), Chr(13), ExistingElement)              If pf                LineNewElement$ = FastMid(ListOfAllElements$(TypeOfElement), ExistingElement, pf - ExistingElement)                ; On retire l'élément de la liste                ListOfAllElements$(TypeOfElement) = FastLeft(ListOfAllElements$(TypeOfElement), ExistingElement - 1) + FastMid(ListOfAllElements$(TypeOfElement), pf + 1)                ; On met à jour son champs #EL_Parent :                LineNewElement$ = InsertValueIntoListLine(LineNewElement$, Parent$, #EL_Parent)                ; On ré-intègre la ligne dans ListOfAllElements$() en prenant soin de le replacer                ; entre la partie de ListOfAllElements$() qui n'a pas été modifiée et les autres                ; éléments ajoutés lors de l'examen du nouveaux code.                ListOfAllElements$(TypeOfElement) = FastLeft(ListOfAllElements$(TypeOfElement), ULOE_mPosInElementList(TypeOfElement)) + LineNewElement$ + Chr(13) + FastMid(ListOfAllElements$(TypeOfElement), ULOE_mPosInElementList(TypeOfElement) + 1)                ; On décale ULOE_mPosInElementList() afin de réintégrer l'élément dans                ; la partie de liste non modifiée :                ULOE_mPosInElementList(TypeOfElement) + Len(LineNewElement$) + 1                ; Dans ListOfUsedElements$(), on remplace l'ancienne mention par la mention                ; réactualisée, afin de mettre à jour les positions de l'élément dans cette                ; liste également :                ListOfUsedElements$(TypeOfElement) = FastLeft(ListOfUsedElements$(TypeOfElement), UsedElementPos - 1) + LineNewElement$ + FastMid(ListOfUsedElements$(TypeOfElement), UsedElementEndPos)              EndIf            Else              ; L'élément a été supprimé, et il n'a pas été recréé.              ; On supprime la ligne correspondant dans ListOfUsedElements$()              ListOfUsedElements$(TypeOfElement) = FastLeft(ListOfUsedElements$(TypeOfElement), UsedElementPos - 1) + FastMid(ListOfUsedElements$(TypeOfElement), UsedElementEndPos + 1)              ; Il faudra noter comme non utilisés tous les éléments qui étaient utilisés par celui-ci.              ; On enregistre donc ses références dans NewMParentList$.              NewMParentList$ + mParent$ + Chr(13)            EndIf          EndIf        Until mParent$ = ""        mParentList\s = NewMParentList$      EndIf      ;      ; ___________________________________________________________________________________      ;      ;            Mise à jour des positions de référence des éléments utilisés      ; ___________________________________________________________________________________      ;      ;      ; Nous allons maintenant examiner les champs '#EL_Parent' de tous les éléments qui faisaient      ; référence à une ligne appartenant au fichier modifié.      ; Si la ligne citée en référence se situe après la partie du code qui a été modifiée,      ; on va mettre sa position à jour dans les éléments 'Enfants'. Si elle se situe à l'intérieur      ; du code modifié, on regarde si l'élément concerné est cité dans (s'il est utilisé par)      ; la nouvelle version du code.      ; Dans l'affirmative, on ajuste le numéro de ligne où il est cité.      ; Dans la négative, on note cet élément comme 'non-utilisé'.      ModStartingLine = CountString(FastMid(*OldContent\s, 1, ModStartPos - 1), Chr(13)) + 1      ModOldEndingLine = ModStartingLine + CountString(FastMid(*OldContent\s, ModStartPos, ModOldEndPos - ModStartPos + 1), Chr(13))      ModNewEndingLine = ModStartingLine + CountString(FastMid(*NewContent\s, ModStartPos, ModNewEndPos - ModStartPos + 1), Chr(13))      ;      NewCodeLCase.String\s = LCase(AddedInNew$)      ;      For TypeOfElement = 0 To (#EndEnumPBBElementTypes - 1)        PosInList = 0        Repeat          ;          ; On devrait théoriquement extraire la ligne de la liste, puis extraire          ; le champs #EL_Parent de cette ligne, puis regarder s'il fait référence          ; au fichier qui vient d'être modifié. Mais, pour gagner du temps, on          ; cherche directement le nom du fichier modifié encadré de slashs ("/"),          ; car on sait qu'une séquence de ce genre n'existe que dans le champs          ; #EL_Parent.          mPosInList = PosInList          ;          PosInList = FindString(ListOfAllElements$(TypeOfElement), "/" + FileName$ + "/", PosInList + 1)          ;          If PosInList            PosInList + Len("/" + FileName$ + "/")            pf = FindString(ListOfAllElements$(TypeOfElement), Chr(9), PosInList)            NoLigneRef = Val(FastMid(ListOfAllElements$(TypeOfElement), PosInList, pf - PosInList))            mLen = pf - PosInList            If ModOldEndingLine <> ModNewEndingLine And NoLigneRef > ModOldEndingLine              ; La ligne de référence se trouve après le code modifié.              ; On ajuste sa position :              NoLigneRef - ModOldEndingLine + ModNewEndingLine              ListOfAllElements$(TypeOfElement) = Left(ListOfAllElements$(TypeOfElement), PosInList - 1) + Str(NoLigneRef) + FastMid(ListOfAllElements$(TypeOfElement), pf)              ; Si le nouveau NoLigneRef n'a pas la même longueur que l'ancien,              ; on met PosInList à jour :              PosInList - mLen + Len(Str(NoLigneRef))              ; On met également à jour la liste 'ListOfUsedElements$(TypeOfElement)' :              UpdateUsedElementListFromAllElementList(PosInList, TypeOfElement)            ElseIf NoLigneRef >= ModStartingLine And NoLigneRef <= ModOldEndingLine              ; La ligne de référence se trouve à l'intérieur du code modifié.              If AddedInNew$                ; On va regarder si l'élément qu'elle permettait de valider figure encore                ; dans la nouvelle version du code.                ;                ; On commence par chercher les bornes de cet élément dans ListOfAllElements$() :                pf2 = FindString(ListOfAllElements$(TypeOfElement), Chr(13), PosInList)                If pf2 = 0                  pf2 = Len(ListOfAllElements$(TypeOfElement)) + 1                EndIf                pd2 = PosInList                While pd2 And FastMid(ListOfAllElements$(TypeOfElement), pd2, 1) <> Chr(13) : pd2 - 1 : Wend                pd2 + 1                ; On extrait la ligne de cet élément dans ListOfAllElements$() :                LineE$ = FastMid(ListOfAllElements$(TypeOfElement), pd2, pf2 - pd2)                LineE$ = InsertValueIntoListLine(LineE$, "", #EL_Parent)                ; On cherche une référence à cet élément dans la nouvelle version du code :                PosInCode = FindElementInCode(NewCodeLCase, LineE$, TypeOfElement)                If PosInCode                  ; L'élément est cité dans la version modifiée du code.                  ; Nous n'avons qu'à ajuster la ligne à laquelle la référence                  ; est trouvée :                  NoLigneRef = ModStartingLine + CountString(FastMid(NewCodeLCase\s, 1, PosInCode), Chr(13))                  ListOfAllElements$(TypeOfElement) = Left(ListOfAllElements$(TypeOfElement), PosInList - 1) + Str(NoLigneRef) + FastMid(ListOfAllElements$(TypeOfElement), pf)                  ; Si le nouveau NoLigneRef n'a pas la même longueur que l'ancien,                  ; on met PosInList à jour :                  PosInList - mLen + Len(Str(NoLigneRef))                  ; On met également à jour la liste 'ListOfUsedElements$(TypeOfElement)' :                  UpdateUsedElementListFromAllElementList(PosInList, TypeOfElement)                Else                  ; On supprime la référence et on note l'élément comme non-utilisé..                  PosInList = RegisterElementAsUnused(PosInList, TypeOfElement, mParentList)                EndIf              Else                ; On supprime la référence et on note l'élément comme non-utilisé..                PosInList = RegisterElementAsUnused(PosInList, TypeOfElement, mParentList)              EndIf            EndIf          EndIf        Until PosInList = 0 Or mPosInList = PosInList      Next      ;      If PosInList And mPosInList = PosInList        ; Cela est en principe impossible.        ; Cette vérification n'est là que pour le déboguage :        Alert("UpdateListOfElements() : Program error / Something is going wrong inside 'UpdateListOfElements()'.")        BackgroundTasksCompletion = #BackgroundTasksMustRestart        ProcedureReturn #False      EndIf      ;      ; ________________________________________________________________________________      ;      ;                 Mise à jour en cascade des éléments non-utilisés :      ; ________________________________________________________________________________      ;      ; On parcourt les éléments qui sont notés comme 'utilisés'. S'il sont utilisés      ; par un élément qui n'est plus mentionné dans la nouvelle partie du code et qui,      ; par conséquent, n'est plus utilisé, on va les noter comme 'non-utilisés', ainsi      ; que tous les éléments qui se référaient à eux.      ;      PosInPLList = 0      Repeat        PosInPLList + 1        mParent$ = StringField(mParentList\s, PosInPLList, Chr(13))        If mParent$          For TypeOfElement = 0 To (#EndEnumPBBElementTypes - 1)            PosInAEList = 0            Repeat              PosInAEList = FindString(ListOfAllElements$(TypeOfElement), Chr(9) + mParent$ + "/", PosInAEList + 1)              PosInAEList = RegisterElementAsUnused(PosInAEList, TypeOfElement, mParentList)              ; L'élement vient d'être ajouté par RegisterElementAsUnused()              ; à mParentList, ce qui fait qu'il sera testé à son tour pour              ; voir s'il avait des enfants à classer comme 'non-utilisés'.            Until PosInAEList = 0          Next        EndIf      Until mParent$ = ""      ;      ;      ; ________________________________________________________________________________      ;            If AddedInNew$        ;        ; ___________________________________________________________________________________        ;        ; Nous allons utiliser la nouvelle version du code modifié pour dresser la liste        ; des éléments qui y figurent et qui ne sont pas encore notés comme 'utilisés'.        ; Ceux-ci seront déplacés à la fin de la liste ListOfAllElements$(TypeOfElement)        ; afin d'être ensuite vérifiés.        ;        NewCodeLCase.String\s = LCase(AddedInNew$)        For TypeOfElement = 0 To (#EndEnumPBBElementTypes - 1)          PosInElementList = 0          Repeat ; On parcourt ListOfAllElements$(TypeOfElement) ligne par ligne.            mPosInElementList = PosInElementList + 1            PosInElementList = FindString(ListOfAllElements$(TypeOfElement), Chr(13), mPosInElementList)            If PosInElementList And PosInElementList <= ULOE_mPosInElementList(TypeOfElement)              ; On extrait la ligne de la liste ListOfAllElements$() :              LineE$ = FastMid(ListOfAllElements$(TypeOfElement), mPosInElementList, PosInElementList - mPosInElementList)              If StringField(LineE$, #EL_Parent, Chr(9)) = ""                ; Nous avons un élément qui n'est pas encore noté comme 'utilisé'                PosInCode = FindElementInCode(NewCodeLCase, LineE$, TypeOfElement)                If PosInCode                  ; Nous avons trouvé un élément utilisé dans la nouvelle partie du code.                  ; Malheureusement, nous ne pouvons pas l'enregistrer immédiatement comme                  ; 'utilisé', car nous venons d'analyser un simple extrait de code et nous                  ; ne sommes pas en mesure de définir les 'Parents' des éléments utilisés.                  ; On va donc se contenter de rejeter l'élément en fin de liste dans le                  ; tableau ListOfAllElements$().                  ; Ainsi, il fera partie des éléments ré-examinés lorsque nous                  ; mettrons la liste à jour pour ré-intégrer les éléments utilisés :                  ULOE_mPosInElementList(TypeOfElement) - Len(LineE$) - 1                  ListOfAllElements$(TypeOfElement) = FastLeft(ListOfAllElements$(TypeOfElement), mPosInElementList - 1) + FastMid(ListOfAllElements$(TypeOfElement), PosInElementList + 1) + LineE$ + Chr(13)                  PosInElementList = mPosInElementList - 1                EndIf              EndIf            EndIf          Until PosInElementList = 0        Next        ;        ;        ; Il faut à présent vérifier si tous les éléments que nous venons de (ré)ajouter        ; ou de rejeter à la fin des listes ListOfAllElements$() sont utilisés ou non.        ;        ; Nous allons faire appel à deux reprises à la procédure SetAllListsOfUsedElements() :        ; • Une première fois pour examiner s'il est fait mention des nouveaux éléments        ;   dans le code des anciens éléments.        ; • Une deuxième fois pour voir si les nouveaux éléments font mention des        ;   anciens éléments.        ;        ;        StageMustReboot = #True ; Pour s'assurer que ExecuteSerialCompletionsForUsedElements()                                ; redémarre au début d'un cycle dans ce qui va suivre.        ;        ;        ; ************************************************************************        ;        ;       Démarrage de la mise à jour partielle des éléments utilisés        ;        ; ************************************************************************        ; On enregistre dans une chaîne la liste des positions des éléments        ; non modifiés dans les listes ListOfAllElements$() et ListOfUsedElements$().        ; Cela va nous permettre d'optimiser l'exploration profonde qui va suivre,        ; et de n'examiner que les éléments nouveaux ou modifiés.        ;        ListPos$ = ""        For TypeOfElement = 0 To (#EndEnumPBBElementTypes - 1)          ; On fabrique une chaîne qui indiquera à SetAllListsOfUsedElements() quels          ; sont les éléments qu'il faudra (re)valider :          ListPos$ + "P" + Chr(9) + Str(TypeOfElement) + Chr(9) + Str(ULOE_mPosInElementList(TypeOfElement)) + Chr(13)           ; On en profite pour mémoriser la taille de ListOfUsedElements$(TypeOfElement)          ; avant que cette liste ne soit complétée :          ULOE_mPosInUsedElementList(TypeOfElement) = Len(ListOfUsedElements$(TypeOfElement))          ; On se replace en mode de complétion :          If ListCompletionUsed(TypeOfElement) = #ListCompletion_Done            ListCompletionUsed(TypeOfElement) = #ListCompletion_ExamAll          EndIf        Next        ;        ; L'examen qui va suivre va chercher des mentions des nouveaux        ; éléments (les éléments à valider comme 'utilisés) parmis        ; l'ensemble des éléments existants (y compris        ; le code 'hors-éléments') :        Result = SetAllListsOfUsedElements(#FinishCompletionNow, ListPos$)        If Result = #Completion_Error          Debug "Error in 'UpDateListOfElements()' - 1. Exploration will restart."          BackgroundTasksCompletion = #BackgroundTasksMustRestart          ProcedureReturn #False        EndIf        ;        ; Nous avons validé nos nouveaux éléments.        ; Il reste à voir si ces nouveaux éléments, lorsqu'ils        ; sont 'utilisés', peuvent eux-mêmes servir à valider        ; les éléments pré-existants comme étant 'utilisés'.        ;        ; On limite l'examen des éléments de référence aux        ; nouveaux éléments :        ;        nRef$ = ""        For TypeOfElement = 0 To (#EndEnumPBBElementTypes - 1)          If ListCompletionUsed(TypeOfElement) = #ListCompletion_Done            ; On relance la complétion :            ListCompletionUsed(TypeOfElement) = #ListCompletion_RebootFromTabRef          EndIf          nRef$ + Str(TypeOfElement) + Chr(9) + Str(ULOE_mPosInUsedElementList(TypeOfElement)) + Chr(13)        Next        For TypeOfElement = 0 To (#EndEnumPBBElementTypes - 1)          ListCompletionReference$(TypeOfElement) = nRef$        Next        ; Comme on ne fournit pas l'argument ListPos$, l'examen        ; qui va suivre va chercher à valider la totalité des        ; anciens éléments.        ; Mais, comme on a intégré dans ListCompletionReference$()        ; la position dans ListOfUsedElements$() avant l'ajout des        ; nouveaux éléments, les codes qui seront examinés pour        ; la validation seront seulement les codes des nouveaux        ; éléments.        Result = SetAllListsOfUsedElements(#FinishCompletionNow)        If Result = #Completion_Error          Debug "Error in 'UpDateListOfElements()' - 2. Exploration will restart."          BackgroundTasksCompletion = #BackgroundTasksMustRestart          ProcedureReturn #False        EndIf        ;        ; ************************************************************************        ;        ;      Préparation pour le redémarrage de l'exploration profonde :        ;         (si elle n'était pas achevée au moment où la présente        ;                     procédure a été appelée).        ;        ; ************************************************************************        ;        If BackgroundTasksCompletion <> #BackgroundTasksCompleted          For TypeOfElement = 0 To (#EndEnumPBBElementTypes - 1)            If ListCompletionUsed(TypeOfElement) = #ListCompletion_DoNot              ListCompletionUsed(TypeOfElement) = #ListCompletion_UnDone            EndIf          Next        EndIf        ;      EndIf    EndIf    CloseWaitingWindow()    ;    ;    If debugging      ; Pour les versions 'Beta' de PBBrowser, on vérifie      ; que tout s'est bien passé dans ce qui vient d'avoir      ; lieu.      tx$ = RunCheckAllListsOfElementsIntegrity(1)      If tx$        AlertInPBBWindow("Error in 'UpdateListOfElement()' (end) while updating " + GetFilePart(FileName$) + Chr(13) + Chr(13) + tx$)      EndIf    EndIf    ;        ProcedureReturn #True    ;  Else    ProcedureReturn #False  EndIf  ;EndProcedure;Procedure UpdateOneFileInMemory(FileName$, TestOnly = #False)  ;  ;  Cette procédure vérifie si le fichier FileName$ a été  ;  modifié sur disque depuis sa dernière lecture. Si tel est le cas, on met la  ;  mémoire à jour et l'on déclenche également une mise à jour des listes d'éléments  ;  ListOfAllElements$() et ListOfUsedElements$().  ;  Shared PBB_FileListing()  Shared ExactValueSearch  Shared RefreshEPanel  Protected OldContent.String  ;  If IsFileInMemory(FileName$)    If FindString(PBBListOfFiles$, FileName$ + Chr(9)) = 0      DeleteElement(PBB_FileListing(), 1)      EraseObsoleteElementsContents(FileName$)      ProcedureReturn #FileHasBeenDeleted    Else      ;      If GetFileDate(FileName$, #PB_Date_Modified) = PBB_FileListing()\FileLastModInList        ProcedureReturn #FileWasUpToDate      ElseIf TestOnly        ProcedureReturn #FileMustBeUpdated      Else        ; La date d'enregistrement du fichier a été modifiée. On la met à jour :        PBB_FileListing()\FileLastModInList = GetFileDate(FileName$, #PB_Date_Modified)        ; On efface les codes des éléments qui étaient en mémoire cache :        EraseObsoleteElementsContents(FileName$)        ; Et on regarde si le fichier lui-même a été modifié ou s'il a simplement été        ; ré-enregistré sans modifications :        OldContent\s = PBB_FileListing()\FileContentInList\s        PBB_FileListing()\FileContentInList\s = GetCodeFromFile(FileName$)        PBB_FileListing()\FileLCaseContentInList\s = "" ; Ce contenu sera regénéré en cas de besoin.        ;        ; 'UpdateListOfElements()' compare l'ancienne et la nouvelle version du fichier.        ; Si elle retourne '#True', c'est que le fichier a vraiment été modifié.        ; Dans ce cas, cette procédure se charge également de mettre à jour les tableaux        ; ListOfAllElements$() et ListOfUsedElements$() en fonction des modifications :        If UpdateListOfElements(OldContent, PBB_FileListing()\FileContentInList, FileName$)          ; Si le contenu a été modifié, on rafraîchit l'affichage des paneaux :          ExactValueSearch = #DoProgSearchAndPrintResult          RefreshEPanel  = #True          ;          ProcedureReturn #FileIsUpDated        Else          ProcedureReturn #FileWasUpToDate        EndIf      EndIf    EndIf  EndIf  ProcedureReturn #FileDoesntExistEndProcedure;Procedure UpdateAllFilesInMemory(TestOnly = #False)  ;  ; Cette procédure parcourt la liste des fichiers et  ; met la mémoire à jour en cas de modification de l'un d'eux.  ; S'il y a eu une modification, la valeur de retour est #FileIsUpDated.  ; #False est retourné dans le cas contraire.  ;  ; La mise à jour implique :  ; • Le contenu des fichiers en mémoire-cache,  ; • Les extraits de code concernant les éléments,  ; • Les tableaux d'éléments 'ListOfAllElements$()'  ;   et ListOfUsedElements$().  ;  Shared PBB_FileListing()  Shared SettingOutOfElementContent  Shared BackgroundTasksCompletion  ;  Protected RetValue = #False  Protected Cont = #True  Protected nPBBListOfFiles$, PosInFileList, LineC$, TypeOfElement  ;  ; On vérifie si l'un des fichiers de la liste PBBListOfFiles$  ; n'a pas été effacé du disque ou déplacé depuis le dernier appel,  ; et l'on met PBBListOfFiles$ à jour, le cas échéant.  If PBBListOfFiles$    nPBBListOfFiles$ = ""    PosInFileList = 0    Repeat       PosInFileList + 1      LineC$ = StringField(PBBListOfFiles$, PosInFileList, Chr(13))      If LineC$        If FileSize(StringField(LineC$, 1, Chr(9))) > 1          nPBBListOfFiles$ + LineC$ + Chr(13)        Else          ; Un fichier a été supprimé.          ; On demande à recommencer l'exploration :          FicPrincipalPB$ = SetListOfFiles(FicPrincipalPB$, #ShowCompletionWindow)          BackgroundTasksCompletion = #BackgroundTasksMustRestart        EndIf      EndIf    Until LineC$ = ""    PBBListOfFiles$ = nPBBListOfFiles$  EndIf  ;  ; Si plus aucun fichier n'est valide, on nettoie :  If PBBListOfFiles$ = "" And FicPrincipalPB$    FicPrincipalPB$ = ""    Protected FileREGadget = NoREGadgetOfPBBPanel(#FilePBBPanel)    If GetGadgetText(GPBBGadgets\Adr_gadget)      SetGadgetText(FileREGadget, "")      SetGadgetText(GPBBGadgets\Adr_gadget, "")      SetGadgetText(GPBBGadgets\SearchedExpression_gadget, "")      ExactValueSearch = #DoProgSearchAndPrintResult      RefreshEPanel  = #True    EndIf  Else    ; On ne peut procéder à une mise à jour partielle que si    ; la première phase d'exploration est terminée et si la    ; compilation du code 'hors-éléments" (OutOfElementContent\s)    ; est déjà terminée.    For TypeOfElement = 0 To (#EndEnumPBBElementTypes - 1)      If ListCompletionAll(TypeOfElement) < #ListCompletion_Done        Cont = #False        Break      EndIf    Next    ;    If Cont And SettingOutOfElementContent = #False And BackgroundTasksCompletion <> #BackgroundTasksMustRestart      If ListSize(PBB_FileListing())        ForEach PBB_FileListing()          If UpdateOneFileInMemory(PBB_FileListing()\FileNameInList$, TestOnly) <> #FileWasUpToDate            RetValue = #True          EndIf        Next      EndIf    EndIf  EndIf  ;  ProcedureReturn RetValueEndProcedure;Procedure EraseAllCodeInMemory()  ;  ; On nettoie la mémoire cache.  ;  Shared PBB_FileListing()  ;  If ListSize(PBB_FileListing())    ForEach PBB_FileListing()      DeleteElement(PBB_FileListing())    Next  EndIf  ;  Shared ElementContentListing()  ;  If ListSize(ElementContentListing())    ForEach ElementContentListing()      DeleteElement(ElementContentListing())    Next  EndIfEndProcedure;; **********************************************************************************;;        Procédures liées à la présentation des résultats dans les panneaux;; **********************************************************************************;#LineBreak$ = Chr(13) + "• ";Procedure.s ComputePrefix(*SearchString.String, SStrLength, PosInCode, NoLine$, Expression$, FileName$, TypeOfElement, Init = 0)  ;  ; Cette procedure n'est appelée que par la procédure 'SetListFoundInFiles'.  ; Elle a pour rôle de déterminer, pour une position donnée dans le code,  ; si nous sommes à l'intérieur d'un élément (une procédure, par exemple)  ; ou non.  ;   ; Le prefix de la ligne sera calculé en conséquence de ce qui a été trouvé.  ;  Shared ProcNameMem$  ;  Protected StartKeyWord$, EndKeyWords$, ElementName$  Protected StartOfElementPos, mStartOfElementPos  Protected CatTxt_CodeMismatchAlert$, pPar, TOE  Protected prefix$ ; Valeur de retour.  ;  If Init    ; On initialise un tableau qui va garder la trâce de ce que nous allons    ; trouver en menant la recherche qui va suivre. L'objectif est d'éviter    ; de refaire une recherche inutilement. Si nous constatons que nous    ; sommes encore à l'intérieur d'un élément que nous avons déjà    ; identifié, il n'est pas utile de le vérifier à nouveau.    Static Dim EndOfElementPosMem(#EndEnumPBBElementTypes - 1)    ; Même si nous utilisons 'Dim' et pas 'Redim', PureBasic    ; peut garder en mémoire les valeurs préalablement affectées    ; aux lignes du tableau. On les met donc à zéro.    For TOE = 0 To #EndEnumPBBElementTypes - 1      EndOfElementPosMem(TOE) = 0    Next    ProcNameMem$ = ""    ; On passe la chaîne à la procédure ReverseFindInPBCode()    ; qui va la mémoriser. Ainsi, nous n'aurons plus besoin    ; de le faire par la suite :    ReverseFindInPBCode(*SearchString\s, "", 0)  Else    ;    StartKeyWord$ = PBBTypeNames$(TypeOfElement)    If TypeOfElement = #PBBEnumeration      StartKeyWord$ + ",EnumerationBinary"    EndIf    EndKeyWords$ = "End" + PBBTypeNames$(TypeOfElement)    ;    If PosInCode > EndOfElementPosMem(TypeOfElement) And Expression$ <> EndKeyWords$      EndOfElementPosMem(TypeOfElement) = 0    EndIf    ;    If EndOfElementPosMem(TypeOfElement) = 0      ;      ; Jusqu'à présent, nous n'étions pas à l'intérieur d'un élément de type 'TypeOfElement'.      ;      ; Nous allons déterminer si nous nous venons d'entrer dans l'élément...      ;      ; Pour cela, nous cherchons simultanément le début et la fin de l'élément :      EndOfElementPosMem(TypeOfElement) = FindInPBPointedCode(*SearchString, StartKeyWord$ + "," + EndKeyWords$, PosInCode)      If EndOfElementPosMem(TypeOfElement)        ;        ; Si nous avons trouvé quelque chose, regardons s'il s'agit du début ou de la fin :        If EndOfElementPosMem(TypeOfElement) + Len(EndKeyWords$) <= SStrLength And FastMid(*SearchString\s, EndOfElementPosMem(TypeOfElement), Len(EndKeyWords$)) = EndKeyWords$          ; On a trouvé 'EndElement' avant de trouver 'Element'.          ; Nous allons donc chercher en amont le début de l'élément :          ;          ; La chaîne de recherche a été passée à ReverseFindInPBCode() au moment          ; de l'initialisation (voir plus haut). Nous n'avons plus besoin de le faire.          StartOfElementPos = ReverseFindInPBCode("", StartKeyWord$, PosInCode)          ;          If StartOfElementPos            mStartOfElementPos = StartOfElementPos            StartOfElementPos + 1            ; On cherche un séparateur après le nom du type de l'élément,            ; (après 'Procedure', par exemple).            StartOfElementPos = FirstOccurrenceOfCharPointed(*SearchString, " :;" + Chr(13), StartOfElementPos)            ;            ; Dans le cas des énumérations, nous ne savons pas si nous avons trouvé 'Enumeration' ou 'EnumerationBinary',            ; puisque nous avons cherché les deux en même temps. On va donc réajuster 'StartKeyWord$' avec la valeur trouvée.            If TypeOfElement = #PBBEnumeration              StartKeyWord$ = FastMid(*SearchString\s, mStartOfElementPos, StartOfElementPos - mStartOfElementPos)            EndIf            ;            ; Il faut que le séparateur trouvé après 'Element' soit un espace pour décider qu'un nom existe.            If StartOfElementPos And FastMid(*SearchString\s, StartOfElementPos, 1) = " "              ; On saute les espaces qui suivent :              While StartOfElementPos <= SStrLength And PeekC(@*SearchString\s + (StartOfElementPos - 1) * SizeOf(CHARACTER)) = 32 : StartOfElementPos + 1 : Wend              ;              ; On cherche à présent le premier séparateur après le nom de l'élément :              pPar = FirstOccurrenceOfCharPointed(*SearchString, " (;:" + Chr(13), StartOfElementPos)              If pPar And pPar - StartOfElementPos                ; On extrait le nom de l'élément :                ElementName$ = Trim(FastMid(*SearchString\s, StartOfElementPos, pPar - StartOfElementPos))              EndIf            EndIf            If ElementName$ = "" ; Les énumérations n'ont pas forcément un nom.              ; On en fabrique un :              ElementName$ = "UnNamed_Line_" + NoLine$            EndIf          Else            ; On a trouvé 'EndElement' sans parvenir à trouver 'Element' en amont.            ; Soit le code n'est pas conforme, soit notre programme s'est mélangé            ; les pinceaux.            NoLine$ = Str(CountString(Mid(*SearchString\s, 1, EndOfElementPosMem(TypeOfElement)), Chr(13)) + 1)            CatTxt_CodeMismatchAlert$ = GetTextFromCatalog("CodeMismatchAlert")            CatTxt_CodeMismatchAlert$ = ReplaceString(CatTxt_CodeMismatchAlert$, "%EndString$%", EndKeyWords$)            CatTxt_CodeMismatchAlert$ = ReplaceString(CatTxt_CodeMismatchAlert$, "%StartString$%", StartKeyWord$)            CatTxt_CodeMismatchAlert$ = ReplaceString(CatTxt_CodeMismatchAlert$, "%SearchString\s%", *SearchString\s)            CatTxt_CodeMismatchAlert$ = ReplaceString(CatTxt_CodeMismatchAlert$, "%nFile$%", FileName$)            AlertInPBBWindow(CatTxt_CodeMismatchAlert$ + Chr(13) + NoLine$)          EndIf        Else          ; Nous avons trouvé 'Element' avant de trouver 'EndOfElement'.          ; Nous sommes donc à l'extérieur d'un élément de type 'TypeOfElement'.          EndOfElementPosMem(TypeOfElement) = 0        EndIf      Else        ; Nous n'avons trouvé ni le début ni la fin d'un l'élément de type 'TypeOfElement'.        ; Nous sommes donc à l'extérieur d'un élément de ce type.        EndOfElementPosMem(TypeOfElement) = 0      EndIf    EndIf    ;    If TypeOfElement = #PBBProcedure Or TypeOfElement = #PBBMacro      If ElementName$        If TypeOfElement = #PBBProcedure          ProcNameMem$ = ElementName$          prefix$ = #LineBreak$ + "In" + Chr(160) + "Procedure" + Chr(160) + ElementName$ + "()"        Else          ProcNameMem$ = ""          prefix$ = #LineBreak$ + "In" + Chr(160) + "Macro" + Chr(160) + ElementName$ + " "        EndIf                ElseIf EndOfElementPosMem(#PBBProcedure) = 0 And EndOfElementPosMem(#PBBMacro) = 0 And ProcNameMem$ <> #OutOfElementsName        ; Nous sommes hors-procédure et hors-macro et nous n'avons pas encore mentionné        ; "OutOfElementsName" dans la ligne qui présente les résultats de recherche.        ProcNameMem$ = #OutOfElementsName        prefix$ = #LineBreak$ + ProcNameMem$      Else        prefix$ = ""      EndIf    ElseIf ElementName$      ; Nous venons tout juste d'entrer dans un élément de type 'TypeOfElement'.      If TypeOfElement = #PBBStructure Or TypeOfElement = #PBBEnumeration        If EndOfElementPosMem(#PBBProcedure) Or EndOfElementPosMem(#PBBMacro)          ; Les structures et le énumérations peuvent être déclarées à l'intérieur           ; de macros ou de procédures. Si tel est le cas, on n'ajoute pas de LineBreak$.          prefix$ = " In" + Chr(160) + StartKeyWord$ + Chr(160) + ElementName$ + " "        Else          prefix$ = #LineBreak$ + "In" + Chr(160) + StartKeyWord$ + Chr(160) + ElementName$ + " "        EndIf      Else        Alert("Unsupported Element in ComputePrefix: " + Str(TypeOfElement) + Chr(13) + StartKeyWord$)      EndIf    EndIf    ProcedureReturn prefix$  EndIfEndProcedure;Procedure.s SetListFoundInFiles(Expression$, Reset = 1)  ;  ; Cette procédure explore la liste des fichiers et note les positions auxquelles  ; l'expression 'Expression$' a été trouvée dans leurs codes.  ;  ; Elle est capable d'identifier l'élément dans lequel l'expression a été trouvée,  ; mais aussi, dans le cas ou 'Expression$' contient le nom d'une variable, si cette  ; variable se voit attribuer une valeur à cet endroit-là. Elle note également le  ; type de la déclaration qui est faite pour la variable (si un type est déclaré).  ;  ; CompleteListOfFiles doit avoir été appelée avant d'appeler cette procédure,  ; afin que la variable globale PBBListOfFiles$ soient renseignée.  ;  ; Les listes 'ListOfAllElements$()' et 'ListOfUsedElements$()' sont facultatives, même si  ; leur existence permet d'afficher un résultat plus détaillé.  ; Les choses ont été conçues de telle sorte que l'utilisateur puisse (presque) immédiatement  ; obtenir des informations pertinentes sur l'expression recherchées (ses positions dans le code,  ; en particulier), même si PBBrowser vient tout juste de démarrer et même si la machine sur  ; laquelle il fonctionne n'est pas très rapide.  ; Ensuite, plus les secondes passent, et plus les résultats affichés sont enrichis en détails.  ;  ; Cette procédure est conçue pour s'interrompre au bout de 100 ms. Elle sera appelée à répétition  ; par FillFoundInREGadget() qui affichera, au fur et à mesure, le résultat des recherches, jusqu'à  ; ce que la totalité du code ait été examinée.  ;  Shared ProcNameMem$ ; Variable mise à jour par 'ComputePrefixe()'.  Shared VarWithArguments  ;  ; On garde en mémoire de la progression à travers les fichiers :  Static *SearchString.String      ; Code sur lequel on travaille.  Static *SearchStringLCase.String ; Version LCase de la chaîne précédente.  Static SStrLength                ; Pour ne pas devoir recalculer la longueur de SearchString trop souvent.  Static PosInFileList, LineC$     ; Position dans la liste des fichiers et ligne en cours d'examen.  Static PosInCode                 ; Position dans le code.  ;  Protected FileName$, BatchListFoundInFiles$, PosAfter  Protected LineInProgress$, PreceedingChar$, PreceedingWord$  Protected StartTime, ExpressionLCase$, FirstLoopInFile, LineOfCode$, LenLOC, PosInCodeLine  Protected tPosAfter, InQuote, InParenthesis, Pos, CChar, BeforeExpression$, AfterEqual  Protected mBeforeExpression$, ppt, PosOfPreceedingWord, Declaration$, Element, variable  Protected Parametre, Argument, VDefine, Sprefix$, NoLine$, prefix$, PeekOrPoke$  Protected FollowedBy$, FirstWordInLine$  ;  If PBBListOfFiles$    ;    BatchListFoundInFiles$ = ""    StartTime = ElapsedMilliseconds()    ;    If Reset      PosInFileList = 0      PosInCode     = 0    EndIf    ;    ExpressionLCase$ = LCase(Expression$)    ;    Repeat       ; On parcout la liste des fichiers pour en récupérer le contenu.      If PosInCode = 0        PosInFileList + 1        LineC$ = StringField(PBBListOfFiles$, PosInFileList, Chr(13))        If LineC$          FileName$ = StringField(LineC$, 1, Chr(9))          ; On récupère les deux versions du code : en version originale,          ; et tout en minuscule.          *SearchString = GetPointedCodeFromFile(FileName$)          *SearchStringLCase = GetPointedCodeFromFile(FileName$, #True)          SStrLength = Len(*SearchString\s)          LineInProgress$ = ""          FirstLoopInFile = 1          PosInCode = 0          ;          ; On initialise les variables de 'ComputePrefix()' :          ComputePrefix(*SearchString, 0, 0, "", "", "", 0, 1)          ;        EndIf      EndIf      If LineC$        ;        Repeat          PosInCode = FindInPBPointedCode(*SearchStringLCase, ExpressionLCase$, PosInCode + 1, #CheckAll | #CheckOneKeyWordOnly)          If PosInCode            ; L'expression a été trouvée dans le code.            ; On va décider de quel genre d'expression il s'agit en fonction            ; de ce qui la précède et de ce qui la suit dans le code.            ;            ; À partir d'ici, on travaille avec *SearchString\s, alors que la recherche a été faite            ; sur *SearchStringLCase\s, mais cela ne pose pas de problème car les deux chaînes            ; sont strictement identique, hormis le fait que *SearchStringLCase\s est en minuscules.            ;            ; On récupère l'expression avec la casse utilisée à cet endroit du code :            Expression$ = FastMid(*SearchString\s, PosInCode, Len(Expression$))            ;            ; On extrait la partie de code comportant l'expression :            LineOfCode$ = ExtractSectionArroundExpression(*SearchString, Expression$, PosInCode)            If LineOfCode$              ;              LenLOC = Len(LineOfCode$)              ;              ; Position de l'expression dans l'extrait de code :              PosInCodeLine = FindInPBStringCode(LineOfCode$, Expression$)              ;              ; On commence par regarder ce qui suit :              PosAfter = PosInCodeLine + Len(Expression$)              ;              If PosAfter <= LenLOC And FastMid(LineOfCode$, PosAfter) = "." ; Si l'expression est suivie d'un point,                PosAfter + 1     ; on regarde après le point et après ce qui suit le point.                                 ; (pour sauter par-dessus les déclarations de type).                While PosAfter <= LenLOC And FindString(ListPBSep$, FastMid(LineOfCode$, PosAfter, 1)) = 0 : PosAfter + 1 : Wend              EndIf              ;              If VarWithArguments                ; Dans le cas des tableaux, listes et map, le caractère qui nous intéresse                ; est celui qui succède aux parenthèses. On va donc sauter par-dessus les                ; parenthèses en tenant compte du fait que l'argument inclu peut être                ; lui-même composé d'une fonction avec des parenthèses.                ;                tPosAfter = FindInPBStringCode(LineOfCode$, "(", PosAfter, #CheckOnlyComAndQuote | #CheckOneKeyWordOnly)                If tPosAfter                  InQuote = 0                  InParenthesis = 0                  For Pos = tPosAfter To Len(LineOfCode$)                    CChar = PeekC(@LineOfCode$ + (Pos - 1) * SizeOf(CHARACTER))                    If CChar = 34 ; Quote                      If InQuote = 1 : InQuote = 0 : Else : InQuote = 1 : EndIf                    EndIf                    If InQuote = 0                      If CChar = Asc("(")                        InParenthesis + 1                      ElseIf CChar = Asc(")")                        InParenthesis - 1                      EndIf                      If InParenthesis = 0                        PosAfter = Pos + 1                        Break                      EndIf                    EndIf                  Next                EndIf              EndIf              ;              ; On saute les espaces éventuels après l'expression trouvée :              While PosAfter <= LenLOC And PeekC(@LineOfCode$ + (PosAfter - 1) * SizeOf(CHARACTER)) = 32 : PosAfter + 1 : Wend              If PosAfter <= LenLOC                FollowedBy$ = FastMid(LineOfCode$, PosAfter, 1)  ; On extrait le premier caractère qui suit l'expression.              Else                FollowedBy$ = ""              EndIf              ;              ; On va maintenant regarder ce qu'il y a avant l'expression trouvée  en décorticant tout ce qui s'y trouve :              ;              BeforeExpression$ = ""              If PosInCodeLine > 1                BeforeExpression$ = Trim(FastMid(LineOfCode$, 1, PosInCodeLine - 1))              EndIf              If BeforeExpression$ = ""                PreceedingChar$ = Chr(13)                PreceedingWord$ = ""                FirstWordInLine$ = ""                AfterEqual = 0                InParenthesis = 0              Else                PreceedingChar$ = Right(BeforeExpression$, 1)                ;                AfterEqual = 0                InParenthesis = 0                InQuote = 0                ;                For Pos = 0 To Len(BeforeExpression$) - 1                  ; On remplace tous les caractères de séparation par des espaces,                  ; excepté le point (caractère ".") que l'on conserve.                  ; On remplace également tout le contenu des chaînes entre guillemets par des espaces,                  ; tout en comptant le nombre de parenthèses ouvrantes et fermantes,                  ; et tout en repérant la présence éventuelle du signe "=".                  CChar = PeekC(@BeforeExpression$ + Pos * SizeOf(CHARACTER))                  If CChar = 34 ; Guillemet.                    If InQuote = 0                      InQuote = 1                    Else                      InQuote = 0                      PokeC(@BeforeExpression$ + Pos * SizeOf(CHARACTER), 32)                    EndIf                  EndIf                  If InQuote                    PokeC(@BeforeExpression$ + Pos * SizeOf(CHARACTER), 32)                  Else                    If CChar = Asc("=") : AfterEqual = 1 : PokeC(@BeforeExpression$ + Pos * SizeOf(CHARACTER), 32)                    ElseIf CChar = Asc("(") : InParenthesis + 1 : PokeC(@BeforeExpression$ + Pos * SizeOf(CHARACTER), 32)                    ElseIf CChar = Asc(")") : InParenthesis - 1 : PokeC(@BeforeExpression$ + Pos * SizeOf(CHARACTER), 32)                    ElseIf FindString(ListPBSep$, Chr(CChar)) And CChar <> Asc(".") : PokeC(@BeforeExpression$ + Pos * SizeOf(CHARACTER), 32)                    EndIf                  EndIf                Next                ;                Repeat                  ; On supprime les doubles espaces :                  mBeforeExpression$ = BeforeExpression$                  BeforeExpression$ = ReplaceString(BeforeExpression$, "  ", " ")                Until mBeforeExpression$ = BeforeExpression$                ;                ; On mémorise le premier mot de 'BeforeExpression$'.                FirstWordInLine$ = StringField(BeforeExpression$, 1, " ")                ; C'est ici que nous éliminons le point et la déclaration de type qui suit :                ppt = FindString(FirstWordInLine$, ".")                If ppt : FirstWordInLine$ = Left(FirstWordInLine$, ppt - 1) : EndIf                ;                ; On cherche le dernier mot de 'BeforeExpression$'.                PosOfPreceedingWord = Len(BeforeExpression$)                FastFindPrecSpaces(BeforeExpression$, PosOfPreceedingWord)                PreceedingWord$ = FastMid(BeforeExpression$, PosOfPreceedingWord + 1)                ; C'est ici que nous éliminons le point et la déclaration de type qui suit :                ppt = FindString(PreceedingWord$, ".")                If ppt : PreceedingWord$ = Left(PreceedingWord$, ppt - 1) : EndIf                ;              EndIf              ;              Declaration$ = ""              ;              ; On regarde si l'expression trouvée est un argument ou un paramètre,              ;              Element = 0              variable = 0              Parametre = 0              Argument = 0              VDefine = 0              ;              ; NoREGadget    GetImageNameFromSelectionPos              ;              If InParenthesis                If FirstWordInLine$ = "Procedure" Or FirstWordInLine$ = "Macro"                  Parametre = 1                Else                  Argument = 1                EndIf              EndIf              ;              ; Si l'expression est déclarée à la position trouvée, on mémorise sa déclaration.              If Argument = 0                If FindString(" Procedure, Declare, Structure, Macro, Enumeration,", " " + PreceedingWord$ + ",", 0, #PB_String_NoCase)                  Declaration$ = #LineBreak$ + PreceedingWord$ + " ▷ "                  Element = 1                ElseIf FindString(" Define, Global, Protected, Static, Shared, ReDim, Dim, NewList, NewMap,", " " + PreceedingWord$ + "," , 0 , #PB_String_NoCase)                  Declaration$ = PreceedingWord$ + " "                  Variable = 1                  If FindString("ReDim, Dim, NewList, NewMap", PreceedingWord$)                    VarWithArguments = 1                  EndIf                EndIf                ;                If AfterEqual = 0 And FindString(" Define, Global, Protected, Static, Shared,", " " + FirstWordInLine$ + "," , 0 , #PB_String_NoCase)                  VDefine = 1                EndIf                ;                If VDefine Or FindString(" Dim, NewList, NewMap,", " " + FirstWordInLine$ + "," , 0 , #PB_String_NoCase)                  If FirstWordInLine$ <> PreceedingWord$                    Declaration$ = FirstWordInLine$ + " " + Declaration$                  EndIf                  Variable = 1                EndIf                If Declaration$ And Right(Declaration$, 1) <> " "                  Declaration$  + " "                EndIf              EndIf              ;              If Variable = 0  And FindString(".=+-*/", FollowedBy$) And (PreceedingChar$ = Chr(13) Or PreceedingChar$ = "\")                Variable = 1              EndIf              ;              ;              If PreceedingWord$ <> "Procedure" And PreceedingWord$ <> "Macro" And PreceedingWord$ <> "Declare"                 ;                ; Nous ne sommes pas dans une déclaration de procédure ou de macro.                ; On va regarder si l'expression figure à l'intérieur d'un élement.                ;                ; On regarde si l'on a trouvé l'expression à l'intérieur d'une procédure.                Sprefix$ = ComputePrefix(*SearchString, SStrLength, PosInCode, NoLine$, Expression$, FileName$, #PBBProcedure)                ; Si nous sommes hors-procédure et que cela n'a pas encore été dit,                ; Sprefix$ comporte à présent la mention #OutOfElementsName                ;                If ProcNameMem$ = #OutOfElementsName Or ProcNameMem$ = ""                  ; On regarde si l'on a trouvé l'expression à l'intérieur d'une structure, d'une énumération ou d'une macro.                  prefix$ = ""                  If PreceedingWord$ <> "Structure"                    prefix$ = ComputePrefix(*SearchString, SStrLength, PosInCode, NoLine$, Expression$, FileName$, #PBBStructure)                  EndIf                  If prefix$ = "" And PreceedingWord$ <> "Enumeration"                    prefix$ = ComputePrefix(*SearchString, SStrLength, PosInCode, NoLine$, Expression$, FileName$, #PBBEnumeration)                  EndIf                  If prefix$ = "" And PreceedingWord$ <> "Macro"                    prefix$ = ComputePrefix(*SearchString, SStrLength, PosInCode, NoLine$, Expression$, FileName$, #PBBMacro)                  EndIf                  If prefix$ = "" And (Element = 0 Or ProcNameMem$ <> #OutOfElementsName)                    prefix$ = Sprefix$                  Else                    ProcNameMem$ = ""                  EndIf                Else                  prefix$ = Sprefix$                EndIf                If prefix$ And Right(prefix$, 1) <> " "                  prefix$  + " "                EndIf              Else                prefix$ = ""              EndIf              ;              If FirstWordInLine$ = "ProcedureReturn"                prefix$ + "Return➭"              EndIf              ;              If FirstWordInLine$ And FindString(" If, ElseIf, While, For, Case, Until, Select,", " " + FirstWordInLine$ + ",")                prefix$ + "Test➭"              EndIf              ;              PeekOrPoke$ = Left(PreceedingWord$, 4)              If PeekOrPoke$ = "Poke" Or PeekOrPoke$ = "Peek"                prefix$ + PeekOrPoke$ + "➭"              EndIf              ;              If PreceedingWord$ = "Read"                prefix$ + "Read" + "➭"              EndIf              ;              If Parametre                Declaration$ + "Param➭"              Else                If Argument Or (VDefine = 0 And (PreceedingChar$ = "(" Or PreceedingChar$ = ","))                  If PeekOrPoke$ <> "Poke" And PeekOrPoke$ <> "Peek"                    prefix$ + "Arg➭"                  EndIf                EndIf              EndIf              ;              If PreceedingWord$ = "For" Or (variable And (FollowedBy$ = "=" Or FollowedBy$ = "+" Or FollowedBy$ = "-") And AfterEqual = 0)                If Declaration$                  Declaration$ + "& Set➭"                Else                  Declaration$ + "Set➭"                EndIf              EndIf              ;              NoLine$ = Str(CountString(FastMid(*SearchString\s, 1, PosInCode), Chr(13)) + 1)              LineInProgress$ + prefix$ + Declaration$ + "(" + NoLine$ + "), "              ;            EndIf          EndIf        Until PosInCode = 0 Or (ElapsedMilliseconds() - StartTime) > 100        ;        If LineInProgress$          LineInProgress$ = ReplaceString(LineInProgress$, ", " + Chr(13), Chr(13))          ; On place Chr(160) (espace insécable), juste après le nom du fichier.          ; Cela servira de point de repère dans 'ClickOverREGadget'.          If FirstLoopInFile            If Right(BatchListFoundInFiles$, 2) = ", "              BatchListFoundInFiles$ = FastLeft(BatchListFoundInFiles$, Len(BatchListFoundInFiles$) - 2)            EndIf            BatchListFoundInFiles$ + Chr(13) + GetFilePart(FileName$) + Chr(160)            FirstLoopInFile = 0          EndIf          BatchListFoundInFiles$ + LineInProgress$          LineInProgress$ = ""        EndIf      EndIf    Until LineC$ = "" Or (ElapsedMilliseconds() - StartTime) > 100  EndIf  ;  If LineC$ <> "" And BatchListFoundInFiles$ = ""    ; L'expression n'a pas encore été trouvée, mais tous les fichiers    ; n'ont pas été explorés. On retourne 'Pending' pour indiquer    ; qu'il ne faut pas en rester là.    BatchListFoundInFiles$ = "Pending"  EndIf  ;  ProcedureReturn BatchListFoundInFiles$EndProcedure;Procedure UnderLineFNamesAndLinks(NoREGadget, posdep = 0, *REContent.String = 0, DontUnderlineNumbers = 0)  ;  ; Examine le contenu du gadget RichEdit 'NoREGadget' et attribue le style 'souligné'  ; aux chiffres entre parenthèses, aux noms de fichiers qui figurent dans PBBListOfFiles$,  ; et aux 'custom links' qui figurent dans la variable partagée 'PBBCustomLinks$'.  ;  ; Cette procédure attribue également une couleur particulière aux mentions 'Set'  ; Return> et Param> qui figurent dans le texte.  ;  Shared PBBCustomLinks$  Protected PosInCode, pf, PosInFileList, LineC$, FileName$, REContent.String  Protected pd, mention$, nl, CustomLinksLine$  Protected *TextFontObjet.ITextFont_Fixed  ;  If *REContent = 0    ; On crée un espace mémoire pour *REContent.    *REContent = @REContent.String    ;    *REContent\s = LCase(ReplaceString(TOM_GetText(NoREGadget, "", 0, -1), Chr(10), "") + Chr(13))    ; Voir les explications données dans la procédure 'ColorizeBasicKeyWords'.  EndIf  ;  If *REContent\s    If DontUnderlineNumbers = 0       ; On souligne les numéros de lignes entre parenthèses.      PosInCode = posdep - 1      Repeat        PosInCode = FindString(*REContent\s, "(", PosInCode + 1)        If PosInCode          PosInCode + 1          pf = FindString(*REContent\s, ")", PosInCode)          If pf And Val(FastMid(*REContent\s, PosInCode, pf - PosInCode))            *TextFontObjet = TOM_GetTextFontObj(NoREGadget, PosInCode - 1, pf - 1)            *TextFontObjet\SetUnderline(#TomSingle)            *TextFontObjet\Release()          EndIf        EndIf      Until PosInCode = 0    EndIf    ;    ;    ; On colorie les mentions "Set>", "Return>", "Param>", etc.    PosInCode = posdep - 1    Repeat      PosInCode = FindString(*REContent\s, "➭", PosInCode + 1)      If PosInCode        pd = PosInCode        FastFindPrecSpaces(*REContent\s, pd)        mention$ = FastMid(*REContent\s, pd + 1, PosInCode - pd - 1)        If FindString(mention$, "set") Or FindString(mention$, "read") Or FindString(mention$, "param") Or FindString(mention$, "ret") Or FindString(mention$, "poke")          *TextFontObjet = TOM_GetTextFontObj(NoREGadget, pd, PosInCode - 1)          *TextFontObjet\SetBold(#TomTrue)          *TextFontObjet\SetForeColor(SetValueColor)          *TextFontObjet\SetWeight(600)          *TextFontObjet\Release()       EndIf      EndIf    Until PosInCode = 0    ;    ;    ; On souligne les nom de fichiers trouvés dans PBBListOfFiles$.    ;    If PBBListOfFiles$      PosInFileList = 0      Repeat         PosInFileList + 1        LineC$ = StringField(PBBListOfFiles$, PosInFileList, Chr(13))        If LineC$          FileName$ = LCase(GetFilePart(StringField(LineC$, 1, Chr(9))))          PosInCode = posdep - 1          Repeat            PosInCode = FindString(*REContent\s, FileName$, PosInCode + 1)            If PosInCode              PosInCode - 1 : If PosInCode < 0 : PosInCode = 0 : EndIf              pf = PosInCode + Len(FileName$)              *TextFontObjet = TOM_GetTextFontObj(NoREGadget, PosInCode, pf)              *TextFontObjet\SetForeColor(0)              *TextFontObjet\SetUnderline(#TomSingle)              *TextFontObjet\Release()              PosInCode = pf            EndIf          Until PosInCode = 0        EndIf      Until LineC$ = ""    EndIf    ;    ; On souligne les 'CustomLinks', s'il y en a.    ;    nl = 0    Repeat      nl + 1      CustomLinksLine$ = LCase(StringField(PBBCustomLinks$, nl, Chr(13)))      If CustomLinksLine$        PosInCode = FindString(*REContent\s, CustomLinksLine$, posdep)        If PosInCode          PosInCode - 1 : If PosInCode < 0 : PosInCode = 0 : EndIf          pf = PosInCode + Len(CustomLinksLine$)          *TextFontObjet = TOM_GetTextFontObj(NoREGadget, PosInCode, pf)          *TextFontObjet\SetUnderline(#TomSingle)          *TextFontObjet\Release()        EndIf      EndIf    Until CustomLinksLine$ = ""  EndIfEndProcedure;Procedure PBBRichEditCallback(hWnd, Msg, wParam, lParam)  ;  ; Intercepte les 'Events' d'un RichEditor Gadget et remplace le curseur  ; de texte par une flèche (curseur standard).  ; Les 'Events' de type '#WM_LBUTTONUP' et '#WM_RBUTTONUP' sont  ; interceptés pour mettre à jour les variables 'PBBRichEditMessage'  ; 'PBBREGadgetID' et 'RangeOfClic'.  ; Les 'Events' de type '#WM_LBUTTONDBLCLK' sont annulés car la gestion  ; du double-click sera faite dans la boucle principale de 'PBBrowserMainProc()'.  ; Les autres 'Events' ne sont pas modifiés, mais on en profite  ; pour masquer le curseur clignotant du gadget.  ;  Shared OldREProc, PBBRichEditMessage, RangeOfClic.CHARRANGE, PBBREGadgetID  ;  Protected txtrange.CHARRANGE  ;  If Msg = #WM_LBUTTONUP Or Msg = #WM_RBUTTONUP    If Msg = #WM_RBUTTONUP      ; On fait en sorte de gérer #WM_RBUTTONUP comme #WM_LBUTTONUP      CallWindowProc_(OldREProc, hWnd, #WM_RBUTTONUP, wParam, lParam)      CallWindowProc_(OldREProc, hWnd, #WM_LBUTTONDOWN, wParam, lParam)    EndIf    ; On laisse OldProc calculer la sélection correspondante.    CallWindowProc_(OldREProc, hWnd, #WM_LBUTTONUP, wParam, lParam)    ; On récupère la sélection    SendMessage_(hWnd, #EM_EXGETSEL, 0, @RangeOfClic)    ;    PBBRichEditMessage = Msg ; Pour signaler #WM_LBUTTONUP ou #WM_RBUTTONUP                             ; à la procédure principale.    PBBREGadgetID = hWnd    ProcedureReturn #True  ElseIf Msg = #WM_LBUTTONDOWN Or Msg = #WM_RBUTTONDOWN    SendMessage_(hWnd, #EM_HIDESELECTION, #False, 0)    ;  ElseIf Msg = #WM_LBUTTONDBLCLK Or Msg = #WM_RBUTTONDBLCLK    PBBRichEditMessage = #WM_LBUTTONDBLCLK    PBBREGadgetID = hWnd    ProcedureReturn #True    ;  ElseIf Msg = #WM_SETCURSOR    ; On affiche le curseur flèche    SetCursor_(PBBDefaultCursor)    ; On masque le curseur, puisque nos gadgets sont 'Read Only',    ; mais on laisse la sélection affichée, si elle a une taille    ; supérieure à 0.    SendMessage_(hWnd, #EM_EXGETSEL, 0, @txtrange)    If txtrange\cpMin = txtrange\cpMax      SendMessage_(hWnd, #EM_HIDESELECTION, #True, 0)    Else      SendMessage_(hWnd, #EM_HIDESELECTION, #False, 0)    EndIf    ; Ici, on retourne sans appeler 'OldREProc'.    ProcedureReturn #True    ;  EndIf  ; Ici, on appel 'OldREProc' pour gérer tous les autres 'Events'.  ProcedureReturn CallWindowProc_(OldREProc, hWnd, Msg, wParam, lParam)EndProcedure;Procedure SetREGadgetParam(NoREGadget)  ;  ; Définit les attributs des gadget RicheEdit des divers panneaux.  ;  Shared OldREProc  ;  SetGadgetColor(NoREGadget, #PB_Gadget_BackColor, GetValueFromBPPrefFile("BackgroundColor"))  SendMessage_(GadgetID(NoREGadget), #EM_SETTARGETDEVICE, #Null, 0);<<--- Automatic carriage return.  SendMessage_(GadgetID(NoREGadget), #EM_LIMITTEXT, -1, 0)             ; Set unlimited content size.  SendMessage_(GadgetID(NoREGadget), #EM_SETTEXTMODE, #TM_RICHTEXT, 0) ; Set gadget to 'RichEdit' type.  ; On met en place une procédure qui va intercepter les 'Events' du gadget.  ; pour afficher un curseur flèche (curseur standard) au-dessus des REGadgets.  OldREProc = SetWindowLongPtr_(GadgetID(NoREGadget), #GWL_WNDPROC, @PBBRichEditCallback())  ;EndProcedure;Procedure ReSizeREMenu()  ;  ; (Re)positionne le menu burger des panneaux.  ;  Protected REGadget  Protected REMenuX = GadgetX(GPBBGadgets\MainPanelGadget) + GadgetWidth(GPBBGadgets\MainPanelGadget) - 27  ;  REGadget = GetREGadgetNbrFromActivePBBPanel()  If REGadget    If GetWindowLong_(GadgetID(REGadget), #GWL_STYLE) & #WS_VSCROLL      ; L'ascenseur est visible. On décale le bouton vers la gauche.      REMenuX - 18    EndIf  EndIf  Protected REMenuY = GadgetY(GPBBGadgets\MainPanelGadget) + 26  If GetActivePBBPanel() >= #ProcPBBPanel    REMenuX - 4    REMenuY + 24  EndIf  ResizeGadget(GPBBGadgets\BREMenu, REMenuX, REMenuY, #PB_Ignore, #PB_Ignore)EndProcedure;Procedure FillFileREGadget()  ;  ; Rempli un Gadget RichEdit avec la liste des fichiers figurant dans PBBListOfFiles$.  ;  ; Avant l'appel de cette procédure, PBBListOfFiles$ doit avoir été déclarée   ; et doit contenir la liste des fichiers liés au fichier principal.  ; CompleteListOfFiles() s'est normalement occupé de ça.  ;  Shared TFileLength  ;  Protected PosInFileList, LineC$, Adr$, Result$, FileREGadget  Protected ContenerFile$, Intro$  ;  TFileLength = 0  Result$ = ""  If PBBListOfFiles$    PosInFileList = 0    Repeat       PosInFileList + 1      LineC$ = StringField(PBBListOfFiles$, PosInFileList, Chr(13))      If LineC$        Adr$ = StringField(LineC$, 1, Chr(9))        TFileLength + FileSize(Adr$)        ContenerFile$ = GetFilePart(StringField(LineC$, 2, Chr(9)))        If ContenerFile$ = ""          ContenerFile$ = "(" + GetTextFromCatalog("mainFile") + ")"        Else          ; On gère les espaces insécables afin que la mention "inclus par 'NomDuFichier'" soit          ; rejetée d'un bloc à la ligne, lorsque la largeur de fenêtre ne permet pas de tout          ; afficher sur la même ligne.          ContenerFile$ = ReplaceString(GetTextFromCatalog("includedBy"), " ", Chr(160)) + Chr(160) + ContenerFile$        EndIf        Result$ + GetFilePart(StringField(LineC$, 1, Chr(9))) + " " + ContenerFile$ + Chr(13)      EndIf    Until LineC$ = ""  EndIf  If Result$    Intro$ = GetTextFromCatalog("IncludedFilesIntro")    Result$ = Intro$ + Chr(13) + Result$  EndIf  FileREGadget = NoREGadgetOfPBBPanel(#FilePBBPanel)  PBB_SuspendRedraw(FileREGadget, #True)  SetGadgetText(FileREGadget, Result$)  TOM_SetFontStyles(FileREGadget, "Bold, ForeColor(" + Str(PBBTitleColor) + ")", 0, Len(Intro$))  TOM_SetParaStyles(FileREGadget, "SpaceAfter(10)", 0, Len(Intro$))  ;    UnderLineFNamesAndLinks(FileREGadget)  PBB_SuspendRedraw(FileREGadget, #False)  ReSizeREMenu()EndProcedure;Procedure FillElementREGadget(TypeOfElement)  ;  ; Rempli un Gadget RichEdit avec la liste des éléments figurant dans ListOfAllElements$(TypeOfElement).  ;  ; Avant l'appel de cette procédure, ListOfUsedElements$(TypeOfElement) doit avoir été déclarée  ; comme variable globale et doit contenir la liste des éléments.  ; Les procédures SetOneListOfAllElements() et/ou CompleteListOfUsedElements() se sont normalement occupé de ça.  ; PBBListOfFiles$ doit avoir été déclarée et doit contenir la liste des fichiers liés  ; au fichier principal. SetListOfFiles() s'est normalement occupé de ça.  ;  Protected tnl, PosInElementList, LineDP$, Result$, txa$, NoREGadget  Protected MSpecies$, MSubSpecies$, Species$, SubSpecies$  Protected EName$, SetInBold$, PosInCode, pf  Protected TOE, Pos  Protected scrollPos.Point ; Position de l'ascenseur avant le ré-affichage du contenu.  ;  If ListCompletionAll(TypeOfElement) = #ListCompletion_Done    ; On cherche le numéro du REGadget correspondant à TypeOfElement.    For TOE = 0 To (#EndEnumPBBPanels - 1)      If TypeElementOfPBBPanel(TOE) = TypeOfElement        NoREGadget = NoREGadgetOfPBBPanel(TOE)      EndIf    Next    ;    If NoREGadget = 0      ; Cela ne devrait pas arriver ! On a donc une erreur de conception du programme.      txa$ = GetTextFromCatalog("UnfoundGadgetNumber") + PBBTypeNames$(TypeOfElement)      AlertInPBBWindow(txa$)    Else      SendMessage_(GadgetID(NoREGadget), #EM_GETSCROLLPOS, 0, @scrollPos)    EndIf    ;    tnl = CountString(ListOfAllElements$(TypeOfElement), Chr(13))    If tnl      Protected Dim pLine$(tnl)      PosInElementList = 0      Repeat         PosInElementList + 1        LineDP$ = StringField(ListOfAllElements$(TypeOfElement), PosInElementList, Chr(13))        If LineDP$          If TypeOfElement = #PBBVariable            pLine$(PosInElementList) = StringField(LineDP$, #EL_VariableSpecies, Chr(9)) + " " + StringField(LineDP$, #EL_ElementName, Chr(9))          Else            pLine$(PosInElementList) = StringField(LineDP$, #EL_ElementName, Chr(9))          EndIf        EndIf      Until LineDP$ = ""      PosInElementList - 1      ;      ; Tri alphabétique de la liste :      ;      SortArray(pLine$(), #PB_Sort_NoCase)      ;      ; Remplissage du gadget :      ;      Result$ = ""      MSpecies$ = ""      MSubSpecies$ = ""      For Pos = 1 To PosInElementList                If TypeOfElement = #PBBProcedure          Result$ + pLine$(Pos) + "()"        ElseIf TypeOfElement = #PBBVariable          Species$ = StringField(pLine$(Pos), 1, " ")          SubSpecies$ = StringField(pLine$(Pos), 2, " ")          EName$ = StringField(pLine$(Pos), 3, " ")          ;          If Species$ <> MSpecies$            If Result$              Result$ + Chr(13)            EndIf            Result$ + Species$ + Chr(13)            Result$ + " • " + SubSpecies$ + Chr(13)            MSpecies$    = Species$            MSubSpecies$ = SubSpecies$          ElseIf SubSpecies$ <> MSubSpecies$            Result$ + Chr(13) + " • " + SubSpecies$ + Chr(13)            MSubSpecies$ = SubSpecies$          EndIf          Result$ + "   " + EName$        Else          Result$ + pLine$(Pos)        EndIf        If SubSpecies$ = "Array" Or SubSpecies$ = "List"          Result$ + "()"        EndIf        If Pos <> PosInElementList          Result$ + Chr(13)        EndIf      Next      ;      ; On suspend l'affichage dans le gadget pour éviter le scrolling.      PBB_SuspendRedraw(NoREGadget, #True)      ;      SetGadgetText(NoREGadget, ReplaceString(Result$, Chr(13), #CRLF$))      ;            TOM_SetFontStyles(NoREGadget, "ForeColor(0)", 0, Len(Result$))      ;      ; Mise en couleur et soulignement des noms d'éléments.      ;      ColorizeElementsNames(NoREGadget, 0, 0, #ListPBBPanel)      ;      If TypeOfElement = #PBBVariable        ;        SetInBold$ = "Global,Shared,Array,List,Var"        ;        For Pos = 1 To 5          PosInCode = 0          Repeat            PosInCode = FindInPBStringCode(Result$, StringField(SetInBold$, Pos, ","), PosInCode + 1)            If PosInCode              pf = PosInCode + Len(StringField(SetInBold$, Pos, ","))              TOM_SetFontStyles(NoREGadget, "Bold", PosInCode - 1, pf)            EndIf          Until PosInCode = 0        Next      EndIf      ;      ; On remet l'ascenseur à sa position de départ:      SendMessage_(GadgetID(NoREGadget), #EM_SETSCROLLPOS, 0, @scrollPos)      ; On rétabli l'affichage dans le gadget.      PBB_SuspendRedraw(NoREGadget, #False)      ;    Else      SetGadgetText(NoREGadget, GetTextFromCatalog("NoElementFound"))    EndIf    ;  EndIf  ;  ListCompletionAll(TypeOfElement) = #ListCompletion_Printed  ReSizeREMenu()EndProcedure;Procedure ManageSearchHistoryButtons(SExpression$, NoREGadget)  ;  ; Met à jour l'historique de navigation au moment de l'affichage d'une page.  ; Affiche également les boutons [<-] et [->] dans le gadget 'NoREGadget'.  ;  ; Cette procédure est appellée par FillDetailREGadget() et FillFoundInREGadget().  ;  Shared ListOfResultPages$, PosInListOfPages, NextOrPreviewAsked ; Pour la navigation dans l'historique de recherche.  ;  Protected PosInList, NewListOfResultPages$, Pos  Protected SepSpace$, IButton$, BMarker$, TotLen                            ;  If NextOrPreviewAsked    NextOrPreviewAsked = 0  Else    ; Nous allons afficher une nouvelle page    ; qui ne figurait pas dans l'historique des pages affichées.    ;    PosInList = FindString(Chr(13) + ListOfResultPages$, Chr(13) + SExpression$ + Chr(9))    If PosInList = 0      NewListOfResultPages$ = "" ; On va recalculer l'historique.      For Pos = 1 To PosInListOfPages        ; On prend ce qu'il y a avant la position courante.        NewListOfResultPages$ + StringField(ListOfResultPages$, Pos, Chr(13)) + Chr(13)      Next      ; On l'insère dans l'historique, à la position courante (PosInListOfPages).      NewListOfResultPages$ + SExpression$ + Chr(9) + Chr(13)      For Pos = PosInListOfPages + 1 To CountString(ListOfResultPages$, Chr(13))        ; On prend ce qu'il y a après la position courante.        NewListOfResultPages$ + StringField(ListOfResultPages$, Pos, Chr(13)) + Chr(13)      Next      ListOfResultPages$ = NewListOfResultPages$ ; On rafraîchit l'historique.      PosInListOfPages + 1    Else      PosInListOfPages = CountString(Mid(ListOfResultPages$, 1, PosInList), Chr(13)) + 1    EndIf  EndIf  ;  ; Affichage des boutons '<< Previous' et 'Next >>' :  ;  SepSpace$ = "  "  PBB_SuspendRedraw(NoREGadget, #True) ; On suspend l'affichage dans le Gadget,                                      ; pour éviter le scrolling, au fur et à mesure                                      ; des mises en couleur.                                      ;  TOM_InsertText(NoREGadget, "", 0, -1) ; On supprime l'ancien contenu  ;  If PosInListOfPages > 1    IButton$ = "Previous.jpg"    ; On insère un marqueur dans l'image pour savoir sur quoi l'utilisateur    ; a cliqué lorsqu'il clique sur cette image-bouton.    BMarker$ = #PBBRTFMarker$ + #PBBLeftArrowMarker$  Else    IButton$ = "NoPrevious.jpg" ; (bouton inactif).    BMarker$ = ""  EndIf  ;  If OSVersion() <= #PB_OS_Windows_Server_2008_R2    ; Le programme tourne sous Windows 7 ou sous une version antérieure,    ; incapable d'afficher une image dans le RichEdit. Comme solution    ; alternative, on va afficher le caractère flèche gauche.    If BMarker$      TOM_InsertText(NoREGadget, #PBBLeftArrow$, -1)    EndIf  Else    TOM_InsertTaggedJPGImageFromFile(NoREGadget, MyAppDataFolder$ + IButton$, BMarker$, -1)  EndIf  ;  ; On ajoute des espaces après le premier bouton.  TOM_InsertText(NoREGadget, SepSpace$, -1)  ;  If PosInListOfPages < CountString(ListOfResultPages$, Chr(13))    IButton$ = "Next.jpg"    ; On insère un marqueur dans l'image pour savoir sur quoi l'utilisateur    ; a cliqué lorsqu'il clique sur cette image-bouton.    BMarker$ = #PBBRTFMarker$ + #PBBRightArrowMarker$  Else    IButton$ = "NoNext.jpg" ; (bouton inactif).    BMarker$ = ""  EndIf  If OSVersion() <= #PB_OS_Windows_Server_2008_R2    ; Le programme tourne sous Windows 7 ou sous une version antérieure,    ; incapable d'afficher une image dans le RichEdit. Comme solution    ; alternative, on va afficher le caractère flèche droite.    If BMarker$      TOM_InsertText(NoREGadget, #PBBRightArrow$, -1)    EndIf  Else    TOM_InsertTaggedJPGImageFromFile(NoREGadget, MyAppDataFolder$ + IButton$, BMarker$, -1)  EndIf  ;  TOM_InsertText(NoREGadget, SepSpace$, -1)  ;  TotLen = TOM_GetEndPos(NoREGadget, -1)  ;  If OSVersion() <= #PB_OS_Windows_Server_2008_R2    TOM_SetFontStyles(NoREGadget, "Name(Segoe UI),Bold,Size(16)", 0, TotLen)  EndIf  ;  ProcedureReturn TotLenEndProcedure;Procedure DrawPreviousButtonOnly(NoREGadget)  ;  ; Affiche un simple bouton [<<] pour les pages indiquant que la recherche  ; n'a pas permis d'obtenir un résultat.  ;  ; Cette procédure est appellée par FillDetailREGadget() et FillFoundInREGadget().  ;  Shared ListOfResultPages$ ; Historique de recherche.  ;  Protected SepSpace$, IButton$, BMarker$  Protected LenButtonsIntro ; Valeur de retour.  ;  ; Affichage du bouton '<< Previous' :  ;  LenButtonsIntro = 0  SepSpace$ = "  "  PBB_SuspendRedraw(NoREGadget, #True) ; On suspend l'affichage dans le Gadget,                                       ; pour éviter le scrolling, au fur et à mesure des mises en couleur.  ;  TOM_InsertText(NoREGadget, "", 0, -1) ; On supprime l'ancien contenu  ;  If CountString(ListOfResultPages$, Chr(13)) > 0    IButton$ = "Previous.jpg"    ; On insère un marqueur avant l'image pour savoir sur quoi l'utilisateur    ; a cliqué lorsqu'il clique sur une image.    BMarker$ = #PBBRTFMarker$ + #PBBRightArrow$  Else    IButton$ = "NoPrevious.jpg" ; (bouton inactif).    BMarker$ = ""  EndIf  If OSVersion() <= #PB_OS_Windows_Server_2008_R2    ; Le programme tourne sous Windows 7 ou sous une version antérieure,    ; incapable d'afficher une image dans le RichEdit. Comme solution    ; alternative, on va afficher le caractère flèche gauche.    If BMarker$      TOM_InsertText(NoREGadget, #PBBLeftArrow$, -1)    EndIf  Else    TOM_InsertTaggedJPGImageFromFile(NoREGadget, MyAppDataFolder$ + IButton$, BMarker$, -1)  EndIf  ;  TOM_InsertText(NoREGadget, SepSpace$, -1)  ;  TotLen = TOM_GetEndPos(NoREGadget, -1)  ;  If OSVersion() <= #PB_OS_Windows_Server_2008_R2    TOM_SetFontStyles(NoREGadget, "Name(Segoe UI),Bold,Size(16)", 0, TotLen)  EndIf  ;  ProcedureReturn TotLenEndProcedure;Procedure FillDetailREGadget(*LastSearch.LastSearchDetails)  ;  ; Rempli un Gadget RichEdit avec le détail d'un élément (nom, paramètres et code),  ; puis attribue des couleurs aux différentes parties du codes PureBasic de l'élément.  ;   ; Avant l'appel de cette procédure, 'ListOfAllElements$(TypeOfElement)' doit avoir été déclarée  ; comme globale et doit contenir la liste des élements.  ; La procédure 'CompleteListOfAllElements()' s'est normalement occupé de ça.  ; Si la liste 'ListOfUsedElements$(TypeOfElement)' a été complétée, les noms des éléments seront  ; affichés dans leurs couleurs normales ou en gris, selon qu'ils sont utilisés ou non.  ; C'est 'SetAllListsOfUsedElements()' qui est chargée de compléter 'ListOfUsedElements$(TypeOfElement)'.  ;  ; 'PBBListOfFiles$' doit avoir été déclarée et doit contenir la liste des fichiers liés  ; au fichier principal. 'CompleteListOfFile()' s'est normalement occupé de ça.  ;  Shared VList.VariableListings, ListOfMacro$  ;  Static LastPrintedExpression$ ; Dernière expression affichée dans le panneau.                                ;  Protected REContentString.string  Protected ElementLine$, ElementName$, FSource$, CompleteElementDeclaration$, EComment$ ; Propriété de l'élément affiché.  Protected pf, EndNamePos, EndCommentPos, EndIntroPos, posa, posb, LenButtonsIntro   ; Positions dans le texte pour les mises en couleur.  Protected *EContent.String, NEContent$  Protected CurrentDecal, ListDecal$, pEnd, pR, pRef, pRet, Decal, mDecal, nl         ; Pour la gestion des indentations.  Protected DetailREGadget, NoDetail                                                  ; Gestion du contenu global.  Protected UseByMention$                                                             ; Pour la mention "utilisée par..."  Protected scrollPos.Point                                                           ; Position de l'ascenseur avant le ré-affichage du contenu  ;  ; Autres variables :  Protected SExpression$, TypeOfElement, ElementNameLCase$  Protected ElementParent$, ElementStartingPos, ElementEndingPos  Protected DeclarationDetails$, ElementTitle$, EValue$, EndDeclarPos  Protected EEnumeration$, LenToDelete, PosInCode, Line$, ext$, mp, Introtext$  Protected ExistingElement, mExistingElement, EFName$  ;  DetailREGadget = NoREGadgetOfPBBPanel(#DetailPBBPanel)  ;  SExpression$     = *LastSearch\ElementName$  TypeOfElement = *LastSearch\ElementType  ;  If SExpression$    ;    If LastPrintedExpression$ = SExpression$      ; Nous nous apprêtons à rafraîchir un contenu qui est déjà affiché.      ; On mémorise la position de l'ascenseur afin de la rétablir à      ; la fin de la procédure.      SendMessage_(GadgetID(DetailREGadget), #EM_GETSCROLLPOS, 0, @scrollPos)    Else      LastPrintedExpression$ = SExpression$      scrollPos\x = 0      scrollPos\y = 0    EndIf    ;    PBB_SuspendRedraw(DetailREGadget, #True)    ;       If TypeOfElement = #PBBProcedure And ListCompletionAll(#PBBVariable) = #ListCompletion_Done      ; On a testé ListCompletionAll(#PBBVariable) = #ListCompletion_Done, car l'exploration      ; des variables d'une procédures n'est fiable que dans la mesure où les variables      ; 'Shared' et 'Global' ont déjà été identifiées.      ListVariables(SExpression$, VList)    EndIf    ;    SExpression$ = PurifyElementName(SExpression$)    ;    LenButtonsIntro = ManageSearchHistoryButtons(SExpression$, DetailREGadget)    ;    If TypeOfElement > -1      ;      ; *************************************************      ; Texte d'introduction      ;      If TypeOfElement < #EndEnumPBBElementTypes        If ListCompletionAll(TypeOfElement) < #ListCompletion_Done          ; On s'assure que tous les éléments ont déjà été inventoriés,          ; et si cela n'a pas déjà été fait, on le fait en mode prioritaire.          SetOneListOfAllElements(TypeOfElement, #FinishCompletionNow)          CloseWaitingWindow()        EndIf        CheckIfElementExistsInList(ListOfAllElements$(TypeOfElement), SExpression$, TypeOfElement)        If ExistingElement          pf = FindString(ListOfAllElements$(TypeOfElement), Chr(13), ExistingElement)          ElementLine$       = FastMid(ListOfAllElements$(TypeOfElement), ExistingElement, pf - ExistingElement)          ElementName$       = StringField(ElementLine$, #EL_ElementName, Chr(9))          ElementNameLCase$  = StringField(ElementLine$, #EL_ElementNameLCase, Chr(9))          ElementParent$     = StringField(ElementLine$, #EL_Parent, Chr(9))          ElementStartingPos = Val(StringField(ElementLine$, #EL_StartingPos, Chr(9)))          ElementEndingPos   = Val(StringField(ElementLine$, #EL_EndingPos, Chr(9)))          FSource$           = StringField(ElementLine$, #EL_FileName, Chr(9))          CompleteElementDeclaration$ = StringField(ElementLine$, #EL_CompleteElementDeclaration, Chr(9))          DeclarationDetails$ = StringField(ElementLine$, #EL_DeclarationDetails, Chr(9))          ;          ElementTitle$      = CompleteElementDeclaration$          If ElementTitle$ = ElementName$ Or ElementTitle$ = ElementName$ + ":" Or FastLeft(ElementName$, 1) = "#"            ElementTitle$    = GetTextFromCatalog(PBBTypeNames$(TypeOfElement)) + " " + ElementTitle$          EndIf          ElementTitle$      = ReplaceString(ElementTitle$, "(", " (")          While FindString(ElementTitle$, "  ")            ElementTitle$    = ReplaceString(ElementTitle$, "  ", " ")          Wend          ElementTitle$      = Trim(ElementTitle$)                    If TypeOfElement = #PBBConstante            EValue$ = StringField(ElementLine$, #EL_Value, Chr(9))            If EValue$ And EValue$ <> "UnResolved"              ; Pour les constantes, en particulier, quand aucune valeur n'a été déclarée au              ; moment de la déclaration, ou quand la valeur découle d'un calcul quelconque,              ; on regarde si nous avons réussi à déduire ou à interpéter cette valeur              ; lors de l'exploration. La procédure 'SetOneListOfAllElements()' tente, en effet,              ; une interprétation de la valeur des constantes qui figurent dans une énumération.              ; (Voir cette procédure pour avoir plus de détails).              If FindString(ElementTitle$, "=") = 0                ElementTitle$ + " = " + EValue$              Else                ElementTitle$ + " (=" + EValue$ + ")"              EndIf            EndIf            EndDeclarPos = Len(ElementTitle$)            EEnumeration$ = StringField(ElementLine$, #EL_DeclarationDetails, Chr(9))            If EEnumeration$              ElementTitle$ + " (" + PBBTypeNames$(#PBBEnumeration) + " " + EEnumeration$ + ")" + Chr(13)            EndIf          Else            EndDeclarPos = Len(ElementTitle$)          EndIf          ;          REContentString\s = ElementTitle$          EndNamePos = Len(REContentString\s)          If TypeOfElement > #PBBInterface            ; Il n'y a pas de code à afficher pour les labels et les constantes.            ; L'utilisateur n'aura donc pas l'occasion de voir les commentaires            ; éventuels accompagnant le code.            ; Alors, on les lui affiche derrière la déclaration de l'élément.            EComment$ = StringField(ElementLine$, #EL_Comment, Chr(9))            If EComment$              REContentString\s + " " + EComment$            EndIf          EndIf          If Right(REContentString\s, 1) <> Chr(13)            REContentString\s + Chr(13)          EndIf          EndCommentPos = Len(REContentString\s)          If TypeOfElement = #PBBProcedure And DeclarationDetails$            REContentString\s + "• " + GetTextFromCatalog("declaredIn") + " "            REContentString\s + GetFilePart(StringField(DeclarationDetails$, 1, "/")) + ", " + GetTextFromCatalog("AtLine") + " " + StringField(DeclarationDetails$, 2, "/") + "." + Chr(13)          EndIf          REContentString\s + "• " + GetTextFromCatalog("definedIn") + " "          REContentString\s + GetFilePart(FSource$) + ", " + GetTextFromCatalog("AtLine") + " " + StringField(ElementLine$, #EL_StartingLine, Chr(9)) + "." + Chr(13)          ;          If ElementParent$            UseByMention$ = StringField(ElementParent$, 1, "/")            If UseByMention$ = #OutOfElementsName              UseByMention$ = GetTextFromCatalog(#OutOfElementsName) + " " + GetTextFromCatalog("in") + " " + GetFilePart(StringField(ElementParent$, 2, "/"))              UseByMention$ + " " + GetTextFromCatalog("AtLine") + " " + StringField(ElementParent$, 3, "/")            Else              UseByMention$ + " (" + PBBTypeNames$(Val(StringField(ElementParent$, 2, "/"))) + ")"              UseByMention$ + " " + GetTextFromCatalog("in") + " " + GetFilePart(StringField(ElementParent$, 3, "/"))              UseByMention$ + " " + GetTextFromCatalog("AtLine") + " " + StringField(ElementParent$, 4, "/")            EndIf            REContentString\s + "• " + GetTextFromCatalog("usedBy") + ": " + UseByMention$ + "." + Chr(13)          ElseIf ListCompletionUsed(TypeOfElement) = #ListCompletion_Done            REContentString\s + "• " + GetTextFromCatalog("Unused") + "." + Chr(13)          EndIf          ;          ; Liste des variables non protégées ou protégées :          If TypeOfElement = #PBBProcedure And VList\Unused            REContentString\s + "• " + VList\Unused + "." + Chr(13)          EndIf          If TypeOfElement = #PBBProcedure And VList\Unprotected            REContentString\s + "• " + VList\Unprotected + "." + Chr(13)          EndIf          If TypeOfElement = #PBBProcedure And VList\CompleteList            REContentString\s + GetTextFromCatalog("SeeVariablesList") + "." + Chr(13)          EndIf          ;          If TypeOfElement = #PBBProcedure And ListOfMacro$            ; On enlève la tabulation finale de ListOfMacro$ et on            ; remplace les tabulations par des virgules :            ListOfMacro$ = ReplaceString(FastLeft(ListOfMacro$, Len(ListOfMacro$) - 1), Chr(9), ", ")            REContentString\s + "• " + GetTextFromCatalog("CalledMacros") + ListOfMacro$ + "." + Chr(13)          EndIf          ;          REContentString\s + Chr(13)          ;          ; On remplace les Chr(13) par #CRLF$ (Chr(13) + Chr(10)) pour éviter les bugs d'affichage.          TOM_InsertText(DetailREGadget, ReplaceString(REContentString\s, Chr(13), #CRLF$), -1)          ; NOTE : Le texte inséré dans un RicheEdit Gadget doit comporter et comporte toujours #CRLF$          ; (Chr(13)+Chr(10)) en fin de ligne. Pourtant, lorque l'on récupère la position          ; du curseur dans un gadget de ce genre (SendMessage_(GadgetID(RE_gadget), #EM_EXGETSEL, 0, *txtrange))          ; ou lorsque l'on modifie la sélection (SendMessage_(GadgetID(RE_Gadget), #EM_EXSETSEL, 0, @txtrange))          ; les fins de ligne n'occupent que l'emplacement d'un seul caractère.          ; Dans ce qui précède et dans ce qui suit, on gère cette particularité comme suit :          ; • Le texte inséré dans le gagdet comporte toujours Chr(13)+Chr(10).          ; • La chaîne de caractère 'REContentString\s' qui sert de référence pour les calculs de position          ;   ne comporte que Chr(13) en fin de ligne.          ;          EndIntroPos = TOM_GetEndPos(DetailREGadget, -1) ; On repère la position dans le texte.          ;          REContentString\s = Space(LenButtonsIntro) + REContentString\s ; REContentString\s va servir de référence          ; aux différentes fonctions de mise en forme et en couleurs qui vont suivre, afin de savoir quel est          ; le contenu du texte de DetailREGadget à tel ou tel endroit. Il faut donc intégrer dans son contenu l'espace          ; occupé par les boutons 'Previous' et 'Next' et par les marqueurs et les espaces qui les entourent.          ;          EndNamePos + LenButtonsIntro  ; idem pour EndNamePos qui repère la fin du nom de l'élément.          EndCommentPos + LenButtonsIntro ; idem pour la fin du commentaire.          EndDeclarPos + LenButtonsIntro  ; idem pour la position de fin de déclaration.          ;          ; On va ajouter le contenu (le code) de l'élément.          ;          *EContent = GetPointedElementContentFromFile(FSource$, ElementStartingPos, ElementEndingPos, #False)          ;          ; ************************************************************          ;   Remplacement des espaces à gauche par des 'OffsetIndent'          ;          ; Il peut arriver que le code de l'élément ne soit pas aligné à gauche          ; (dans le cas, par exemple, où l'on récupère le contenu d'une structure déclarée dans une procédure).          ; On va donc regarder comment est aligné le 'EndElement' ('EndStructure', par exemple)          ; et tout décaler vers la gauche en fonction de ce que l'on a trouvé.          ;          pEnd = ReverseFindString(*EContent\s, "End")          pRet = ReverseFindString(*EContent\s, Chr(13), pEnd)          LenToDelete = pEnd - pRet - 1          ;          ; Nous allons maintenant lire le contenu de l'élément ligne par ligne,          ; supprimer les espaces qui figuraient en début de ligne,          ; et mémoriser leurs nombres, afin de pouvoir ensuite          ; appliquer un OffsetIndent (décalage à gauche) sur ces lignes.          ;          CurrentDecal = 0          ListDecal$ = ""          NEContent$ = ""          ;            If pEnd            pR = 0            pRef = 1            Repeat              PosInCode = pR + 1              If PosInCode < Len(*EContent\s)                pR = FindString(*EContent\s, Chr(13), pR + 1)                If pR = 0 : pR = Len(*EContent\s) + 1 : EndIf                ; On compte les espaces qui figurent au début de la ligne.                Decal = 0                While FastMid(*EContent\s, PosInCode, 1) = " " : PosInCode + 1 : Decal + 1 : Wend                Line$ = FastMid(*EContent\s, PosInCode, pR - PosInCode)                ;                ; Si le texte de l'élément n'était pas aligné à gauche, on corrige.                If Decal >= LenToDelete                  Decal - LenToDelete                EndIf                ;                ; Pour gagner du temps, on ne va mémoriser que les changements d'alignement                ; (positifs ou négatifs).                Decal - CurrentDecal                CurrentDecal + Decal                If Decal                  ; On mémorise les changements dans une chaîne qui contiendra une suite de                  ; 'position dans le texte' + Chr(9) + Str(Decalage) + Chr(9).                  ListDecal$ + Str(pRef - 1) + Chr(9) + Str(Decal) + Chr(9)                EndIf                pRef + (pR - PosInCode) + 1                ; On stock la ligne débarrassée de ses espaces à gauche.                NEContent$ + Line$ + Chr(13)              EndIf            Until PosInCode >= Len(*EContent\s)            ; On n'oublie pas de mémoriser la dernière position de décalage.            ListDecal$ + Str(pRef - 1) + Chr(9) + Str(Decal) + Chr(9)          EndIf          ; On met à jour la chaîne de référence avec le contenu de l'élément.          REContentString\s + NEContent$          ; On met à jour le RE_Gadget avec le contenu de l'élément :          TOM_InsertText(DetailREGadget, ReplaceString(Chr(13) + NEContent$, Chr(13), #CRLF$), -1)          ; On applique un 'offset' (décalage des lignes qui suivent la première ligne)          ; sur la totalité du code. Comme notre gagdet sera affiché en mode 'Wrap', cela permet          ; à l'œil de mieux se repérer quand une ligne est coupée en plusieurs morceaux.          TOM_SetParaStyles(DetailREGadget, "LeftIndent(5.5), FirstLineIndent(-5.5)", EndIntroPos, -1)          ;          ; Nous allons maintenant appliquer les 'LeftIndent' (décalages à gauche)          ; en fonction de ce qui figure dans la chaîne 'ListDecal$'.          nl = 0          PosInCode = EndIntroPos + 1 ; Position de début du code que nous venons d'intégrer dans le RE_Gadget.          Decal = 0          Repeat            nl + 1            ext$ = StringField(ListDecal$, nl, Chr(9))            If ext$              mp = PosInCode              PosInCode = Val(ext$) + EndIntroPos + 1              nl + 1              mDecal + Decal              Decal = Val(StringField(ListDecal$, nl, Chr(9)))              ; Pour chaque décalage lu, on applique le précédent décalage              ; à tout ce qui précède la position donnée.              TOM_SetParaStyles(DetailREGadget, "LeftIndent(" + Str(5.5 * (mDecal + 1)) + ")", mp, PosInCode - 1)              ; Ainsi, on obtient bien l'effet voulu, c'est-à-dire que chaque décalage              ; s'applique à tout le texte, jusqu'au décalage suivant.              ; Tout ça est un peu compliqué, mais cela permet de diviser le nombre              ; d'opérations par deux ou trois, si l'on compare cette méthode à celle              ; qui consisterait à régler le décalage ligne par ligne, pour toutes              ; les lignes.            EndIf          Until ext$ = ""          ;          ;          ; On met la chaîne de référence en minuscule, afin que les recherches          ; qui vont suivre soient 'NoCase' (insensibles à la casse).          ;          REContentString\s = LCase(REContentString\s)          ;          ; ************************************************************          ;                Mise en couleur et en styles          ;          ; Ce qui se situe avant 'EndIntroPos' est affiché en 'Segoe UI', taille 9.          ;          TOM_SetFontStyles(DetailREGadget, "Name(Segoe UI),Bold(0),Size(9)", LenButtonsIntro, EndIntroPos)          ;          ; Tout ce qui suit est affiché en 'Consolas', taille 10.          ; La police 'Consolas' est une variante de 'Courier", mais elle a           ; l'avantage de pouvoir afficher un jeu de caractères plus étendu          ; qui exploite pleinement les possibilités de l'UTF-8.          ;          TOM_SetFontStyles(DetailREGadget, "Name(Consolas),Bold(0), Size(10)", EndIntroPos - 1, -1)          ;          ; On colorie le nom de l'élément placé en titre, ainsi que ses arguments :          ;          If ElementParent$ Or ListCompletionUsed(TypeOfElement) < #ListCompletion_Done            ; Si l'exploration profonde n'est pas terminée, on affiche par défaut l'élément            ; comme s'il était utilisé.            TOM_SetFontStyles(DetailREGadget, "SetForeColor(" + Str(DarkRedColor) + ")", 0, EndDeclarPos)          Else            TOM_SetFontStyles(DetailREGadget, "SetForeColor(" + Str(pcolorNotUsed) + ")", 0, EndDeclarPos)          EndIf          TOM_SetParaStyles(DetailREGadget, "LeftIndent(40), FirstLineIndent(-40)", 0, EndDeclarPos)          ;          ; On met en gras le nom de l'élément lui-même.          posa = FindString(REContentString\s, ElementNameLCase$) - 1          posb = FindString(REContentString\s, ".", posa)          If posb = 0 Or posb > posa + Len(ElementNameLCase$)            posb = posa + Len(ElementNameLCase$)          EndIf          ;          If posa            TOM_SetFontStyles(DetailREGadget, "Bold", posa, posb)          EndIf          ;          ; On affiche en gris tous les autres détails figurant          ; dans la présentation de l'élément :          TOM_SetFontStyles(DetailREGadget, "SetForeColor(" + Str(GreyColor) + ")", EndDeclarPos, EndIntroPos)          ;          ; On attribue une marge à gauche pour tous les détails          ; qui suivent la ligne où figure le nom de l'élément.          ; dans la présentation de l'élément :          posa = FindString(REContentString\s, Chr(13))          TOM_SetParaStyles(DetailREGadget, "LeftIndent(40)", posa, EndIntroPos)          ;          ; On souligne les liens          ;          UnderLineFNamesAndLinks(DetailREGadget, 0, REContentString, 1)          ;          ; On colorie les commentaires          ;          ColorizeComments(DetailREGadget, 0, 0, REContentString)          ;          ; On affiche déjà le résultat auquel on est arrivé, pour réduire          ; le sentiment d'attente pour l'utilisateur :          SendMessage_(GadgetID(DetailREGadget), #EM_SETSCROLLPOS, 0, @scrollPos)          PBB_SuspendRedraw(DetailREGadget, #False)          PBB_SuspendRedraw(DetailREGadget, #True)          ;          ;On colorie les noms des éléments.          ;          ColorizeElementsNames(DetailREGadget, EndDeclarPos, 0, #DetailPBBPanel, REContentString, ElementNameLCase$)          ;          ; On colorie les mots clés de PureBasic (if, endif, while, wend, etc.)          ; et on les met en gras.          ;          ColorizeBasicKeyWords(DetailREGadget, EndIntroPos, 0, REContentString)          ;          ; On colorie les noms des constantes natives (ou Windows).          ;          ColorizeNativeConstants(DetailREGadget, EndIntroPos, 0, REContentString)          ;          ; On colorie les textes entre guillemets.          ;          ColorizeInQuote(DetailREGadget, EndIntroPos, 0, REContentString)          ;          ; On colorie les noms des fonctions natives de PureBasic          ; (c'est ce qui prend le plus de temps, car il y a presque 2000 fonctions).          ;          ColorizeNativePBFunctions(DetailREGadget, EndIntroPos, 0, REContentString)          ;        EndIf        ;      ElseIf TypeOfElement = #PBBNativeFunction Or TypeOfElement = #PBBBasicKeyword        If TypeOfElement = #PBBNativeFunction          Introtext$ = *LastSearch\ElementName$ + "() " + GetTextFromCatalog("AboutNativeFunction")        ElseIf TypeOfElement = #PBBBasicKeyword          Introtext$ = *LastSearch\ElementName$ + " " + GetTextFromCatalog("AboutBasicKeyword")        EndIf        ;        TOM_InsertText(DetailREGadget, ReplaceString(Introtext$, Chr(13), #CRLF$), -1)        Introtext$ = Space(LenButtonsIntro) + Introtext$        ;        TOM_SetParaStyles(DetailREGadget, "LeftIndent(40), FirstLineIndent(-40)", 0, LenButtonsIntro - 1)        TOM_SetFontStyles(DetailREGadget, "Name(Segoe UI),Bold(0),Size(9)", LenButtonsIntro, -1)        ; On colorie le nom de l'expression        TOM_SetFontStyles(DetailREGadget, "ForeColor(" + Str(DarkRedColor) + "), Underline(Single), Bold", LenButtonsIntro, LenButtonsIntro + Len(SExpression$))        ; On crée un décalage à gauche pour la deuxième ligne.        posa = FindString(Introtext$, Chr(13)) + 1        TOM_SetParaStyles(DetailREGadget, "LeftIndent(40)", posa + 1, posa + 2)      Else        ; On ne devrait jamais arriver ici. Alors, si c'est le cas,        ; on affiche une erreur :        AlertInPBBWindow("Error in procedure FillDetailREGadget : TypeOfElement is unknown (" + Str(TypeOfElement) + ").")      EndIf    Else      NoDetail = 1    EndIf  Else    NoDetail = 1  EndIf  If NoDetail    If SExpression$      REContentString\s = ReplaceString(GetTextFromCatalog("NoDetailFound"), "%SExpression$%", "'" + SExpression$ + "'")      TOM_InsertText(DetailREGadget, ReplaceString(REContentString\s, Chr(13), #CRLF$), -1)      TOM_SetParaStyles(DetailREGadget, "LeftIndent(40), FirstLineIndent(-40)", 0, 1)      TOM_SetFontStyles(DetailREGadget, "Name(Segoe UI),Bold(0),Color(0),Size(9)", LenButtonsIntro, -1)      ;          ; On colorie le nom de l'expression      PosInCode = FindString(REContentString\s, SExpression$)      TOM_SetFontStyles(DetailREGadget, "ForeColor(" + Str(DarkRedColor) + "), Bold", LenButtonsIntro + PosInCode - 1, LenButtonsIntro + PosInCode - 1 + Len(SExpression$))    Else      LenButtonsIntro = DrawPreviousButtonOnly(DetailREGadget)      REContentString\s = GetTextFromCatalog("NoDetailNoExpression")      TOM_InsertText(DetailREGadget, ReplaceString(REContentString\s, Chr(13), #CRLF$), -1)      TOM_SetParaStyles(DetailREGadget, "LeftIndent(40), FirstLineIndent(-40)", 0, 1)      TOM_SetFontStyles(DetailREGadget, "Name(Segoe UI),Bold(0),color(0),Size(9)", LenButtonsIntro, -1)    EndIf    PosInCode = FindString(REContentString\s, Chr(13))    If PosInCode And PosInCode < Len(REContentString\s)      TOM_SetParaStyles(DetailREGadget, "LeftIndent(40)", LenButtonsIntro + PosInCode + 1, -1)    EndIf  EndIf  ;  ; On remet l'ascenseur à sa position initiale :  SendMessage_(GadgetID(DetailREGadget), #EM_SETSCROLLPOS, 0, @scrollPos)  ;  ; On rétabli l'affichage dans le gadget :  PBB_SuspendRedraw(DetailREGadget, #False)  ;  ReSizeREMenu()EndProcedure;Procedure FillFoundInREGadget(*LastSearch.LastSearchDetails)  ;  ; Remplit le gadget FoundInFilesREGadget avec les éléments trouvés dans la liste de fichiers  ; après une recherche sur l'expression contenue dans *LastSearch\ElementName$.  ;  Shared VarWithArguments  ;  Static LastPrintedExpression$ ; Dernière expression affichée dans le panneau.                                ;  Protected REContentString.string  Protected PosInCode, mp, LenButtonsIntro, IsUnused, PrintedExpression$  Protected FoundInFilesREGadget, BatchListFoundInFiles$, Reset  Protected scrollPos.Point ; Position de l'ascenseur avant le ré-affichage du contenu  Protected  mSExpression$, SExpression$, RemainingString$, LastCRPos, StartPos  ;  FoundInFilesREGadget = NoREGadgetOfPBBPanel(#FoundInFilesPBBPanel)  ;  ; Nous procédons maintenant à la recherche de l'expression,  ; afin de compléter le panneau "Trouvé dans..."  ;  ; On ne conserve que ce qui figure avant le caractère Chr(8239).  ; (Voir 'BSearchExpression' pour avoir des détails).  ;  mSExpression$ = *LastSearch\ElementName$  SExpression$ = PurifyElementName(*LastSearch\ElementName$)  ;  REContentString\s = ""  BatchListFoundInFiles$ = "Pending"  If SExpression$    If LastPrintedExpression$ = SExpression$      ; Nous nous apprêtons à rafraîchir un contenu qui est déjà affiché.      ; On mémorise la position de l'ascenseur afin de la rétablir à      ; la fin de la procédure.      SendMessage_(GadgetID(FoundInFilesREGadget), #EM_GETSCROLLPOS, 0, @scrollPos)    Else      LastPrintedExpression$ = SExpression$      scrollPos\x = 0      scrollPos\y = 0    EndIf          ; Si les listes ont déjà été complétée, on regarde si l'expression    ; correspond au nom d'une liste, d'un tableau ou d'une map :    If FindString(*LastSearch\TypeName$, "Array") Or FindString(*LastSearch\TypeName$, "List") Or FindString(*LastSearch\TypeName$, "Map")      VarWithArguments = 1    Else      VarWithArguments = 0    EndIf    ; On lance la recherche dans les fichiers de code,    ; pour voir si on trouve quelque chose :    Reset = #True    Repeat      RemainingString$ = SetListFoundInFiles(SExpression$, Reset)      ; SetListFoundInFiles() s'interrompt au bout de 100 millisecondes.      ; Elle retourne la valeur "Pending" quand elle n'a pas réussi à      ; trouver quelque chose pendant cet intervalle, mais que l'ensemble      ; des fichiers n'a pas encore été exploré.      Reset = #False    Until RemainingString$ <> "Pending"    ;    If RemainingString$      ; L'expression a été trouvée.      ;      RemainingString$ = Chr(13) + RemainingString$      ;      ; On mémorise la position de l'ascenseur avant de rafraîchir le contenu      ; du gagdet.      SendMessage_(GadgetID(FoundInFilesREGadget), #EM_GETSCROLLPOS, 0, @scrollPos)      ;      ; On suspend l'affichage pendant le remplissage du gadget :      PBB_SuspendRedraw(FoundInFilesREGadget, #True)      ; ManageSearchHistoryButtons() va dessiner les boutons << et >> dans le REGadget      ; en leur ajoutant des marqueurs pour que ClickOverREGadget puisse les reconnaître      ; quand l'utilisateur cliquera dessus :      LenButtonsIntro = ManageSearchHistoryButtons(SExpression$, FoundInFilesREGadget)      ; On affiche le titre et le texte d'introduction :      PrintedExpression$ = SExpression$      ; On ajoute le type de l'expression, si elle en a un, et on rétabli la casse, si nécessaire :      If *LastSearch\TypeName$ And PrintedExpression$ = LCase(*LastSearch\ElementName$) Or PrintedExpression$ + "." = Left(LCase(*LastSearch\ElementName$), Len(PrintedExpression$ + "."))        PrintedExpression$ = *LastSearch\ElementName$ + " (" + *LastSearch\TypeName$ + ")"      Else        PrintedExpression$ = mSExpression$      EndIf      REContentString\s = PrintedExpression$ + Chr(13) + GetTextFromCatalog("FoundListIntro") + Chr(13) + GetTextFromCatalog("MoreInfo") + " "      TOM_InsertText(FoundInFilesREGadget, ReplaceString(REContentString\s, Chr(13), #CRLF$), -1)      TOM_SetFontStyles(FoundInFilesREGadget, "Name(Segoe UI),Bold(0),Size(9)", LenButtonsIntro, -1)      ; On ajoute à REContentString\s le nombre d'espace correspondant à la place      ; occupée par les boutons et les marqueurs, pour que les recherches que l'on      ; mènera plus tard sur cette chaîne renvoient une position identique à      ; ce qu'il y a réellement dans le gadget.      REContentString\s = Space(LenButtonsIntro) + LCase(REContentString\s)      ;      ; On défini un offest pour le titre (l'expression recherchée et trouvée) :      ;      TOM_SetParaStyles(FoundInFilesREGadget, "LeftIndent(40), RightIndent(20), FirstLineIndent(-40)", LenButtonsIntro, LenButtonsIntro + Len(PrintedExpression$))      ;      ; Le fait de mettre le nom de l'expression en gras et en couleur,      ; dans les trois lignes qui vont suivre, peut sembler redondant      ; avec le fait de faire colorier cette expression par ColorizeElementsNames()      ; juste après. Sauf que ColorizeElementsNames() ne colorie que les      ; noms d'éléments et seulement lorque l'exploration est suffisamment avancée      ; pour permettre d'identifier les éléments. Si notre expression n'est pas      ; un élément reconnu, ces deux lignes permettront qu'elle soit tout de même      ; bien présentée.      TOM_SetFontStyles(FoundInFilesREGadget, "ForeColor(" + Str(DarkRedColor) + ")", LenButtonsIntro, LenButtonsIntro + Len(PrintedExpression$))      TOM_SetFontStyles(FoundInFilesREGadget, "Bold", LenButtonsIntro, LenButtonsIntro + Len(SExpression$))      ;      ; On colorie le titre en gris, s'il s'agit d'un élément non utilisé,      ; Ou en 'DarkRedColor' dans le cas contraire.      ; ColorizeElementsNames() nous retourne une valeur pour nous dire      ; si l'expression est utilisée.      IsUnused = ColorizeElementsNames(FoundInFilesREGadget, 1, DarkRedColor, #FoundInFilesPBBPanel, REContentString, SExpression$)      ; On souligne "En savoir plus..."      UnderLineFNamesAndLinks(FoundInFilesREGadget, 1, REContentString)      ;      ; On attribue une marge gauche à la mention "En savoir plus..."      PosInCode = FindString(REContentString\s, Chr(13), 0)      TOM_SetParaStyles(FoundInFilesREGadget, "LeftIndent(40)", PosInCode, Len(REContentString\s) - 1)      ;    EndIf  EndIf  ;  If REContentString\s    Repeat      ;      If BatchListFoundInFiles$                If FindString(BatchListFoundInFiles$, Chr(13)) = 0          ; On n'a pas de fin de ligne dans la chaîne de résultats. Cela veut dire que SetListFoundInFiles()          ; est en train de produire une longue chaîne de résultats qui a été segmentée en plusieurs morceaux.          ; On va stocker les résultats que nous avons dans RemainingString$ jusqu'à ce que la ligne          ; soit complétée.          If BatchListFoundInFiles$ <> "Pending"            RemainingString$ = RemainingString$ + BatchListFoundInFiles$            ; Et on attribue la valeur "Pending" à BatchListFoundInFiles$ pour que le travail se poursuive :            BatchListFoundInFiles$ = "Pending"          EndIf        Else          ; Si RemainingString$ contient un morceau de texte issu de la passe          ; précédente, on l'intègre aux résultats que l'on vient d'obtenir :          If Right(RemainingString$, 2) = ", " And FastLeft(BatchListFoundInFiles$, 1) = Chr(13)            RemainingString$ = FastLeft(RemainingString$, Len(RemainingString$) - 2)          EndIf          BatchListFoundInFiles$ = RemainingString$ + BatchListFoundInFiles$          ; On cherche le dernier caractère de fin de ligne dans la chaîne :          LastCRPos = Len(BatchListFoundInFiles$)          While LastCRPos And PeekC(@BatchListFoundInFiles$ + (LastCRPos - 1) * SizeOf(CHARACTER)) <> 13            LastCRPos - 1          Wend          ;          If (Len(BatchListFoundInFiles$) - LastCRPos) > 1            ; On met de côté (dans RemainingString$) tout ce qui suit la dernière fin de ligne trouvée.            ; Ainsi, les styles seront appliqués sur des paragraphes entiers :            RemainingString$ = FastMid(BatchListFoundInFiles$, LastCRPos)            BatchListFoundInFiles$ = FastLeft(BatchListFoundInFiles$, LastCRPos - 1)          Else            RemainingString$ = ""          EndIf        EndIf      Else        BatchListFoundInFiles$ = RemainingString$        RemainingString$ = ""      EndIf      If Right(BatchListFoundInFiles$, 2) = ", "        BatchListFoundInFiles$ = FastLeft(BatchListFoundInFiles$, Len(BatchListFoundInFiles$) - 2)      EndIf            If BatchListFoundInFiles$ And BatchListFoundInFiles$ <> "Pending"                ;        ; On insère dans le gadget les résultats qui viennent d'être obtenus :        ;        StartPos = Len(REContentString\s) + 1        TOM_InsertText(FoundInFilesREGadget, ReplaceString(BatchListFoundInFiles$, Chr(13), #CRLF$), -1)        TOM_SetFontStyles(FoundInFilesREGadget, "Name(Segoe UI),Bold(0),Size(9)", StartPos, -1)        REContentString\s + LCase(BatchListFoundInFiles$)        ;        ; On attribue un offset aux lignes qui commencent par une puce :        ;        PosInCode = StartPos        Repeat          mp = PosInCode          While FastMid(REContentString\s, mp, 1) = Chr(13) : mp + 1 : Wend          If mp <> PosInCode            ; Le texte à mettre en forme commence par un retour chariot.            ; On met donc fin au décalage qui s'appliquait éventuellement            ; à la ligne précédente :            TOM_SetParaStyles(FoundInFilesREGadget, "LeftIndent(0), FirstLineIndent(0)", mp, mp + 1)          EndIf          ;          ; On cherche la fin de ligne :          PosInCode = FindString(REContentString\s, Chr(13), mp)          If PosInCode = 0 : PosInCode = Len(REContentString\s) : EndIf          ;          If FastMid(REContentString\s, mp, 1) = "•"            ; La ligne commence par une puce. On lui applique            ; un décalage et un offset :            TOM_SetParaStyles(FoundInFilesREGadget, "LeftIndent(10), FirstLineIndent(-5)", mp, PosInCode - 1)          EndIf        Until PosInCode = Len(REContentString\s)        ;        ColorizeElementsNames(FoundInFilesREGadget, StartPos, 0, #FoundInFilesPBBPanel, REContentString)        ColorizeBasicKeyWords(FoundInFilesREGadget, StartPos, 0, REContentString, IsUnused)        UnderLineFNamesAndLinks(FoundInFilesREGadget, StartPos, REContentString)        ;        ; On rafraîchit l'affichage :        SendMessage_(GadgetID(FoundInFilesREGadget), #EM_SETSCROLLPOS, 0, @scrollPos)        PBB_SuspendRedraw(FoundInFilesREGadget, #False)        PBB_SuspendRedraw(FoundInFilesREGadget, #True)      EndIf      ;      BatchListFoundInFiles$ = SetListFoundInFiles(SExpression$, #False)      ;    Until BatchListFoundInFiles$ = "" And RemainingString$ = ""    ;  Else    ;    LenButtonsIntro = DrawPreviousButtonOnly(FoundInFilesREGadget)    TOM_InsertText(FoundInFilesREGadget, ReplaceString(GetTextFromCatalog("ShouldSearchForSomething"), Chr(13), #CRLF$), -1)    TOM_SetParaStyles(FoundInFilesREGadget, "LeftIndent(19), RightIndent(20), FirstLineIndent(-19)", 0, LenButtonsIntro)    TOM_SetFontStyles(FoundInFilesREGadget, "Size(9), Name(Segoe UI)", 0, LenButtonsIntro)  EndIf  ;  SendMessage_(GadgetID(FoundInFilesREGadget), #EM_SETSCROLLPOS, 0, @scrollPos)  ;  ; On rétabli l'affichage du Gadget :  PBB_SuspendRedraw(FoundInFilesREGadget, #False)  ReSizeREMenu()  ;EndProcedure;Procedure OpenFileWithPureBasic(FNameWithoutPath$, LineNumber$)  ;  ; Cherche FNameWithoutPath$ dans PBBListOfFiles$ et ouvre le fichier  ; dans l'éditeur de PureBasic, si un résultat est trouvé.  ;  ; Utilise les variables globales PBBListOfFiles$ et PureBasicProgAdr$  ;  Shared MustStayActive  ;  Protected PosInList, pf, FFile$, FParam$, FPath$  ;  PosInList = FindString(PBBListOfFiles$, "\" + FNameWithoutPath$, 0) ; on cherche l'expression dans PBBListOfFiles$.  If PosInList    pf = PosInList + Len(FNameWithoutPath$) + 1    While PosInList > 1 And Mid(PBBListOfFiles$, PosInList - 1, 1) <> Chr(9) And Mid(PBBListOfFiles$, PosInList - 1, 1) <> Chr(13) : PosInList - 1 : Wend    FFile$ = Mid(PBBListOfFiles$, PosInList, pf - PosInList)    If FindString(FFile$, "\Temp\PureBasic_TempFile") ; Il s'agit d'un fichier temporaire. On ne passe pas son adresse.      FParam$ = ""      FPath$ = ""      AlertInPBBWindow(GetTextFromCatalog("SaveFilePrompt"))    Else      FPath$  = Chr(34) + GetPathPart(FFile$) + Chr(34)      FParam$ = Chr(34) + FFile$ + Chr(34)    EndIf    If LineNumber$      FParam$ + " /L " + LineNumber$ ; Cet ajout aux paramètres permet de positionner l'éditeur de PureBasic sur une ligne particulière.    EndIf    ;    ; On cas de double-clic de la part de l'utilisateur, on évite    ; de harceler l'éditeur en lui envoyant trop de demandes :    ; il faut au minimum que 500 ms se soient écoulées depuis le dernier    ; clic pour que celui-ci soit pris en compte.    If PureBasicProgAdr$ And (ElapsedMilliseconds() - MustStayActive) > 500      RunProgram(Chr(34) + PureBasicProgAdr$ + Chr(34), FParam$, FPath$)      MustStayActive = ElapsedMilliseconds()    EndIf  EndIfEndProcedure;; ***********************************************************;              Gestion de la fenêtre principale; ***********************************************************;Procedure WalkOverPannels(PStep)  ; Bascule d'un panneau à l'autre, en fonction de l'appui  ; sur les touches de raccourci.  ;  Shared ExactValueSearch, RefreshEPanel  ;  Protected ActPannel  ;  ActPannel = GetActivePBBPanel()  If PStep = 1    If ActPannel = #FoundInFilesPBBPanel      ActPannel = #FilePBBPanel    ElseIf ActPannel = #FilePBBPanel      ActPannel = #ProcPBBPanel    ElseIf ActPannel = #EndEnumPBBPanels - 1      ActPannel = #DetailPBBPanel    Else      ActPannel + 1    EndIf  Else    If ActPannel = #FilePBBPanel      ActPannel = #FoundInFilesPBBPanel    ElseIf ActPannel = #DetailPBBPanel      ActPannel = #EndEnumPBBPanels - 1    ElseIf ActPannel = #ProcPBBPanel      ActPannel = #FilePBBPanel    Else      ActPannel - 1    EndIf  EndIf  SetActivePBBPanel(ActPannel)  ReSizeREMenu()  If ActPannel = #DetailPBBPanel Or ActPannel = #FoundInFilesPBBPanel    ExactValueSearch = #DoProgrammedSearch  Else    RefreshEPanel = #True  EndIfEndProcedure;Procedure WalkOverPages(NextOrPreviewAsked, SearchedExpression_gadget)  ;  Shared ExactValueSearch, PosInListOfPages, ListOfResultPages$  ;  Protected OldExpression$, ClickTime  Protected LineInViewedList$, ExpressionInList$  ;  If NextOrPreviewAsked And (GetActivePBBPanel() = #DetailPBBPanel Or GetActivePBBPanel() = #FoundInFilesPBBPanel)    ; L'utilisateur vient de cliquer sur le bouton 'Next' ou sur 'Previous'.    ; (Ces deux boutons figurent dans les panneaux 'Détails' et 'Trouvé dans...')    ;    ; On va chercher la page à afficher en explorant l'historique    ; des pages précédemment affichées.    If ListOfResultPages$      PosInListOfPages + NextOrPreviewAsked      If PosInListOfPages < 1        PosInListOfPages = 1      EndIf      If PosInListOfPages > CountString(ListOfResultPages$, Chr(13))        PosInListOfPages = CountString(ListOfResultPages$, Chr(13))      EndIf      LineInViewedList$ = StringField(ListOfResultPages$, PosInListOfPages, Chr(13))      ExpressionInList$ = StringField(LineInViewedList$, 1, Chr(9))      ;      OldExpression$ = Trim(StringField(GetGadgetText(SearchedExpression_gadget), 1, Chr(8239)))      ; On affiche l'expression trouvée dans le champs de recherche.      If (ExpressionInList$ And OldExpression$ <> ExpressionInList$)        SetGadgetText(SearchedExpression_gadget, ExpressionInList$)        ; On déclenche une recherche, afin de rafraîchir ce qui est affiché dans le panneau.        ClickTime = ElapsedMilliseconds()        ExactValueSearch = #DoProgrammedSearch        ProcedureReturn #True      EndIf    EndIf  EndIf  ProcedureReturn #FalseEndProcedure;Procedure ClickOverREGadget(SearchedExpression_gadget, Button)  ;  ; Gestion des liens (parties du texte soulignées ou images-boutons)  ; dans les Gadgets des différents panneaux.  ;  ; Cette procédure nécessite que la variable PureBasicProgAdr$ ait été déclarée comme globale  ; et qu'elle contienne l'adresse de l'executable PureBasic.exe.  ; La procédure UpDatePureBasicExeAdr () s'est normalement occupé de ça.  ; De même, ListOfAllElements$(#PBBProcedure) doit avoir été déclarée et doit contenir la liste des procédures.  ; La procédure CompleteListProc() s'est normalement occupé de ça.  ; PBBListOfFiles$ doit avoir été déclarée et doit contenir la liste des fichiers liés  ; au fichier principal. CompleteListProc() s'est normalement occupé de ça.  ;  ; Remarque à propos des fonctions RE_Gadget utilisées ici :  ; Pour Windows, la position dans un texte commence à 0, alors que pour PureBasic, elle commence à 1  ; Les fonctions de la librairie RE_Gadget respecte la logique de Windows, ce qui explique des +1 ou -1  ; quand les paramètres de cette librairies sont utilisés dans un appel à Mid(), par exemple.  ;  Static LastClickPos ; Mémorise la position du dernier clic, pour éviter de refaire la même chose.  ;  Shared NextOrPreviewAsked ; Pour la navigation dans l'historique de recherche.  Shared ExactValueSearch   ; Pour déclencher une recherche, si besoin.  Shared VList.VariableListings  ;  Protected StrRef$, cpos, txtrange.CHARRANGE, ExpressionUnderCursor$ ; Pour l'exploration du contenu du RE_Gadget.  Protected *pTextFont.ITextFont_Fixed  Protected PageAdr$          ; Pour le clic sur le nom d'une fonction native PureBasic.  Protected p, pd, pf, NoLine$           ; Pour le clic sur un nom de fichier ou sur un nom de fonction native.  Protected FNameWithoutPath$            ; Pour le clic sur un numéro de ligne dans la liste "Trouvé dans...".  Protected ImageButtonName$             ; Pour le clic sur une image-bouton.  Protected NoREGadget, pl, ElementType, PosInText, Underlined  ;  NoREGadget = GetREGadgetNbrFromActivePBBPanel()  ;  If NoREGadget    StrRef$ = ReplaceString(GetGadgetText(NoREGadget), Chr(10), "")    ;    TOM_GetSelectionPos(NoREGadget, @txtrange.CHARRANGE)    Underlined = FindString(TOM_GetFontStyles(NoREGadget), "Underline")    cpos = txtrange\cpMin    ;    If Underlined = 0 And txtrange\cpMax - txtrange\cpMin <= 1      ; Le curseur est dans une zone non soulignée et la sélection comporte un seul caractère ou aucun.      ; Il est bien possible que l'utilisateur ait cliqué sur un bouton.      ; On va vérifier ça :      LastClickPos = 0      ImageButtonName$ = GetImageNameFromSelectionPos(NoREGadget)      If ImageButtonName$ = #PBBLeftArrowMarker$        NextOrPreviewAsked - 1      ElseIf ImageButtonName$ = #PBBRightArrowMarker$        NextOrPreviewAsked + 1      EndIf      WalkOverPages(NextOrPreviewAsked, SearchedExpression_gadget)      TOM_SetSelectionPos(NoREGadget, 0, 0)      ;    ElseIf cpos <> LastClickPos And Underlined      LastClickPos = cpos      ;      ; On cherche les limites du soulignement, à gauche et à droite :      Repeat        txtrange\cpMin - 1        *pTextFont = TOM_GetTextFontObj(NoREGadget, txtrange\cpMin, txtrange\cpMin + 1)        *pTextFont\GetUnderline(@pl)        *pTextFont\Release()      Until txtrange\cpMin <= -1 Or pl = #TomNone      txtrange\cpMin + 1      ;      Repeat        *pTextFont = TOM_GetTextFontObj(NoREGadget, txtrange\cpMax, txtrange\cpMax + 1)        *pTextFont\GetUnderline(@pl)        *pTextFont\Release()        If pl <> #TomNone          txtrange\cpMax + 1        EndIf      Until txtrange\cpMax >= Len(StrRef$) Or pl = #TomNone      ;      TOM_SetSelectionPos(NoREGadget, txtrange\cpMin, txtrange\cpMax) ; On sélectionne toute la partie soulignée.      ;      ExpressionUnderCursor$ = TOM_GetText(NoREGadget) ; C'est-à-dire Mid(StrRef$,txtrange\cpMin+1,txtrange\cpMax-txtrange\cpMin).      ;      ; On va réagir au clic      ;      If ExpressionUnderCursor$        ;        SendMessage_(GadgetID(NoREGadget), #EM_SETREADONLY, #False, 0)        TOM_SetFontStyles(NoREGadget, "Underline(Wave)")        SendMessage_(GadgetID(NoREGadget), #EM_SETREADONLY, #True, 0)        ;        ElementType = GetTypeOfExpression(ExpressionUnderCursor$)        ;        If ElementType = #PBBNativeFunction Or ElementType = #PBBBasicKeyword          ;          ; Clic sur le nom d'une fonction native PureBasic.          ; On va ouvrir le fichier d'aide fourni avec PureBasic.          ;          TOM_SetSelectionPos(NoREGadget, 0, 0)          ;          If ElementType = #PBBNativeFunction            p = FindString(PBFunctionListLCase$, "/" + LCase(ExpressionUnderCursor$) + Chr(13))            pd = ReverseFindString(PBFunctionList$, Chr(13), p) + 1            pf = FindString(PBFunctionList$, Chr(13), p)            PageAdr$ = Mid(PBFunctionList$, pd, pf - pd)            PageAdr$ = GetPathPart(PureBasicProgAdr$) + "PureBasic.chm::/" + PageAdr$ + ".html"            RunProgram("hh.exe", Chr(34) + PageAdr$ + Chr(34), GetPathPart(PageAdr$))          Else            RunProgram("https://www.google.com/search?q=purebasic+" + ExpressionUnderCursor$)          EndIf          LastClickPos = 0          ;        ElseIf ExpressionUnderCursor$ = GetTextFromCatalog("MoreInfo")          ;          ; Clic sur "En savoir plus..".          ;          AlertInPBBWindow(GetTextFromCatalog("HelpClickInstruction"))                  ElseIf ExpressionUnderCursor$ = GetTextFromCatalog("SeeVariablesList")          ;          ; Clic sur "Voir la liste complète des variables".          ;          AlertInPBBWindow(VList\CompleteList, VList\ProcedureName + ": variables", 1, 0, 1, 500, "100,250")          ;        ElseIf FindString(ExpressionUnderCursor$, ".") And FindString(PBBListOfFiles$, "\" + ExpressionUnderCursor$, 0)          ;          ; Le clic vient d'avoir lieu sur un nom de fichier.          ;          NoLine$ = ""          If GetActivePBBPanel() = #DetailPBBPanel            ; Nous sommes dans le détail d'un élément et le clic vient d'avoir lieu sur le nom de fichier            ; qui contient cet élément. La mission consiste à demander à l'éditeur PureBasic d'ouvrir le fichier            ; en question et de placer le curseur sur la bonne ligne.            ; On va récupérer le n° de ligne qui se situe normalement à la fin de la ligne de texte.            PosInText = FindString(StrRef$, Chr(13), txtrange\cpMax)            If PosInText              PosInText - 1              While FastMid(StrRef$, PosInText, 1) = "." Or FastMid(StrRef$, PosInText, 1) = ")" : PosInText - 1 : Wend              pf = PosInText + 1              While PosInText And FindString(ListPBSep$, FastMid(StrRef$, PosInText, 1)) = 0 : PosInText - 1 : Wend              PosInText + 1              If Val(FastMid(StrRef$, PosInText, pf - PosInText))                NoLine$ = FastMid(StrRef$, PosInText, pf - PosInText)              EndIf            EndIf          EndIf          OpenFileWithPureBasic(ExpressionUnderCursor$, NoLine$)          ;        ElseIf GetActivePBBPanel() = #FoundInFilesPBBPanel And Val(ExpressionUnderCursor$) > 0          ;          ; Clic sur un numéro de ligne dans la liste "Trouvé dans..."          ;          NoLine$ = ExpressionUnderCursor$          ;          ; On récupère le nom de l'élément qui figure avant.          pf = ReverseFindString(StrRef$, Chr(160) + Chr(13), txtrange\cpMin) ; Le caractère 160 (espace insécable) a été placé                                                                     ; à la fin du nom de fichier par 'CompleteFoundInFIles'                                                                     ; pour servir de point de repère.          PosInText = pf          FastFindPrecReturn(StrRef$, PosInText) ; On remonte jusqu'au début de ligne.          PosInText + 1               FNameWithoutPath$ = Mid(StrRef$, PosInText, pf - PosInText)          OpenFileWithPureBasic(FNameWithoutPath$, NoLine$)          ;        ElseIf GetActivePBBPanel() >= #ProcPBBPanel Or GetActivePBBPanel() = #DetailPBBPanel Or GetActivePBBPanel() = #FoundInFilesPBBPanel          ;          ; Le clic a eu lieu sur le nom d'un élement, dans une liste,          ; dans le panneau de détail ou dans le panneau "Found in...".          ;          If Button = #WM_LBUTTONUP            ; Clic gauche :            ; On affiche le panneau "Détails" :            SetActivePBBPanel(#DetailPBBPanel)          Else            ; Clic droit :            ; On affiche le panneau "Trouvé dans..." :            SetActivePBBPanel(#FoundInFilesPBBPanel)          EndIf          ; On affiche le nom cliqué dans le champs de recherche          SetGadgetText(SearchedExpression_gadget, ExpressionUnderCursor$)          ;          ; On déclenche une recherche, afin de compléter ce qui est affiché dans "Détails" :          ExactValueSearch = #DoProgrammedSearch          ;        Else          ;          ; Si aucun des cas de figure précédents ne s'est vérifié...          ;          ; (Je ne sais pas quoi faire pour le moment).          ;        EndIf      EndIf    EndIf  EndIfEndProcedure;Procedure ResizePBBGadgets()  ;  ; Dimensionnement et redimensionnement des gadgets de la fenêtre principale.  ;  ; Variables de calcul pour le redimensionnement :  Protected MainPanelGadgetWidth, MainPanelGadgetHeight, ResultInsideHeightDecal, ResultInsideWidthDecal  Protected REGadgetsHeight, REGadgetsWidth, PBarWidth, TypeOfElement  ;  ; Dimensionne ou redimensionne les gadgets en fonction de la taille de la fenêtre.  ;  ; Cette procédure n'est appelée qu'à deux occasions : au moment de la création de la fenêtre,  ; et lors d'un événement #PB_Event_SizeWindow.  ;  ; La structure 'GPBBGadgets' qui contient tous les numéros de gadgets est une variable globale.  ;  Protected BWidth = 70  Protected ExternalMargin = 10  Protected SpaceInterFields = 4  ResizeGadget(GPBBGadgets\Adr_gadget, #PB_Ignore, #PB_Ignore, WindowWidth(GPBBGadgets\PBBWindow) - GadgetX(GPBBGadgets\Adr_gadget) - BWidth - ExternalMargin - SpaceInterFields, #PB_Ignore)  ResizeGadget(GPBBGadgets\BChangeAdresse, WindowWidth(GPBBGadgets\PBBWindow) - BWidth - ExternalMargin, #PB_Ignore, BWidth, #PB_Ignore)    ResizeGadget(GPBBGadgets\SearchedExpression_gadget, #PB_Ignore, #PB_Ignore, WindowWidth(GPBBGadgets\PBBWindow) - GadgetX(GPBBGadgets\SearchedExpression_gadget) - BWidth - ExternalMargin - SpaceInterFields, #PB_Ignore)  ResizeGadget(GPBBGadgets\BSearchExpression, WindowWidth(GPBBGadgets\PBBWindow) - BWidth - ExternalMargin, #PB_Ignore, BWidth, #PB_Ignore)  ;  ResizeGadget(GPBBGadgets\GLine, #PB_Ignore, #PB_Ignore, WindowWidth(GPBBGadgets\PBBWindow) - 22, #PB_Ignore)  ;  MainPanelGadgetHeight = (WindowHeight(GPBBGadgets\PBBWindow) - GadgetY(GPBBGadgets\MainPanelGadget) - 27)  MainPanelGadgetWidth = (WindowWidth(GPBBGadgets\PBBWindow) - 19)  ResizeGadget(GPBBGadgets\MainPanelGadget, #PB_Ignore, #PB_Ignore, MainPanelGadgetWidth, MainPanelGadgetHeight)  ResizeGadget(GPBBGadgets\ListsPGadget, #PB_Ignore, #PB_Ignore, MainPanelGadgetWidth - 7, MainPanelGadgetHeight - 29)  ;  PBarWidth = WindowWidth(GPBBGadgets\PBBWindow) / 8  ResizeGadget(GPBBGadgets\EProgressBar, WindowWidth(GPBBGadgets\PBBWindow) - PBarWidth - ExternalMargin - 1, #PB_Ignore, PBarWidth, #PB_Ignore)  ResizeGadget(GPBBGadgets\TProgressBar, WindowWidth(GPBBGadgets\PBBWindow) - BWidth - ExternalMargin - 36, #PB_Ignore, #PB_Ignore, #PB_Ignore)  ;  ResizeGadget(GPBBGadgets\BStats, WindowWidth(GPBBGadgets\PBBWindow) - BWidth - ExternalMargin, #PB_Ignore, BWidth, #PB_Ignore)  ResizeGadget(GPBBGadgets\BRefresh, WindowWidth(GPBBGadgets\PBBWindow) - BWidth - ExternalMargin - 21 - SpaceInterFields, #PB_Ignore, #PB_Ignore, #PB_Ignore)  ;  ResultInsideHeightDecal = 30  ResultInsideWidthDecal = 8  REGadgetsHeight = MainPanelGadgetHeight - ResultInsideHeightDecal  REGadgetsWidth = MainPanelGadgetWidth - ResultInsideWidthDecal  For TypeOfElement = 0 To #EndEnumPBBPanels - 1    If TypeOfElement = #ProcPBBPanel      REGadgetsWidth - 7      REGadgetsHeight - 29    EndIf    If IsGadget(NoREGadgetOfPBBPanel(TypeOfElement))      ResizeGadget(NoREGadgetOfPBBPanel(TypeOfElement), #PB_Ignore, #PB_Ignore, REGadgetsWidth, REGadgetsHeight)    EndIf  Next  ;  ReSizeREMenu()  ;  ResizeGadget(GPBBGadgets\BStick, #PB_Ignore, WindowHeight(GPBBGadgets\PBBWindow) - 26, #PB_Ignore, #PB_Ignore)  ResizeGadget(GPBBGadgets\BAbout, WindowWidth(GPBBGadgets\PBBWindow) - GadgetWidth(GPBBGadgets\BQuit) - GadgetWidth(GPBBGadgets\BAbout) - ExternalMargin - 8, WindowHeight(GPBBGadgets\PBBWindow) - 26, #PB_Ignore, #PB_Ignore)  ResizeGadget(GPBBGadgets\BLanguage, WindowWidth(GPBBGadgets\PBBWindow) - GadgetWidth(GPBBGadgets\BQuit) - GadgetWidth(GPBBGadgets\BAbout) - GadgetWidth(GPBBGadgets\BLanguage) - ExternalMargin - 16, WindowHeight(GPBBGadgets\PBBWindow) - 26, #PB_Ignore, #PB_Ignore)  ResizeGadget(GPBBGadgets\BQuit, WindowWidth(GPBBGadgets\PBBWindow) - GadgetWidth(GPBBGadgets\BQuit) - 10, WindowHeight(GPBBGadgets\PBBWindow) - 26, #PB_Ignore, #PB_Ignore)  ;  ; On redessine la WhiteBox aux nouvelles dimensions de la fenêtre :  GPBBGadgets\IWhiteOver = WhiteBoxOverWindow(GPBBGadgets\PBBWindow)  ;EndProcedure;Macro PBBUpdateMainFile(NewSFile = "", Refresh = 0)  ;  ; Cette macro est appelée par OpenPBBMainWindow(), ManagePipeMessages() et PBBrowserMainProc()  ; Elle met à jour le nom du fichier principal et (re)lance l'exploration profonde si nécessaire.  ;  Shared BackgroundTasksCompletion  Shared ExactValueSearch  ;  mPBBListOfFiles$ = PBBListOfFiles$  ;  If NewSFile = ""    NewSFile = FicPrincipalPB$  EndIf  ;  NewSFile = SetListOfFiles(NewSFile, #ShowCompletionWindow)  ;  Reload = 0  ;  If PBBListOfFiles$    PosInFileList = 0    Repeat       PosInFileList + 1      LineC$ = StringField(PBBListOfFiles$, PosInFileList, Chr(13))      If LineC$        If FindString(mPBBListOfFiles$, StringField(LineC$, 1, Chr(9))) = 0          Reload = 1        EndIf      EndIf    Until LineC$ = ""  EndIf  ;  If Reload Or Refresh    ; La liste des fichiers a augmenté ou l'utilisateur a demandé une mise à jour.    ; On se met à jour.    FicPrincipalPB$ = NewSFile    If OpenPreferencesWithPatience(PBBrowserPrefile$) ; PBBrowserPrefile$ est une variable globale.      WritePreferenceString("FicPrincipalPB", FicPrincipalPB$)      ClosePreferences()    EndIf    ;    FillFileREGadget()    ;    SetGadgetText(GPBBGadgets\Adr_gadget, GetFilePart(FicPrincipalPB$))    If FileSize(FicPrincipalPB$) > 2      BOText$ = GetTextFromCatalog("Change")    Else      BOText$ = GetTextFromCatalog("Open")    EndIf    SetGadgetText(GPBBGadgets\BChangeAdresse, BOText$)    ;    If FileSize(FicPrincipalPB$) > 2      BackgroundTasksCompletion = #BackgroundTasksMustRestart ; Ceci va provoquer le (re)lancement de l'exploration profonde.    EndIf  Else    ; Certains fichiers ont peut-être été modifiés.    ; on met la mémoire à jour.    UpdateAllFilesInMemory()  EndIf  ;EndMacro;#PBBMenu_CommandOffset = 200 ; Valeur de décalage des numéro des commandes dans les menus.                             ; Cette valeur a pour objectif d'empêcher un chevauchement entre                             ; les raccourcis attribués directement dans le programme                             ; et ceux qui sont choisis par l'utilisateur pour chacun                             ; des outils..;Procedure UpdatePBBMenus()  ;  ; Construit le menu hamburger des Gadgets de liste gérés par PBBrowserMainProc()  ;  If IsMenu(GPBBGadgets\REMenu)    FreeMenu(GPBBGadgets\REMenu)  EndIf  GPBBGadgets\REMenu = CreatePopupMenu(#PB_Any)  MenuItem(#REM_ZoomIn,       GetTextFromCatalog("ZoomIn")       + Chr(9) + "CTRL + '+'")  MenuItem(#REM_ZoomOut,      GetTextFromCatalog("ZoomOut")      + Chr(9) + "CTRL + '-'")  MenuItem(#REM_ZoomReset,    GetTextFromCatalog("ZoomReset")    + Chr(9) + "CTRL + 0")  MenuBar()  MenuItem(#REM_FindInPannel, GetTextFromCatalog("FindInPannel") + Chr(9) + "CTRL + F")  MenuBar()  MenuItem(#REM_CopyAll,      GetTextFromCatalog("CopyAll"))  MenuItem(#REM_SaveAsText,   GetTextFromCatalog("SaveAsText")   + Chr(9) + "CTRL + S")  MenuItem(#REM_SaveAsRTF,    GetTextFromCatalog("SaveAsRTF")    + Chr(9) + "CTRL + R")  ;  ; Construit le menu de la fenêtre principale géré par PBBrowserMainProc()  ;  Protected MenuLine$  ;  If IsMenu(GPBBGadgets\Menu)    FreeMenu(GPBBGadgets\Menu)  EndIf  GPBBGadgets\Menu = CreatePopupMenu(#PB_Any)  MenuItem(#PBBMenu_THAT, GetTextFromCatalog("OpenTHATWindow") + Chr(9) + "CTRL + I")  MenuBar()  ForEach CommandList()    If CommandList()\CommandDontShow = 0      MenuLine$ = GetTranslatedCommandName(CommandList()\CommandNo)      If CommandList()\CommandShortCut        MenuLine$ + Chr(9) + ComputeShortcutString(CommandList()\CommandShortCut)      EndIf      MenuItem(CommandList()\CommandNo + #PBBMenu_CommandOffset, MenuLine$)    EndIf    If CommandList()\CommandShortCut      AddKeyboardShortcut(GPBBGadgets\PBBWindow, CommandList()\CommandShortCut, CommandList()\CommandNo + #PBBMenu_CommandOffset)    EndIf  NextEndProcedure;Procedure SetPBBGadgetsTitles()  ;   Shared PBBCustomLinks$ ; Liste de liens cliquables dans les textes affichés.    PBBCustomLinks$ = GetTextFromCatalog("MoreInfo") + Chr(13) + GetTextFromCatalog("SeeVariablesList") + Chr(13)  ;  Protected txa$, Panel  ;  SetGadgetText(GPBBGadgets\AdrTitle, GetTextFromCatalog("MainFileLabel"))  SetGadgetText(GPBBGadgets\BChangeAdresse, GetTextFromCatalog("Open"))  SetGadgetText(GPBBGadgets\ProcNameTitle, GetTextFromCatalog("Expression"))  SetGadgetText(GPBBGadgets\BSearchExpression, GetTextFromCatalog("Search"))  txa$ = GetTextFromCatalog("SearchInstructions")  RemoveBalloonToolTip(GPBBGadgets\Tooltip, GPBBGadgets\SearchedExpression_gadget)    AddBalloonToolTip(GPBBGadgets\Tooltip, GPBBGadgets\SearchedExpression_gadget, txa$)  RemoveBalloonToolTip(GPBBGadgets\Tooltip, GPBBGadgets\BSearchExpression)    AddBalloonToolTip(GPBBGadgets\Tooltip, GPBBGadgets\BSearchExpression, txa$)  SetGadgetText(GPBBGadgets\TProgressBar, GetTextFromCatalog("Exploration"))  SetGadgetText(GPBBGadgets\BStats, GetTextFromCatalog("Statistics"))  RemoveBalloonToolTip(GPBBGadgets\Tooltip, GPBBGadgets\BRefresh)  AddBalloonToolTip(GPBBGadgets\Tooltip, GPBBGadgets\BRefresh, GetTextFromCatalog("RefreshEx"))  SetGadgetItemText(NoGadgetPBBPanel(#FilePBBPanel), NoPBBPanel(#FilePBBPanel), GetTextFromCatalog(PBBPanelNames$(#FilePBBPanel)))  SetGadgetItemText(NoGadgetPBBPanel(#ListPBBPanel), NoPBBPanel(#ListPBBPanel), GetTextFromCatalog(PBBPanelNames$(#ListPBBPanel)))  For Panel = #ProcPBBPanel To #EndEnumPBBPanels - 1    SetGadgetItemText(GPBBGadgets\ListsPGadget, NoPBBPanel(Panel), GetTextFromCatalog(PBBPanelNames$(Panel)))  Next  SetGadgetItemText(NoGadgetPBBPanel(#DetailPBBPanel), NoPBBPanel(#DetailPBBPanel), GetTextFromCatalog(PBBPanelNames$(#DetailPBBPanel)))  SetGadgetItemText(NoGadgetPBBPanel(#FoundInFilesPBBPanel), NoPBBPanel(#FoundInFilesPBBPanel), GetTextFromCatalog(PBBPanelNames$(#FoundInFilesPBBPanel)))    SetGadgetText(GPBBGadgets\BStick, GetTextFromCatalog("AlwaysOnTop"));     If OpenPreferencesWithPatience(PBBrowserPrefile$);       PBBLanguageFolder$ = ReadPreferenceString ("PBBLanguageFolder", "");       ClosePreferences();       PBBLanguageFolder$ = ReplaceString(PBBLanguageFolder$, GetParentFolder(PBBLanguageFolder$), "");       PBBLanguageFolder$ = Trim(ReplaceString(PBBLanguageFolder$, "\", ""));       SetGadgetText(GPBBGadgets\BLanguage, PBBLanguageFolder$);     EndIf  SetGadgetText(GPBBGadgets\BAbout, GetTextFromCatalog("About"))  SetGadgetText(GPBBGadgets\BQuit , GetTextFromCatalog("Quit"))    ;  UpdatePBBMenus()  ;  PBBInitAlertTexts()  ;EndProcedure;Procedure OpenPBBMainWindow(WSticky)  ;  ; Ouverture de la fenêtre princpale et création de ses gadgets.  ;  Protected VPos, RefImg  Protected txa$, Panel  ;  GPBBGadgets\PBBWindow = OpenWindowFromPrefCoordonnates(PBBrowserPrefile$, "PureBasic Browser " + PBB_NumVersion$, 400, 400)  ;  If IsWindow(GPBBGadgets\PBBWindow)    WindowBounds(GPBBGadgets\PBBWindow, 400, 400, #PB_Ignore, #PB_Ignore)    StickyWindow(GPBBGadgets\PBBWindow, WSticky)    BindEvent(#PB_Event_SizeWindow, @ResizePBBGadgets(), GPBBGadgets\PBBWindow)    ;________________________________________________________    ;    ;     Création des gadgets de la fenêtre principale    ;________________________________________________________    ;    ; Dans ce qui va suivre, beaucoup de dimensions de gadgets sont simplement fixées à '1',    ; car la procédure ResizePBBGadgets() va, de toute façon, se charger de les redimensionner.    ;    Protected ExternalMargin = 10    Protected UpMargin = 5    ;    GPBBGadgets\AdrTitle = TextGadget(#PB_Any, ExternalMargin, UpMargin + 2, 79, 18, "")    SetGadgetColor(GPBBGadgets\AdrTitle, #PB_Gadget_FrontColor, PBBTitleColor)    SetGadgetFont(GPBBGadgets\AdrTitle, PBBTitleFont)    GPBBGadgets\Adr_gadget = EditorGadget(#PB_Any, 80 + ExternalMargin, UpMargin + 1, 1, 20, #PB_Editor_ReadOnly)    SendMessage_(GadgetID(GPBBGadgets\Adr_gadget), #EM_SETTEXTMODE, #TM_RICHTEXT, 0)    SendMessage_(GadgetID(GPBBGadgets\Adr_gadget), #EM_SHOWSCROLLBAR, #SB_HORZ, #False)    GPBBGadgets\BChangeAdresse = ButtonGadget(#PB_Any, 1, UpMargin, 1, 22, "")    ;    VPos = UpMargin + 20 + 5    ;    GPBBGadgets\ProcNameTitle = TextGadget(#PB_Any, ExternalMargin, VPos + 2, 79, 20, "")    SetGadgetColor(GPBBGadgets\ProcNameTitle, #PB_Gadget_FrontColor, PBBTitleColor)    SetGadgetFont(GPBBGadgets\ProcNameTitle, PBBTitleFont)    GPBBGadgets\SearchedExpression_gadget = EditorGadget(#PB_Any, 80 + ExternalMargin, VPos + 1, 1, 20)    SendMessage_(GadgetID(GPBBGadgets\SearchedExpression_gadget), #EM_SETTEXTMODE, #TM_RICHTEXT, 0)    SendMessage_(GadgetID(GPBBGadgets\SearchedExpression_gadget), #EM_SHOWSCROLLBAR, #SB_HORZ, #False)    GPBBGadgets\BSearchExpression = ButtonGadget(#PB_Any, 1, VPos, 1, 22, "")    GPBBGadgets\Tooltip = InitBalloonToolTip(GPBBGadgets\PBBWindow)        AddBalloonToolTip(GPBBGadgets\Tooltip, GPBBGadgets\SearchedExpression_gadget, txa$)    AddBalloonToolTip(GPBBGadgets\Tooltip, GPBBGadgets\BSearchExpression, txa$)    ;    VPos + 20 + 5    ;    GPBBGadgets\GLine = FrameGadget(#PB_Any, ExternalMargin + 1, VPos - 1, 1, 1, "", #PB_Frame_Flat)    ;    VPos + 4    ;    GPBBGadgets\TProgressBar = TextGadget(#PB_Any, 1, VPos - 1, 105, 15, "", #PB_Text_Right)    SetGadgetFont(GPBBGadgets\TProgressBar, ProgressLegendFont)    SetGadgetColor(GPBBGadgets\TProgressBar, #PB_Gadget_FrontColor, PBBTitleColor)    GPBBGadgets\EProgressBar = ProgressBarGadget(#PB_Any, 1, VPos + 15, 1, 8, 0, 100, #PB_ProgressBar_Smooth)    SetWindowTheme_(GadgetID(GPBBGadgets\EProgressBar), #Empty$, #Empty$)    SetGadgetColor(GPBBGadgets\EProgressBar, #PB_Gadget_FrontColor, PBBTitleColor)    ;    GPBBGadgets\BStats = ButtonGadget(#PB_Any, 1, VPos, 70, 22, "")    HideGadget(GPBBGadgets\BStats, #True)    UseJPEGImageDecoder()    RefImg = LoadImage(#PB_Any,  MyAppDataFolder$ + "Refresh.jpg")    If IsImage(RefImg)      GPBBGadgets\BRefresh = ButtonImageGadget(#PB_Any, 1, VPos, 22, 22, ImageID(RefImg))    Else      Alert("Program Error: Unable to load 'Refresh.jpg'")      End    EndIf        HideGadget(GPBBGadgets\BRefresh, #True)    ;    ; La création des panneaux des PanelGadgets fait usage des tableaux créés dans PBBrowserDeclarations.pb    ; Pour chaque panneau :    ; PBBPanelNames$() comporte le nom du panneau. Ce tableau à été mis à jour dans PBBrowserDeclarations.pb    ; NoPBBPanel() comportera le numéro du panneau dans son PanelGadget.    ;   Pour tous les panneaux de 'MainPanelGadget', on a NoPBBPanel(x) = x, mais pour les panneaux    ;   de 'ListsPGadget', on a par exemple NoPBBPanel(#ProcPBBPanel) = 0, alors que #ProcPBBPanel = 4    ; NoGadgetPBBPanel() comportera le numéro de gadget du PanelGadget contenant le panneau,    ;   c'est-à-dire 'MainPanelGadget' ou 'ListsPGadget'    ; NoREGadgetOfPBBPanel() comportera le numéro du RichEdit gadget (EditorGadget) qui va être créé dans le panneau    ; TypeElementOfPBBPanel() dans le cas où le panneau est un panneau de liste d'éléments (procédures, structures,etc.),    ;   ce tableau contient le type d'élément correspondant  (#PBBProcedure, #PBBStructure, #PBBMacro, etc.)    ; TypeElementOfPBBPanel() a été initialisé dans PBBrowserDeclarations.pb    ;    GPBBGadgets\MainPanelGadget = PanelGadget(#PB_Any, ExternalMargin, Vpos, 1, 1)      AddGadgetItem(GPBBGadgets\MainPanelGadget, -1, "")      NoGadgetPBBPanel(#FilePBBPanel) = GPBBGadgets\MainPanelGadget      NoPBBPanel(#FilePBBPanel) = CountGadgetItems(GPBBGadgets\MainPanelGadget) - 1        NoREGadgetOfPBBPanel(#FilePBBPanel) = EditorGadget(#PB_Any, 0, 0, 1, 1, #PB_Editor_ReadOnly)        SetREGadgetParam(NoREGadgetOfPBBPanel(#FilePBBPanel))      AddGadgetItem(GPBBGadgets\MainPanelGadget, -1, "")      NoPBBPanel(#ListPBBPanel) = CountGadgetItems(GPBBGadgets\MainPanelGadget) - 1      NoGadgetPBBPanel(#ListPBBPanel) = GPBBGadgets\MainPanelGadget        GPBBGadgets\ListsPGadget = PanelGadget(#PB_Any, 0, 0, 1, 1)        For Panel = #ProcPBBPanel To #EndEnumPBBPanels - 1          AddGadgetItem(GPBBGadgets\ListsPGadget, -1, "")          NoGadgetPBBPanel(Panel) = GPBBGadgets\ListsPGadget          NoPBBPanel(Panel) = CountGadgetItems(GPBBGadgets\ListsPGadget) - 1          NoREGadgetOfPBBPanel(Panel) = EditorGadget(#PB_Any, 0, 0, 1, 1, #PB_Editor_ReadOnly)          SetREGadgetParam(NoREGadgetOfPBBPanel(Panel))        Next        CloseGadgetList()      AddGadgetItem(GPBBGadgets\MainPanelGadget, -1, "")      NoPBBPanel(#DetailPBBPanel) = CountGadgetItems(GPBBGadgets\MainPanelGadget) - 1      NoGadgetPBBPanel(#DetailPBBPanel) = GPBBGadgets\MainPanelGadget        NoREGadgetOfPBBPanel(#DetailPBBPanel) = EditorGadget(#PB_Any, 0, 0, 1, 1, #PB_Editor_ReadOnly)        SetREGadgetParam(NoREGadgetOfPBBPanel(#DetailPBBPanel))      AddGadgetItem(GPBBGadgets\MainPanelGadget, -1, "")      NoPBBPanel(#FoundInFilesPBBPanel) = CountGadgetItems(GPBBGadgets\MainPanelGadget) - 1      NoGadgetPBBPanel(#FoundInFilesPBBPanel) = GPBBGadgets\MainPanelGadget        NoREGadgetOfPBBPanel(#FoundInFilesPBBPanel) = EditorGadget(#PB_Any, 0, 0, 1, 1, #PB_Editor_ReadOnly)        SetREGadgetParam(NoREGadgetOfPBBPanel(#FoundInFilesPBBPanel))    CloseGadgetList()    ;    GPBBGadgets\BREMenu = ButtonGadget(#PB_Any, 1, 1, 20, 19, "☰")    SetWindowPos_(GadgetID(GPBBGadgets\BREMenu), #HWND_TOP, 0, 0, 0, 0, #SWP_NOMOVE | #SWP_NOSIZE)    ;    GPBBGadgets\BStick = CheckBoxGadget(#PB_Any, ExternalMargin, 1, 120, 22, "")    SetGadgetState(GPBBGadgets\BStick, WSticky)    GPBBGadgets\BLanguage = ButtonGadget(#PB_Any, ExternalMargin + 120 + 5, 1, 80, 22, "Language")    GPBBGadgets\BAbout = ButtonGadget(#PB_Any, 1, 1, 100, 22, "")    GPBBGadgets\BQuit = ButtonGadget(#PB_Any, 1, 1, 60, 22, "")    ;    ResizePBBGadgets()    ;    ; Raccourcis de la fenêtre principale    ; Les constantes correspondant à ces raccourcis sont définies dans 'PBBrowserDeclarations.pb'    ;    AddKeyboardShortcut(GPBBGadgets\PBBWindow, #PB_Shortcut_Return,                 #PBBMenu_Return)    AddKeyboardShortcut(GPBBGadgets\PBBWindow, #PB_Shortcut_Escape,                 #PBBMenu_Escape)    AddKeyboardShortcut(GPBBGadgets\PBBWindow, #PB_Shortcut_Tab,                    #PBBMenu_NextPanel)    AddKeyboardShortcut(GPBBGadgets\PBBWindow, #PB_Shortcut_Tab | #PB_Shortcut_Shift, #PBBMenu_PreviousPanel)    AddKeyboardShortcut(GPBBGadgets\PBBWindow, #PB_Shortcut_Up,                     #PBBMenu_Up)    AddKeyboardShortcut(GPBBGadgets\PBBWindow, #PB_Shortcut_Down,                   #PBBMenu_Down)    AddKeyboardShortcut(GPBBGadgets\PBBWindow, #PB_Shortcut_PageUp,                 #PBBMenu_PageUp)    AddKeyboardShortcut(GPBBGadgets\PBBWindow, #PB_Shortcut_PageDown,               #PBBMenu_PageDown)    AddKeyboardShortcut(GPBBGadgets\PBBWindow, #PB_Shortcut_Right,                  #PBBMenu_NextPage)    AddKeyboardShortcut(GPBBGadgets\PBBWindow, #PB_Shortcut_Left,                   #PBBMenu_PreviousPage)    ;    AddKeyboardShortcut(GPBBGadgets\PBBWindow, #PB_Shortcut_Control | #PB_Shortcut_Q, #PBBMenu_Find)    AddKeyboardShortcut(GPBBGadgets\PBBWindow, #PB_Shortcut_Control | #PB_Shortcut_I, #PBBMenu_THAT)    ;    ; Raccourcis du menu hamburger    ; Les constantes correspondant à ce menu sont définies dans 'PBBrowserDeclarations.pb'    ;    AddKeyboardShortcut(GPBBGadgets\PBBWindow, #PB_Shortcut_Control | #PB_Shortcut_Add,      #REM_ZoomIn)    AddKeyboardShortcut(GPBBGadgets\PBBWindow, #PB_Shortcut_Control | #VK_OEM_PLUS,          #REM_ZoomIn)    AddKeyboardShortcut(GPBBGadgets\PBBWindow, #PB_Shortcut_Control | #PB_Shortcut_Subtract, #REM_ZoomOut)    AddKeyboardShortcut(GPBBGadgets\PBBWindow, #PB_Shortcut_Control | #VK_OEM_MINUS,         #REM_ZoomOut)    AddKeyboardShortcut(GPBBGadgets\PBBWindow, #PB_Shortcut_Control | #PB_Shortcut_0,        #REM_ZoomReset)    AddKeyboardShortcut(GPBBGadgets\PBBWindow, #PB_Shortcut_Control | #PB_Shortcut_F,        #REM_FindInPannel)    ;    AddKeyboardShortcut(GPBBGadgets\PBBWindow, #PB_Shortcut_Control | #PB_Shortcut_S,        #REM_SaveAsText)    AddKeyboardShortcut(GPBBGadgets\PBBWindow, #PB_Shortcut_Control | #PB_Shortcut_R,        #REM_SaveAsRTF)    ;    ; On crée un rectange blanc semi-transparent qui va se superposer avec le contenu de la fenêtre    ; lorsque l'on veut montrer que la fenêtre est inactive.    GPBBGadgets\IWhiteOver = WhiteBoxOverWindow(GPBBGadgets\PBBWindow)    ;    SetPBBGadgetsTitles()    ;    ProcedureReturn #True  EndIfEndProcedure;Procedure ManagePBBBackgroundTasks()  ;  ;  Gestion des tâches de fond  ;  ; Cette procédure est appelée à chaque cycle de la boucle principale de PBBrowserMainProc.  ; Son rôle est de gérer les tâches de fond consistant à explorer les fichiers qui ont  ; été listés par 'SetListOfFiles(). Cette exploration sera interrompue toutes les 200 millisecondes,  ; pour reprendre au cycle suivant, ce qui revient à partager le temps disponible entre la gestion  ; des actions de l'utilisateur (dans la boucle principale) et les tâches d'exploration (dans la  ; présente procédure), comme  si l'application fonctionnait en mode multi-thread.  ; Alors, pourquoi ne pas avoir utilisé le mode Multi-thread ?  ; • Parce que l'option 'multi-thread safe' ralentit de façon importante le traitement  ;   des chaînes de caractères, alors qu'on a justement énormément besoin de performance  ;   sur ce type de traitement.  ; • Parce que le multi-thread peut donner à l'utilisateur l'impression que la machine rame,  ;   quand les tâches de fond sont très consommatrices de puissance (ce qui est le cas ici).  ;  ; Cette procédure va répartir le temps-machine en essayant de l'optimiser :  ; • Tant que l'utilisateur ne fait rien, la quasi-totalité du temps-machine est affecté  ;   à l'exécution des tâches de fond. Toutes les 200 millisecondes, on fait un simple  ;   WindowEvent() pour voir s'il se passe quelque chose et, dans la négative, on relance  ;   l'exécution des tâches de fond.  ; • Dès que l'utilisateur fait quelque chose (bouger la souris, par exemple), on lui donne  ;   toute la puissance de la machine en suspendant l'exécution des tâches de fond pendant  ;   50 ms. Ainsi, l'utilisateur n'a pas du tout l'impression que sa machine rame.  ;  ; Le résultat obtenu par cette méthode est satisfaisant, mais il impose des contraintes  ; importantes à la programmation des tâches de fond :  ; 1- Aucun process ne doit avoir une durée d'exécution supérieure à 200 ms, pour ne pas  ;    donner à l'utilisateur le sentiment que sa machine est bloquée. Cela oblige à  ;    fractionner ces tâches en tous petits segments, et à tester régulièrement le temps  ;    écoulé, afin d'interrompre la tâche quand ce temps atteint les 200 ms.  ; 2- Lorsque l'on reprend l'exécution de la tâche, il faut savoir exactement où on s'était  ;    arrêté la fois précédente, afin de reprendre au même endroit. Cela oblige à mémoriser  ;    pas mal de choses, est à mettre en place de nombreuses variables 'Static' ou 'Global',  ;    afin de garder la trâce de la progression.  ;  ; Plus la tâche de fond est complexe à réaliser, plus ces deux contraintes peuvent sembler lourdes.  ; Mais, en réalité, ce sont toujours les mêmes méthodes qui sont appliquées pour y faire  ; face :  ; 1- Dans chaque boucle d'exécution, il faut regarder l'heure à sa montre, et sortir de la  ;    boucle quand il est temps de le faire.  ; 2- Juste après être sorti de la boucle, il faut se dire que le boulot n'est pas forcément  ;    terminé et qu'il faut mémoriser la stade d'exécution où l'on était.  ; 3- Avant d'entrer dans la boucle, il faut toujours se dire qu'on y rentre pas forcément pour  ;    la première fois et qu'une partie du boulot a peut-être déjà été faite. Il faut simplement  ;    disposer des bonnes variables Static ou Global pour nous rappeler où on en était.  ;  ; Malgré tout, la mise en œuvre de ces méthodes a produit un résultat qui pourra sembler complexe  ; au programmeur entrant dans ce code pour la première fois, car certaines tâches de fond sont  ; vraiment lourdes et il a fallu les découper en une myriade de fragments organisés de façon  ; hiérarchique, pour obéir aux contraintes énoncées ci-dessus.  ;  ; Pour comprendre l'oganisation adoptée, il faut s'imaginer que 'ManagePBBBackgroundTasks()'  ; explore les feuilles d'un arbre une à une, en grimpant le long des branches et de leurs ramures  ; à tout de rôle. Quand une feuille a été explorée, on passe à la feuille suivante. Quand une  ; ramure a été explorée, on passe à la remure suivante. Quand une branche a été explorée, on  ; passe à la branche suivante.  ;  ; Les deux branches principales sont :  ; • 'SetAllListsOfAllElements()' qui dresse un inventaire de tous les 'éléments' composant le code :   ;   Procedures, Macros, Structures, Enumerations, Constantes, etc.  ;   - Cette première branche fait appel à répétition à 'SetOneListOfAllElements()'.  ;       - 'SetOneListOfAllElements()' fait appel à répétition à 'CompleteListOfAllElements()'.  ;           - 'CompleteListOfAllElements()' explore les fichiers un par un et morceau par morceau.  ; • 'SetAllListsOfUsedElements()' s'appuie sur l'inventaire précédemment établi pour déterminer  ;   quels sont les éléments réellement utilisés par le programme principal.  ;   - Cette branche appelle à répétition ExecuteSerialCompletionsForUsedElements(),  ;       - qui appelle à répétition CompleteListOfUsedElements(),  ;          - qui parcourt des fragments de code pour regarder si un élément donné y figure.  ;  ; Les résultats de ces deux types d'exploration sont stockés dans des tableaux déclarés en 'Global'.  ; • ListOfAllElements$() contiendra la liste complète des éléments identifiés (déclarés d'une façon ou d'une autre).  ; • ListOfUsedElements$() contiendra la liste des éléments réellements utilisés par le fichier principal.  ;   Les éléments non-utilisés seront affichés en gris.  ;   Une fois la liste des éléments utilisés établis, ListOfUsedElements$() est effacé pour libérer la mémoire.  ;   car le produit de l'exploration profonde est également stocké dans l'un des champs de ListOfAllElements$().  ;  ;  Shared BackgroundTasksCompletion ; Indique l'état d'avancement de l'exploration.                                   ; Cette valeur est initialisée au démarrage du programme                                   ; ou dans la Macro PBBUpdateMainFile, lorsque l'utilisateur                                   ; change de fichier principal. Elle est mise à jour dans ce                                   ; qui suit, au fur et à mesure de l'avancée des explorations.  ;  ; Quand BackgroundTasksCompletion = #BackgroundTasksCompleted toutes les tâches de fond ont été achevées.  ; Elle vaut '#BackgroundTasksUncompleted' tant qu'elles sont en cours,  ; ou '#BackgroundTasksHavePriority' si l'utilisateur par l'une de ses actions, provoque l'exploration profonde en priorité.  ; Quand l'utilisateur change de fichier principal, BackgroundTasksCompletion = '#BackgroundTasksMustRestart'.    ;  Shared RefreshEPanel             ; Quand cette variable est différente de #False, cela                                   ; provoque un rafraîchissement de l'affichage pour certains panneaux.                                   ; La présente procédure va attribuer la valeur #True, une fois par seconde                                   ; à cette variable, pendant toute la phase d'exploration profonde.  Shared PBBWaitingGadget          ; Peut contenir le numéro d'un gagdet quand une fenêtre d'attente                                   ; a été ouverte par ManageWaitingWindow(). Cela donne à cette variable                                   ; le rôle d'indicateur : si elle est différente de zéro,                                   ; c'est qu'une fenêtre d'attente est ouverte.  ;  Shared TFileLength       ; Taille cumulée de tous les fichiers. Utile pour calculer la progression de l'exploration.                           ; Cette valeur est calculée par FillFileREGadget()  ;  Shared PBB_LastEventTime ; Ce timer contient l'heure du dernier évènement utilisateur (mouvement de souris, par exemple).  ;  Shared ExactValueSearch  ; Cette variable indique à PBBrowserMainProc qu'il faut relancer une recherche.                           ;      Dans le cas présent, cela aura pour but de rafraîchir l'affichage des panneaux                           ; 'Détails' et 'Trouvé dans...'  ;  Shared StatReport$ ; Contiendra les statistiques sur l'exploration et sur le code.  Shared PBBRichEditMessage ; Message du RichEdit Gadget courant.  ;  ; Timers  ;  Static LastTimeForBackgroundTasksEnding ; Heure de la dernière fois ou  les tâches de fond se sont interrompues.  Static StartTimeForBackgroundTasks      ; Heure du dernier démarrage des tâches de fond.  Static LastEPanelRefreshTime            ; Heure de la dernière fois où RefreshPanel a été positionnée à #True.  Static TotOutTime                       ; Temps total écoulé depuis le tout début des explorations.  ;  Static ExploringPhase, ExploringGoal, FirstExplorationProgress ; Pour le calcul de la progression de l'exploration.  ;  Protected SALParam, TypeOfElement  ;  Protected EventID ; Valeur de retour  ;  If FileSize(FicPrincipalPB$) < 1 Or PBBListOfFiles$ = ""    BackgroundTasksCompletion = #BackgroundTasksCompleted    HideGadget(GPBBGadgets\EProgressBar, #True)    HideGadget(GPBBGadgets\TProgressBar, #True)    HideGadget(GPBBGadgets\BStats, #True)    HideGadget(GPBBGadgets\BRefresh, #True)  EndIf  ;  ; *****************************************************************  ;                  Supension des tâches de fond  ;  ; Ce qui va suivre a pour but de reprendre la main sur les tâches de fond,  ; lorsque l'utilisateur est actif dans l'application.  ; Nous allons filtrer les événements pour ne retenir que ceux qui sont  ; réellement provoqués par les actions de l'utilisateur et ne pas tenir  ; compte de ceux qui sont provoqués par la mise à jour du EProgressBar.  ;  ;  If BackgroundTasksCompletion <> #BackgroundTasksCompleted    ;    ; Tant qu'il reste des tâches de fond à traîter, on examine les événements    ; de la fenêtre en boucle, sans forcément attendre qu'un événement ait lieu,    ; c'est-à-dire que l'on utilise 'WindowEvent()' et non 'WaitWindowEvent()'.    ; Cela va absorber le plus grande partie de la puisssance de l'ordinateur    ; sur lequel tourne l'application, mais nous avons besoin de cette puissance    ; et cela ne durera que jusqu'à la fin de l'exploration des fichiers.    EventID = WindowEvent()    ;    ; On ne tient compte des événements de l'application que lorsque la fenêtre d'attente    ; n'est pas affichée, car si elle est affichée, c'est que l'utilisateur à demandé    ; à ce que l'exploration profonde soit terminée en priorité :    If PBBWaitingGadget = 0      If PBBRichEditMessage ; PBBRichEditCallback() a détecté un évènement dans un panneau.        PBB_LastEventTime = ElapsedMilliseconds()      ElseIf EventID And EventGadget() <> GPBBGadgets\EProgressBar And EventGadget() <> GPBBGadgets\TProgressBar        If EventType() Or (EventID & #WM_MOUSEMOVE) Or EventID = #PB_Event_Menu          ;          ; #WM_TIMER et 280 (combinaison non identifée) sont provoqués          ; par le rafraîchissement de la ProgressBar.          ; Il n'est pas utile de gérer ces événements en urgence.          ; On ne suspend pas les tâches de fond lorsqu'ils ont lieu.          If EventID <> #WM_TIMER And EventID <> 280             PBB_LastEventTime = ElapsedMilliseconds()            ; Le fait de mettre à jour 'PBB_LastEventTime' va suspendre l'exécution            ; des tâches de fond pendant 50 millisecondes, afin de rester à            ; l'écoute de ce que l'utilisateur est en train de faire et d'y            ; réagir aussi rapidement que possible.          EndIf        EndIf      EndIf    EndIf  Else    EventID = WaitWindowEvent(100)    ; Les tâches de fond (l'exploration profonde) sont terminées.    ; On utilise WaitWindowEvent() afin de ne consommer que la puissance-machine    ; qui est nécessaire.  EndIf  ;  ; *****************************************************************  ;  ;                   Gestion des tâches de fond  ;  If (ElapsedMilliseconds() - PBB_LastEventTime) > 50 Or BackgroundTasksCompletion = #BackgroundTasksHavePriority    ; Si l'application n'a pas d'événements-utilisateur à gérer depuis 50 millisecondes,    ; on exécute les tâches de fond.    ;    If BackgroundTasksCompletion = #BackgroundTasksMustRestart      ;      ; Les tâches de fond sont à faire ou à recommencer.      ;      ; On active donc le EProgressBar qui affiche la progression des tâches de fond :      HideGadget(GPBBGadgets\EProgressBar, #False)      HideGadget(GPBBGadgets\TProgressBar, #False)      HideGadget(GPBBGadgets\BStats, #True)      HideGadget(GPBBGadgets\BRefresh, #True)      ;      ; (Re)initialisation des variables.      ;      ;      ; On initialise le compteur qui va permettre de mesurer      ; le temps passé en dehors des tâches de fond.      LastTimeForBackgroundTasksEnding = ElapsedMilliseconds()      ; StartTimeForBackgroundTasks va mesurer le temps consacré à l'exécution      ; des tâches de fond. On l'initalise aussi.      StartTimeForBackgroundTasks = ElapsedMilliseconds()      ;      ; Variables permettant le calcul de la barre de progression :      ExploringPhase = 1      ExploringGoal = 0      FirstExplorationProgress = 0      ;      OutOfElementContent\s = "" ; Variable globale qui contient tout le code 'hors-éléments'.      ;      ; On indique que les listes sont à recalculer :      ;      For TypeOfElement = #PBBProcedure To #EndEnumPBBElementTypes - 1        ListCompletionAll(TypeOfElement)  = #ListCompletion_Undone        ListCompletionUsed(TypeOfElement) = #ListCompletion_Undone        ListCompletionStepsCompleted(TypeOfElement) = 0      Next      EraseAllCodeInMemory()      ;      ; Pour finir, on met à jour LastEPanelRefreshTime qui sert à rafraîchir      ; certains panneaux au fur et à mesure l'avancée des résultats      ; obtenus lors de l'exploration profonde effectuée en tâche de fond.      LastEPanelRefreshTime = ElapsedMilliseconds()      ;      BackgroundTasksCompletion = #BackgroundTasksUncompleted      ;      ExactValueSearch = #DoProgSearchAndPrintResult       ; Il va falloir rafraîchir l'affichage de certains panneaux.      ;      TotOutTime = 0      ;    EndIf    ; On déduit de StartTimeForBackgroundTasks le temps qui n'a pas été consacré    ; aux tâches de fonds.    StartTimeForBackgroundTasks + ElapsedMilliseconds() - LastTimeForBackgroundTasksEnding    TotOutTime + ElapsedMilliseconds() - LastTimeForBackgroundTasksEnding    ; Ce compteur mesure désormais précisément le temps qui a été consacré    ; aux tâches de fond depuis leur démarrage.    ;    If BackgroundTasksCompletion = #BackgroundTasksHavePriority      ; L'utilisateur a demandé à terminer l'exploration profonde.      SALParam = #ShowCompletionWindow      ; En passant le paramètre #ShowCompletionWindow aux tâches d'exploration, on provoque      ; l'affichage d'une fenêtre d'attente.    Else      SALParam = #WorkInBackGround    EndIf    ;    ; En testant 'SetAllListsOfAllElements()', on provoque l'exécution    ; de la première phase d'exploration (listing de tous les éléments).    Result = SetAllListsOfAllElements(SALParam)    If Result = #Completion_Completed      ;      ; La première phase d'exploration est terminée.      ; Toutes les listes d'éléments ont été complétées.      ; La phase suivante, que j'ai nommée "Exploration profonde",      ; devra déterminer quels sont les éléments utilisés par le      ; fichier principal.      ;      ExploringPhase = 2      ;      If SetAllListsOfUsedElements(SALParam) = #Completion_Uncomplete        If ElapsedMilliseconds() - LastEPanelRefreshTime > 1000          RefreshEPanel = #True ; Pour les panneaux de résultats.          ; Quand un panneau comportant une liste d'éléments est affiché,          ; RefreshEPanel va provoquer, une fois par seconde, une mise-à-jour de ce panneau.          ; Ainsi, l'utilisateur pourra constater les résultats partiels          ; de l'exploration profonde, au fur et à mesure de son avancement.          LastEPanelRefreshTime = ElapsedMilliseconds()        EndIf      Else        ;        ; L'exploration profonde est terminée.        ;        StatReport$ = GetTextFromCatalog("ExploringDuration")  + " : " + FormatNumber(ElapsedMilliseconds() - StartTimeForBackgroundTasks, 0, ".", ",") + " ms." + Chr(13)        StatReport$ + GetTextFromCatalog("EventManagement")    + " : " + FormatNumber(TotOutTime, 0, ".", ",") + " ms." + Chr(13)        StatReport$ + GetTextFromCatalog("TotalExploringTime") + " : " + FormatNumber(ElapsedMilliseconds() - StartTimeForBackgroundTasks + TotOutTime, 0, ".", ",") + " ms." + Chr(13) + Chr(13)        ;        StatReport$ + GetTextFromCatalog("TFileLength")        + " : " + FormatNumber(TFileLength, 0, ".", ",") + " bytes." + Chr(13) + Chr(13)                StatReport$ + GetTextFromCatalog("ElementUsedOrNot") + Chr(13)        ;        ; On note le nombre d'éléments existants et trouvés.        For TypeOfElement = 0 To #EndEnumPBBElementTypes - 1          StatReport$ + GetTextFromCatalog(PBBTypeNames$(TypeOfElement))   + ": " + CountString(ListOfAllElements$(TypeOfElement), Chr(13))   + " / " + CountString(ListOfUsedElements$(TypeOfElement), Chr(13))   + "." + Chr(13)        Next          ;        BackgroundTasksCompletion = #BackgroundTasksCompleted        CloseWaitingWindow()        HideGadget(GPBBGadgets\EProgressBar, #True) ; On masque EProgressBar qui affichait la progression.        HideGadget(GPBBGadgets\TProgressBar, #True)        HideGadget(GPBBGadgets\BStats, #False)     ; Et on affiche le bouton 'Statistiques'.        HideGadget(GPBBGadgets\BRefresh, #False)        BringWindowToTop_(GadgetID(GPBBGadgets\BStats))        BringWindowToTop_(GadgetID(GPBBGadgets\BRefresh))                ; On provoque un réaffichage des résultats :        ExactValueSearch = #DoProgrammedSearch ; Pour les panneaux "Détails" et "Trouvé dans..."        RefreshEPanel    = #True               ; Pour les panneaux de résultats      EndIf    ElseIf Result = #Completion_Error      alert("Unexpected program Error in 'ManagePBBBackgroundTasks()'.")      BackgroundTasksCompletion = #BackgroundTasksMustRestart      ProcedureReturn    EndIf    ;    If BackgroundTasksCompletion <> #BackgroundTasksCompleted      ; Tout ce qui va suivre ne sera pas d'une grande utilité pour l'analyse des fichiers      ; de petites tailles, car la phase d'exploration sera alors terminée avant même que      ; EProgressBar ait eu le temps d'être mis à jour. Mais pour l'analyse de codes-sources      ; importants (plus de 200 ko), dont l'analyse peut prendre plus d'une seconde, il est      ; pratique de pouvoir constater sa progression.      If ExploringPhase < 2        ;        FirstExplorationProgress + 5        ; Cette valeur de progression ne correspond à rien de concret, mais        ; la première phase d'exploration est de toute façon très rapide,        ; même pour des projets très lourd. On se contente donc d'animer        ; la barre de progression a minima.        ;        SetGadgetState(GPBBGadgets\EProgressBar, FirstExplorationProgress)      Else        ; Nous sommes dans la phase d'exploration profonde (deuxième phase        ; de l'exploration). Le calcul de la progression est simpliste, mais        ; il fonctionne de façon satisfaisante :        ; • On commence par calculer la variable 'ExploringGoal' en cumulant        ;   le nombre total d'éléments identifiés pendant la première phase        ;   d'exploration, pour chaque type d'élément.        ; • On calcule la progression en ajoutant, pour chaque type d'élément,        ;   le nombre d'éléments multiplié par son stade d'exploration. Le        ;   stade d'exploration est renseigné par la procédure 'CompleteListOfUsedElement()'        ;   qui lui attribue la valeur '1' en début d'exploration et la valeur        ;   '2' en fin d'exploration.        If ExploringGoal = 0          For TypeOfElement = 0 To (#EndEnumPBBElementTypes - 1)            ExploringGoal + ListOfAllElementsNbr(TypeOfElement)          Next        EndIf        ;        Protected ExploringResult = 0        For TypeOfElement = 0 To (#EndEnumPBBElementTypes - 1)          ExploringResult + ListOfAllElementsNbr(TypeOfElement) * ListCompletionStepsCompleted(TypeOfElement) / 2        Next        If ExploringGoal          SetGadgetState(GPBBGadgets\EProgressBar, (ExploringResult * (100 - FirstExplorationProgress) / ExploringGoal) + FirstExplorationProgress)        EndIf      EndIf      ;      ; On note le moment où l'exploration s'est interrompue :      LastTimeForBackgroundTasksEnding = ElapsedMilliseconds()    EndIf  EndIf    ;  ProcedureReturn EventID  ;EndProcedure;Procedure ManagePipeMessages()  ;  ; Cette procédure se met à l'écoute du 'Pipe' baptisé 'PBBrowserRunningPipe$',  ; et récupère un message$ éventuel émis par une autre instance de PBBrowser.  ;  ; Concrètement, quand l'éditeur de PureBasic appelle PBBrowser depuis son menu 'Outils',  ; cela démarre une instance de PBBrowser. Deux cas de figure sont alors possibles :  ; Si aucune autre instance n'était déjà en cours de fonctionnement, PBBrowser  ; démarre et exploite directement las paramètres qui lui ont été fournis.  ; Si une autre instance est déjà en cours de fonctionnement, la nouvelle instance  ; récupère les arguments et les transmets à l'ancienne instance à travers le 'Pipe',  ; puis met fin à son fonctionnement.  ; L'instance principale (la première qui a été démarrée) teste donc régulièrement  ; le 'Pipe' pour voir si des arguments lui sont transmis.  ;  Shared PBB_LastEventTime ; Ce timer contient l'heure du dernier évènement utilisateur  Shared ExactValueSearch  ;  Protected NewArgument$, TempFile$  Protected Reload ; pour PBUpdateMainFile  Protected  ActivePannel, mPBBListOfFiles$, PosInFileList, LineC$, BOText$  ;  ; *******************************************************************  ;  Gestion des messages provenant d'une autre instance de PBBrowser.  ;  NewArgument$ = ListenForPipeMessages()  If NewArgument$ <> ""    ; L'éditeur de PureBasic vient de lancer une autre instance qui nous    ; a transmis de nouveaux arguments.    ;    If GetWindowState(GPBBGadgets\PBBWindow) = #PB_Window_Minimize      SetWindowState(GPBBGadgets\PBBWindow, #PB_Window_Normal)    EndIf    SetForegroundWindow_(WindowID(GPBBGadgets\PBBWindow))    SetFocus_(WindowID(GPBBGadgets\PBBWindow))    BringWindowToTop_(WindowID(GPBBGadgets\PBBWindow))    ;    PBB_LastEventTime = ElapsedMilliseconds()    If StringField(NewArgument$, 1, Chr(13))      PureBasicProgAdr$ = StringField(NewArgument$, 1, Chr(13))      If OpenPreferencesWithPatience(PBBrowserPrefile$) ; PBBrowserPrefile$ est une variable globale        WritePreferenceString("PureBasicProgAdr", PureBasicProgAdr$)        ClosePreferences()      EndIf    EndIf    ;    PBUnderCursor$ = StringField(NewArgument$, 2, Chr(13))    ;    FicActualPB$ = StringField(NewArgument$, 3, Chr(13))    ;    If StringField(GetGadgetText(GPBBGadgets\SearchedExpression_gadget), 1, Chr(8239)) <> PBUnderCursor$      ; La chaîne à rechercher vient de changer. On se met à jour.      SetGadgetText(GPBBGadgets\SearchedExpression_gadget, PBUnderCursor$)      ;      If PBUnderCursor$        ActivePannel = GetActivePBBPanel()        If ActivePannel <> #FoundInFilesPBBPanel And  ActivePannel <> #DetailPBBPanel          SetActivePBBPanel(#FoundInFilesPBBPanel)        EndIf      Else        SetActivePBBPanel(#FilePBBPanel)      EndIf      ;      ExactValueSearch = #DoProgSearchAndPrintResult    EndIf    ;    If FicActualPB$      PBBUpdateMainFile(FicActualPB$) ; on se met à jour avec les nouveaux arguments.    EndIf  EndIfEndProcedure;; On inclut les outils à cet endroit-là, afin qu'ils aient accès; à toutes les procédures et macros développées ci-dessus.;XIncludeFile "PBBrowser resources\Source Codes\PBBrowser_NativeTools.pb"XIncludeFile "PBBrowser resources\Source Codes\PBBrowser_CustomTools.pb";Procedure PBBrowserMainProc(WSticky = -1)  ;  Shared RefreshEPanel             ; Quand cette variable est supérieure à zéro, cela                                   ; provoque un rafraîchissement de l'affichage pour certains panneaux.                                   ; C'est la procédure ManagePBBBackgrounsTasks() qui peut la mettre à un.                                   ;  Shared BackgroundTasksCompletion ; Indique l'état d'avancement de l'exploration.  ;  Shared PBBWaitingGadget          ; Peut contenir le numéro d'un gagdet quand une fenêtre d'attente                                   ; a été ouverte par ManageWaitingWindow().  ;  Shared ListOfResultPages$, PosInListOfPages ; Pour gérer l'historique du panneau 'Détails'  ;  Shared PBBRichEditMessage, PBBREGadgetID ; Pour gérer les clics sur les pseudo-liens. Ces variables sont mises                                           ; à jour par la procédure PBBRichEditCallback().                                           ;  Shared ExactValueSearch ; Cette variable indique à PBBrowserMainProc qu'il faut relancer une recherche.                          ; Elle est partagée par ManagePBBBackgroundTasks(), ManagePipeMessages() et                          ; ClikOverREGadget(), et figure aussi comme paramètre pour GetTypeOfExpression.                          ;  Shared StatReport$ ; Contiendra les statistiques sur l'exploration et sur le code.  ;  ; Variables pour la gestion des événements :  Protected EventID, EventGadget, QuitAll, NoREGadget, ActPannel  ;  Protected Reload ; pour PBUpdateMainFile.  :   Protected PBB_LastUpdateTime ; Sert à mesurer le temps depuis la dernière vérification des fichiers.  ;  ; Autres variables :  Protected TypeOfElement, SExpression$, StrRef$, pd, pf  Protected FileName$, LastSearch.LastSearchDetails  Protected txtrange.CHARRANGE, NFile$, mPBBListOfFiles$, PosInFileList, LineC$, BOText$  Protected  StatReport2$, PBBLanguageFolder$  ;  If WSticky = -1 And OpenPreferencesWithPatience(PBBrowserPrefile$)    WSticky = ReadPreferenceLong("WSticky", 1)    ClosePreferences()  EndIf  ;  If OpenPBBMainWindow(WSticky)    ;    PBBUpdateMainFile(FicPrincipalPB$)    ;________________________________________________________    ;    ;     Initialisation des recherches et explorations    ;    If PBUnderCursor$ ; Variable globale renseignée en amont qui contient l'expression                      ; transmise par l'éditeur de PureBasic à PBBrowser.      SetGadgetState(GPBBGadgets\MainPanelGadget, #FoundInFilesPBBPanel)    Else      SetGadgetState(GPBBGadgets\MainPanelGadget, #FilePBBPanel)      SetActiveGadget(GPBBGadgets\SearchedExpression_gadget)    EndIf    ;________________________________________________________    ;    ClearKeyboardBuffer(GPBBGadgets\PBBWindow)    ;    If PBUnderCursor$ ; Cette variable globale a pu être renseignée par les arguments reçus au démarrage.                      ; dans le cas où l'application fonctionne en mode 'StandAlone'.      SetGadgetText(GPBBGadgets\SearchedExpression_gadget, PBUnderCursor$)      ExactValueSearch = #DoProgSearchAndPrintResult    EndIf    ;    Repeat      ;      ; Comme l'utilisateur risque de faire des aller-retour entre la fenêtre      ; de PureBasic et celle de PBBrowser, on s'assure que les clics sur les      ; gadgets de PBBrowser sont bien retransmis, même quand la fenêtre était      ; inactive au moment du clic :      Shared MustStayActive ; MustStayActive est mis à jour dans la procédure       ; 'ClickOverREGadget()' au moment ou on active l'éditeur de PureBasic      ;  avec un 'RunProgram()' (ce qui fait perdre le focus à notre fenêtre).      If GetActiveWindow() = -1 And (ElapsedMilliseconds() - MustStayActive) < 500        ; Pour Windows 7, on est obligé d'employer la manière forte        ; en simulant des clics à répétition jusqu'à récupérer le        ; focus (pendant une durée maximale de 500 ms).        ClickOverGadget(GetREGadgetNbrFromActivePBBPanel())      EndIf      ;      ; Pour les versions de Windows postérieures à la version 7, ce qui suit      ; est généralement suffisant :      TransfertClickToGadget()      ;      If BackgroundTasksCompletion <> #BackgroundTasksCompleted        EventId = ManagePBBBackgroundTasks()      Else        EventId = WaitWindowEvent(200)        ;        ; On vérifie, toutes les secondes, si un fichier n'a pas été modifié,        ; afin de mettre nos données à jour :        If EventId = 0 And ElapsedMilliseconds() - PBB_LastUpdateTime > 1000          PBB_LastUpdateTime = ElapsedMilliseconds()          UpdateAllFilesInMemory()        EndIf      EndIf      ;      ; À chaque cycle, on vérifie si on ne reçoit pas de données en provenance      ; d'une autre instance :      ManagePipeMessages()      ;      ; On ne tient compte des événements de l'application que lorsque la fenêtre d'attente      ; n'est pas affichée.      If PBBWaitingGadget = 0        If EventWindow() = GPBBGadgets\PBBWindow Or ExactValueSearch Or RefreshEPanel          EventGadget = 0          ;          If EventID = #PB_Event_CloseWindow            QuitAll = 1          ElseIf EventID = #PB_Event_Menu            If EventMenu() = #PBBMenu_Return ; Appui sur Return.              EventID = #PB_Event_Gadget              EventGadget = GPBBGadgets\BSearchExpression            ElseIf EventMenu() = #PBBMenu_Escape ; Appui sur Escape.              QuitAll = 1            ElseIf EventMenu() = #PBBMenu_Find ; Appui sur CTRL Q.              If GetActivePBBPanel() = #DetailPBBPanel Or GetActivePBBPanel() = #FoundInFilesPBBPanel                NoREGadget = GetREGadgetNbrFromActivePBBPanel()                SExpression$ = TOM_GetText(NoREGadget)                ; Lorsque l'utilisateur a sélectionné une portion de texte dans le panneau                ; 'Détails' ou dans le panneau 'Trouvé dans...', puis appuyé sur CRTL Q,                ; on lance une recherche sur l'expression sélectionnée.                If SExpression$                  SetGadgetText(GPBBGadgets\SearchedExpression_gadget, SExpression$)                  ExactValueSearch = #DoProgSearchAndPrintResult                EndIf              EndIf              EventID = #PB_Event_Gadget              EventGadget = GPBBGadgets\BSearchExpression            ElseIf EventMenu() = #PBBMenu_THAT ; Appui sur CTRL I ou Choix dans le menu.              DisablePBBWindow()              ; Ouverture de 'Aide et Outils'.              THATProc()              ; On rafraîchit le menu.              UpdatePBBMenus()              EnablePBBWindow()              ;              ; Commandes pour la navigation :              ;            ElseIf EventMenu() = #PBBMenu_NextPanel              WalkOverPannels(1)            ElseIf EventMenu() = #PBBMenu_PreviousPanel              WalkOverPannels( - 1)            ElseIf EventMenu() =  #PBBMenu_PageUp              NoREGadget = GetREGadgetNbrFromActivePBBPanel()              SendMessage_(GadgetID(NoREGadget), #WM_VSCROLL, #SB_PAGEUP, 0)            ElseIf EventMenu() =  #PBBMenu_PageDown              NoREGadget = GetREGadgetNbrFromActivePBBPanel()              SendMessage_(GadgetID(NoREGadget), #WM_VSCROLL, #SB_PAGEDOWN, 0)            ElseIf EventMenu() =  #PBBMenu_Up              NoREGadget = GetREGadgetNbrFromActivePBBPanel()              SendMessage_(GadgetID(NoREGadget), #WM_VSCROLL, #SB_LINEUP, 0)            ElseIf EventMenu() =  #PBBMenu_Down              NoREGadget = GetREGadgetNbrFromActivePBBPanel()              SendMessage_(GadgetID(NoREGadget), #WM_VSCROLL, #SB_LINEDOWN, 0)            ElseIf EventMenu() =  #PBBMenu_NextPage              ActPannel = GetActivePBBPanel()              If ActPannel = #DetailPBBPanel Or ActPannel = #FoundInFilesPBBPanel                If WalkOverPages(1, GPBBGadgets\SearchedExpression_gadget) = #False                  WalkOverPannels(1)                EndIf              Else                WalkOverPannels(1)              EndIf            ElseIf EventMenu() =  #PBBMenu_PreviousPage              ActPannel = GetActivePBBPanel()              If ActPannel = #DetailPBBPanel Or ActPannel = #FoundInFilesPBBPanel                If WalkOverPages( - 1, GPBBGadgets\SearchedExpression_gadget) = #False                  WalkOverPannels( - 1)                EndIf              Else                WalkOverPannels( - 1)              EndIf              ;              ; Commandes des outils :              ;            ElseIf EventMenu() >= #PBBMenu_CommandOffset And EventMenu() < 300              ExecCommandFromPBBWindow(EventMenu() - #PBBMenu_CommandOffset)              ;              ; Commandes du menu hamburger :              ;            ElseIf EventMenu() = #REM_ZoomIn              RE_AdjustZoom(GetREGadgetNbrFromActivePBBPanel(), 10)              ReSizeREMenu()            ElseIf EventMenu() = #REM_ZoomOut              RE_AdjustZoom(GetREGadgetNbrFromActivePBBPanel(), -10)              ReSizeREMenu()            ElseIf EventMenu() = #REM_ZoomReset              RE_AdjustZoom(GetREGadgetNbrFromActivePBBPanel(), 0)              ReSizeREMenu()            ElseIf EventMenu() = #REM_FindInPannel              RE_FindReplace(GetREGadgetNbrFromActivePBBPanel())            ElseIf EventMenu() = #REM_CopyAll              TOM_Copy(GetREGadgetNbrFromActivePBBPanel(), 0, -1)            ElseIf EventMenu() = #REM_SaveAsText              NFile$ = SaveFileRequester(GetTextFromCatalog("SaveAs"), "", GetTextFromCatalog("TextFile"), 1)              If NFile$                NFile$ = ChangeFileExtension(NFile$, "txt")                RE_SaveContent(GetREGadgetNbrFromActivePBBPanel(), NFile$, #SF_TEXT)              EndIf            ElseIf EventMenu() = #REM_SaveAsRTF              NFile$ = SaveFileRequester(GetTextFromCatalog("SaveAs"), "", GetTextFromCatalog("RTFFile"), 1)              If NFile$                NFile$ = ChangeFileExtension(NFile$, "RTF")                RE_SaveContent(GetREGadgetNbrFromActivePBBPanel(), NFile$, #SF_RTF, 1)              EndIf            EndIf          ElseIf EventID = #PB_Event_Gadget            EventGadget = EventGadget()          EndIf          ;          ; Repositionnement du bouton hamburger pour les REGadgets.          ;          If EventId = #WM_LBUTTONDOWN Or EventId = #WM_LBUTTONUP            ReSizeREMenu()          EndIf          ;          ; Le rafraîchissement des panneaux d'éléments peut être consécutif à une action          ; de l'utilisateur, ou à une demande issue des tâches de fond.          ; On gère donc les conditions de ce rafraîchissement à part de la gestion          ; des autres gadgets.          If GetGadgetState(GPBBGadgets\MainPanelGadget) = #ListPBBPanel And FileSize(FicPrincipalPB$) > 2            If RefreshEPanel Or ((EventGadget = GPBBGadgets\ListsPGadget Or EventGadget = GPBBGadgets\MainPanelGadget) And EventType() = #PB_EventType_Change And EventID = #PB_Event_Gadget)              TypeOfElement = TypeElementOfPBBPanel(GetActivePBBPanel())              While ListCompletionAll(TypeOfElement) < #ListCompletion_Done                ; La liste d'éléments qui doit être affichée n'est pas complétée.                ; Alors on la complète :                SetOneListOfAllElements(TypeOfElement, GPBBGadgets\PBBWindow)              Wend              If RefreshEPanel = #False                CloseWaitingWindow()              EndIf              If ListCompletionAll(TypeOfElement) < #ListCompletion_Printed                ; Le gadget qui doit comporter la liste d'éléments n'a pas encore été rempli.                ; Alors, on le rempli.                FillElementREGadget(TypeOfElement)                ; En cas de 'RefreshEPanel', on vide la pile des events générés par le redessin                ; du RichEdit Gadget de l'élément, pour que la mise à jour en tâche de fond ne soit pas                ; inutilement ralentie.                While WindowEvent() : Wend              EndIf              RefreshEPanel = #False            EndIf          EndIf          ;          ; Gestion des clics sur les pseudo-liens.          ;          ; (PBBRichEditMessage et PBBREGadgetID sont mis à jour par la procédure PBBRichEditCallback()).          ;          If PBBRichEditMessage = #WM_LBUTTONUP Or PBBRichEditMessage = #WM_RBUTTONUP ; clic à l'intérieur de l'un des RichEditGadget.            NoREGadget = GetREGadgetNbrFromActivePBBPanel()            If NoREGadget And GadgetID(NoREGadget) = PBBREGadgetID              ClickOverREGadget(GPBBGadgets\SearchedExpression_gadget, PBBRichEditMessage)            EndIf            PBBRichEditMessage = 0          ElseIf PBBRichEditMessage = #WM_LBUTTONDBLCLK            PBBRichEditMessage = 0            ; L'utilisateur a double-cliqué dans le contenu d'un RichEdit Gadget,            ; ce qui a sans doute eu pour effet de sélectionner une portion de texte.            ; On regarde si le double-clic a eu lieu dans le panneau 'Détail' ou dans le panneau 'Trouvé dans...'            If GetActivePBBPanel() = #DetailPBBPanel Or GetActivePBBPanel() = #FoundInFilesPBBPanel              NoREGadget = GetREGadgetNbrFromActivePBBPanel()              ;              ; On regarde d'abord si le double-clic n'a pas eu lieu sur une image-bouton.              ; Cela peut se produire si l'utilisateur clique de façon un peu trop frénétique              ; sur le bouton [<<] ou sur [>>].              If GetImageNameFromSelectionPos(NoREGadget) = ""                ;                ; On va maintenant regarder s'il ne serait pas utile d'étendre la sélection,                ; car, par défaut, la sélection  que fait Windows lors d'un double-clic dans                ; un 'RichEdit control' s'arrête à l'underscore ('_') et n'englobe pas                ; les caractères "$" et "#" qui font pourtant partie des noms de variables.                ;                ; On récupère le texte du gadget :                StrRef$ = ReplaceString(GetGadgetText(NoREGadget), Chr(10), "")                ; On récupère les positions de la sélection :                RE_GetSelection(NoREGadget, @txtrange.CHARRANGE)                pd = txtrange\cpMin + 1                pf = txtrange\cpMax + 1                ; On élargi la sélection jusqu'à trouver un séparateur de part et d'autre.                While pd And (FindString(ListPBSep$, FastMid(StrRef$, pd, 1)) = 0 Or FastMid(StrRef$, pd, 1) = "*" Or FastMid(StrRef$, pd, 1) = "#") : pd - 1 : Wend                pd + 1                While pf <= Len(StrRef$) And FindString(ListPBSep$, Mid(StrRef$, pf, 1)) = 0  : pf + 1 : Wend                ; On applique la sélection élargie dans le texte.                RE_SetSelection(NoREGadget, pd - 1, pf - 1)              EndIf            EndIf          EndIf          ;          ; Gestion des gadgets classiques.          ;          If EventGadget = GPBBGadgets\BQuit            QuitAll = 1          ElseIf EventGadget = GPBBGadgets\BStick            StickyWindow(GPBBGadgets\PBBWindow, GetGadgetState(GPBBGadgets\BStick))            If OpenPreferencesWithPatience(PBBrowserPrefile$) ; PBBrowserPrefile$ est une variable globale.              WritePreferenceLong("WSticky", GetGadgetState(GPBBGadgets\BStick))              ClosePreferences()            EndIf            ;          ElseIf EventGadget = GPBBGadgets\BStats            ; Affiche Stats            AlertInPBBWindow(StatReport$ + Chr(13) + Chr(13) + StatReport2$, GetTextFromCatalog("Statistics"))            ;          ElseIf EventGadget = GPBBGadgets\BRefresh            PBBUpdateMainFile(FicPrincipalPB$, #True)            ;          ElseIf EventGadget = GPBBGadgets\BAbout            ;            ; Affichage du menu 'Aide et Outils'.            ;            DisplayPopupMenu(GPBBGadgets\Menu, WindowID(GPBBGadgets\PBBWindow))            ;          ElseIf EventGadget = GPBBGadgets\BLanguage            ;            ; Choix de la langue            ;            If OpenPreferencesWithPatience(PBBrowserPrefile$)              PBBLanguageFolder$ = ReadPreferenceString("PBBLanguageFolder", "")              ClosePreferences()            Else              Alert("Error while opening preference file.")              End            EndIf            ;            DisablePBBWindow()            ;            PBBLanguageFolder$ = ChooseLanguage(MyAppDataFolder$ + "Catalogs\", PBBLanguageFolder$)            If OpenPreferencesWithPatience(PBBrowserPrefile$)              WritePreferenceString("PBBLanguageFolder", PBBLanguageFolder$)              ClosePreferences()            EndIf            ;            EnablePBBWindow()            ;            GetTextFromCatalog("", PBBLanguageFolder$ + "PBBrowser.catalog")            SetPBBGadgetsTitles()            ;          ElseIf EventGadget = GPBBGadgets\BREMenu            ;            ; Affichage du menu hamburger des REGadgets.            ;            DisplayPopupMenu(GPBBGadgets\REMenu, WindowID(GPBBGadgets\PBBWindow))            ;          ElseIf EventGadget = GPBBGadgets\MainPanelGadget And (GetActivePBBPanel() = #FoundInFilesPBBPanel Or GetActivePBBPanel() = #DetailPBBPanel) And EventType() = #PB_EventType_Change            ; En navigant à l'intérieur des panneaux, l'utilisateur vient de provoquer l'affichage            ; du panneau "Détails" ou du panneau "Trouvé dans..."            ExactValueSearch = #DoProgrammedSearch ; On va réactualiser les résultats de recherche.            ;          ElseIf EventGadget = GPBBGadgets\BChangeAdresse            FileName$ = OpenFileRequester(GetTextFromCatalog("SelectMainFile"), FicPrincipalPB$, "PureBasic (pb,pbi)|*.pb;*.pbi", 1)            ; L'utilisateur vient de changer l'adresse du fichier principal.            If FileName$              SetGadgetText(GPBBGadgets\SearchedExpression_gadget, "")              SetActivePBBPanel(#FilePBBPanel)              PBBUpdateMainFile(FileName$)            EndIf          EndIf          ;          ; La gestion de ce qui va suivre peut, elle aussi, avoir plusieurs causes.          ; Soit elle est provoquée par l'utilisateur (par un clic sur 'Chercher'),          ; soit par une procédure ou par ce qui précède (si une valeur non nulle           ; a été attribuée à ExactValueSearch).          ; Là encore, on gère donc la situation de façon différente par rapport          ; aux autres gadgets.          ;           If (EventID = #PB_Event_Gadget And EventGadget = GPBBGadgets\BSearchExpression) Or ExactValueSearch            ;            ;- BSearchExpression            ;            ; On regarde si les fichiers sont à jour par rapport à ce qui figure en mémoire.            ; Si ce n'est pas le cas, 'UpdateAllFilesInMemory()' va les mettre à jour, ainsi que            ; la liste des éléments :            UpdateAllFilesInMemory()            ;            ;            SExpression$ = GetGadgetText(GPBBGadgets\SearchedExpression_gadget)            ;            If FindString(SExpression$, Chr(8239)) = 0              GetTypeOfExpression(SExpression$, LastSearch, ExactValueSearch)              If LastSearch\ElementType > -1                ; Le caractère Chr(8239) (espace fine), nous sert à isoler                ; l'expression saisie de ce qui suit (une précision sur le type de l'expression).                SExpression$ = LastSearch\ElementName$ + Chr(8239) + " (" + LastSearch\TypeName$ + ")"              EndIf              SetGadgetText(GPBBGadgets\SearchedExpression_gadget, SExpression$)            EndIf            ;            If GetActivePBBPanel() = #DetailPBBPanel              FillDetailREGadget(LastSearch)            ElseIf GetActivePBBPanel() = #FoundInFilesPBBPanel              FillFoundInREGadget(LastSearch)            EndIf            ;            ExactValueSearch = #NoSearchOrManualSearch          EndIf        EndIf      EndIf    Until QuitAll        If IsWindow(GPBBGadgets\PBBWindow)      RecordWindowDimInPref(PBBrowserPrefile$, GPBBGadgets\PBBWindow)      CloseWindow(GPBBGadgets\PBBWindow)    EndIf  EndIf  ClearKeyboardBuffer(0)EndProcedure;PBBrowserMainProc();; IDE Options = PureBasic 6.00 LTS (Windows - x86); CursorPosition = 1436; FirstLine = 1351; Folding = x---X4----+---; EnableXP; DPIAware; UseIcon = PBBrowser resources\Images\PBBrowserLogo.ico; Executable = PBBrowser.exe; EnablePurifier = 32,32,64,32; EnableExeConstant