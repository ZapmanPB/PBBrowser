;Global ListPBSepWithoutEndChars$ = " ,();+-=" + Chr(34) + "/*\><@{}|~[]&.!?"Global ListPBSep$ = ":" + Chr(13) + ListPBSepWithoutEndChars$;Enumeration CheckModesForFindInPBCode  #NoCheck  #CheckOnlyLeft  #CheckOnlyRight  #CheckOnlyLeftAndRight  #CheckOnlyComAndQuote  #CheckLeftAndComAndQuote  #CheckRightAndComAndQuote  #CheckAll  #CheckOneKeyWordOnlyEndEnumeration;Procedure FindInPBPointedCode(*SearchString.String, KeywordList$, posdep = 0, CheckMode = #CheckAll, FMode = #PB_String_CaseSensitive)  ;  ; Cherche un mot clé dans une page de code PureBasic, en vérifiant que ce mot clé  ; n'est pas placé dans un commentaire ou des guillemets  ;  ; KeywordList$ peut comporter plusieurs mots séparés par des virgules, comme par  ; exemple "IncludeFile,XIncludeFile", auquel cas, c'est le premier mot trouvé  ; dans cette liste qui déterminera la position de retour.  ;  ; Si vous voulez faire figurer une virgule dans l'un des mots de la liste KeywordList$  ; remplacez la virgule par l'expression "\comma_". Ou bien, si vous ne faites une recherche  ; que sur une seule expression, attribuez la valeur '#CheckOneKeyWordOnly' à 'CheckMode'  ; et les virgules ne seront plus considérées comme des séparateurs de mots-clés.  ; #CheckOneKeyWordOnly peut être combiné à toutes les autres valeurs de l'énumération  ; 'CheckModesForFindInPBCode'. Par exemple : #CheckOnlyLeft|#CheckOneKeyWordOnly  ;  ; L'énumération CheckModesForFindInPBCode liste les diverses possibilités de vérification  ; qui seront effectuées sur la chaîne recherchée.  ; Si CheckMode vaut 1 ou 5 ou 7, la chaîne ne sera considérée comme trouvée que si elle est  ; bordée d'un séparateur valide sur son côté gauche (la liste des séparateurs valides  ; est définie par la variable globale ListPBSep$, définie un peu plus haut).  ; Si CheckMode vaut 2 ou 6 ou 7, la chaîne ne sera considérée comme trouvée que si elle est  ; bordée d'un séparateur valide sur son côté droit.  ; Si CheckMode vaut 4 ou 5 ou 7, la chaîne ne sera considérée comme trouvée que si elle est  ; ne figure pas dans un commentaire ou entre guillemets.  ;  ; Plutôt que de passer le paramètre 'SearchString' en chaîne, ce qui peut  ; consommer de la mémoire et du temps si la chaîne est longue, on travaille  ; avec un pointeur sur une structure String. Ainsi, la chaîne n'est pas  ; duppliquée en mémoire au moment de l'appel.  ;  Protected SimpleSearch, FirstKeyword$, FirstKeywordPos, nl, Keyword$  Protected posdepR, p, ppv, nbg, TestS$  ;  If CheckMode & #CheckOneKeyWordOnly Or FindString(KeywordList$, ",") = 0    FirstKeyword$ = KeywordList$    SimpleSearch = 1  Else    SimpleSearch = 0  EndIf  ;  SearchFurtherLabel:   ;  If *SearchString = 0    Debug "pointeur vide"    CallDebugger    ProcedureReturn  EndIf  If SimpleSearch    p = FindString(*SearchString\s, FirstKeyword$, posdep, FMode)  Else    FirstKeyword$ = ""    FirstKeywordPos = 0    nl = 1    Repeat      Keyword$ = StringField(KeywordList$, nl, ",")      If Keyword$        Keyword$ = ReplaceString(Keyword$, "\comma_", ",")        p = FindString(*SearchString\s, Keyword$, posdep, FMode)        If p And ((p - Len(Keyword$) < FirstKeywordPos - Len(FirstKeyword$)) Or FirstKeywordPos = 0)          FirstKeywordPos = p          FirstKeyword$ = Keyword$        EndIf      EndIf      nl + 1    Until Keyword$ = ""    p = FirstKeywordPos  EndIf  ;  If p    ; On commence par vérifier que le mot trouvé est bien encadré par des séparateurs valides.    If (CheckMode & #CheckOnlyLeft And p > 1 And FindString(ListPBSep$, FastMid(*SearchString\s, p - 1, 1), 0) = 0) Or (CheckMode & #CheckOnlyRight And (p + Len(FirstKeyword$) < Len(*SearchString\s)) And FindString(ListPBSep$, FastMid(*SearchString\s, p + Len(FirstKeyword$), 1), 0) = 0)      ; Au moins un des séparateurs n'est pas valide.      posdep = p + Len(FirstKeyword$)      Goto SearchFurtherLabel ; On recommence la recherche.    EndIf    ;    If CheckMode & #CheckOnlyComAndQuote      ;      ; On examine ce qu'il y a entre le début de la ligne et la chaîne trouvée      ;      posdepR = p      ; On remonte au début de la ligne.      While posdepR > 0 And PeekC(@*SearchString\s + (posdepR - 1) * SizeOf(CHARACTER)) <> 13        posdepR - 1      Wend      posdepR + 1      ;      If posdepR > posdep : posdep = posdepR : EndIf ; On ajuste la position de départ pour la prochaine recherche      ;      ; Regardons si nous sommes en début de ligne (sinon, il est inutile de continuer les tests).      If p - posdepR > 0        ; On extrait le segment de texte existant entre le début de ligne et la position trouvée.        TestS$ = Trim(FastMid(*SearchString\s, posdepR, p - posdepR))        If TestS$          ;  On vérifie que la chaîne trouvée n'est pas en commentaire.          If FastLeft(TestS$, 1) = ";"            posdep = FindString(*SearchString\s, Chr(13), posdep + ppv) ; On cherche le retour chariot qui suit.            If posdep = 0              p = 0            Else              Goto SearchFurtherLabel ; et on recommence la recherche.            EndIf          EndIf          If p            ppv = 0            Repeat              ; On cherche un ";" entre le début de ligne et la position trouvée              ppv = FindString(TestS$, ";", ppv + 1)              If ppv                ; On vérifie que le point-virgule trouvé n'est pas entre guillemets.                ; en comptant le nombre de guillemets que contient le segment TestS$.                nbg = CountString(Mid(TestS$, 1, ppv), Chr(34))                If Not (nbg & 1) ; Il y a un nombre pair de guillemets ou aucun guillemet.                  ; La chaine trouvée est en commentaire. On ne peut pas la considérer comme valide.                  posdep = FindString(*SearchString\s, Chr(13), posdep + ppv) ; On cherche le retour chariot qui suit.                  If posdep = 0 : p = 0 : Break : EndIf                  Goto SearchFurtherLabel ; et on recommence la recherche.                EndIf              EndIf            Until p = 0 Or ppv = 0          EndIf          ;          If p            ; On vérifie que la chaine cherchée n'est pas entre guillemets.            ; en comptant le nombre de guillemets que contient le segment TestS$.            nbg = CountString(TestS$, Chr(34))            If nbg & 1 ; Il y a un nombre impair de guillemets.              ; La chaine trouvée est donc entre guillemets. On ne peut pas la considérer comme valide.              posdep = p + 2              Goto SearchFurtherLabel ; et on relance la recherche.            EndIf          EndIf        EndIf      EndIf    EndIf  EndIf  ProcedureReturn pEndProcedure;Procedure FindInPBStringCode(SearchString$, KeywordList$, posdep = 0, CheckMode = #CheckAll, FMode = #PB_String_CaseSensitive)  ;  ; Identique à FindInPBPointedCode avec une recherche sur une chaîne  ; ordinaire passée en paramètre.  ; Cela peut être plus pratique pour les chaînes courtes.  ;  Protected SearchString.String\s = SearchString$  ;  ProcedureReturn FindInPBPointedCode(SearchString, KeywordList$, posdep, CheckMode, FMode)EndProcedure;Procedure ReverseFindInPBCode(txt$, KeywordList$, posdep = 0, CheckMode = #CheckAll, FMode = #PB_String_CaseSensitive)  ;  ; Cherche un mot clé (ou une liste de mots clé dans une page de code PureBasic,  ; en vérifiant que ce(s) mot(s) clé ne sont pas placés dans un commentaire ou des guillemets  ;  ; KeywordList$ peut comporter plusieurs mots séparés par des virgules, comme par  ; exemple "IncludeFile,XIncludeFile", auquel cas, c'est le premier mot trouvé  ; qui déterminera la position de retour.  ;  ; Contrairement à la procédure FindInPBCode(), celle-ci cherche le(s) mot(s) clé  ; en AMONT (avant) la position posdep. C'est une recherche en marche arrière.  ;  ; Si vous voulez faire figurer une virgule dans l'un des mots de la liste KeywordList$  ; remplacez la virgule par l'expression "\comma_". Ou bien, si vous ne faites une recherche  ; que sur une seule expression, attribuez la valeur '#CheckOneKeyWordOnly' à 'CheckMode'  ; et les virgules ne seront plus considérées comme des séparateurs de mots-clés.  ; #CheckOneKeyWordOnly peut être combiné à toutes les autres valeurs de l'énumération  ; 'CheckModesForFindInPBCode'. Par exemple : #CheckOnlyLeft|#CheckOneKeyWordOnly  ;  ; L'énumération CheckModesForFindInPBCode liste les diverses possibilités de vérification  ; qui seront effectuées sur la chaîne recherchée.  ; Si CheckMode vaut 1 ou 5 ou 7, la chaîne ne sera considérée comme trouvée que si elle est  ; bordée d'un séparateur valide sur son côté gauche (la liste des séparateurs valides  ; est définie par la variable globale ListPBSep$, définie un peu plus haut).  ; Si CheckMode vaut 2 ou 6 ou 7, la chaîne ne sera considérée comme trouvée que si elle est  ; bordée d'un séparateur valide sur son côté droit.  ; Si CheckMode vaut 4 ou 5 ou 7, la chaîne ne sera considérée comme trouvée que si elle est  ; ne figure pas dans un commentaire ou entre guillemets.  ;  ; Remarque : 'ReverseFindInPBCode()' utilise une version inversée (et donc modifiée)  ; de la chaîne 'txt$' passée en paramètre. Elle l'a stocke en 'Static' afin d'éviter  ; de perdre du temps à calculer un ReverseString() à chaque appel.  ;  Static SearchString$  ;    Protected FirstKeyword$, FirstKeywordPos, nl, Keyword$, cg$  Protected posdepR, p, ppv, nbg, SimpleSearch, SStringLength  ;  If txt$    ; Si la procédure est appelée plusieurs fois, on peut éviter    ; de passer le premier paramètre après le premier appel, car SearchString$ est une    ; variable 'Static' (conservée en mémoire).    ; Cela peut faire gagner du temps si on travaille sur une chaîne de grande taille,    ; car, même si ReverseString() est rapide, elle prend quand même du temps.    SearchString$ = ReverseString(txt$)  EndIf  ;  If KeywordList$    If Right(KeywordList$, 1) = "," : KeywordList$ = Left(KeywordList$, Len(KeywordList$) - 1) : EndIf    KeywordList$ = ReverseString(KeywordList$)    ;    SStringLength = Len(SearchString$)    If posdep      posdep = SStringLength - posdep + 1    EndIf    ;    If CheckMode & #CheckOneKeyWordOnly Or FindString(KeywordList$, ",") = 0      FirstKeyword$ = KeywordList$      SimpleSearch = 1    Else      SimpleSearch = 0    EndIf    ;    ;    ReverseSearchFurtherLabel:     If SimpleSearch      FirstKeywordPos = FindString(SearchString$, KeywordList$, posdep, FMode)    Else      FirstKeyword$ = ""      FirstKeywordPos = 0      nl = 1      Repeat        Keyword$ = StringField(KeywordList$, nl, ",")        If Keyword$          Keyword$ = ReplaceString(Keyword$, "\comma_", ",")          p = FindString(SearchString$, Keyword$, posdep, FMode)          If p And ((p - Len(Keyword$) < FirstKeywordPos - Len(FirstKeyword$)) Or FirstKeywordPos = 0)            FirstKeywordPos = p            FirstKeyword$ = Keyword$          EndIf        EndIf        nl + 1      Until Keyword$ = ""    EndIf    ;    ;    If FirstKeywordPos        p = FirstKeywordPos + Len(FirstKeyword$)        ; On commence par vérifier que le mot trouvé est bien encadré par des séparateurs valides.      If (CheckMode & #CheckOnlyRight And p <= SStringLength And FindString(ListPBSep$, FastMid(SearchString$, p, 1), 0) = 0) Or (CheckMode & #CheckOnlyLeft And p - Len(FirstKeyword$) - 1 > 0 And FindString(ListPBSep$, FastMid(SearchString$, p - Len(FirstKeyword$) - 1, 1), 0) = 0)        ; Au moins un des séparateurs n'est pas valide.        posdep = p        Goto ReverseSearchFurtherLabel ; On recommence la recherche.      EndIf      ;      If CheckMode & #CheckOnlyComAndQuote        ;        posdepR = FindString(SearchString$, Chr(13), p) ; on remonte au début de ligne (dans l'ordre normal).        If posdepR = 0 : posdepR = SStringLength + 1 : EndIf        ;        If posdepR > p          cg$ = FastMid(SearchString$, p, posdepR - p) ; On extrait le segment entre l'expression trouvée et le début de ligne.          ppv = FindString(cg$, ";")          If ppv            ; On extrait le segment entre le point virgule et le début de ligne,            ; et on compte le nombre de guillemets que contient le segment.            nbg = CountString(FastMid(cg$, ppv), Chr(34))            If Not (nbg & 1) ; Il n'y a pas de guillemets, ou il y a un nombre pair de guillemets.               ; L'expression a donc été trouvée dans un commentaire. Ça ne marche pas.              posdep = p + ppv - 1 ; On remonte avant le début de commentaire (dans l'ordre normal).              Goto ReverseSearchFurtherLabel ; et on recommence la recherche.            EndIf          EndIf          ;          ; On regarde si l'expression trouvée n'est pas entre guillemets :          ;          ; On compte les guillemets entre le début de ligne et l'expression          ; (c'est-à-dire, dans l'ordre inverse, entre l'expression et posdepR).          nbg = CountString(cg$, Chr(34))          If nbg & 1 ; Il y a un nombre impair de guillemets. L'expression est donc entre guillemets.                   ; On remonte avant le début des guillemets (dans l'ordre normal),                   ; c'est-dire après les guillemets dans l'ordre inverse            posdep = FirstOccurrenceOfChar(SearchString$, Chr(34) + Chr(13) + ":", p) + 1             If posdep              Goto ReverseSearchFurtherLabel ; et on relance la recherche.            Else              ProcedureReturn 0            EndIf          EndIf        EndIf      EndIf      If p        ProcedureReturn SStringLength - p  + 2      EndIf    EndIf  EndIfEndProcedure;Procedure FindReplaceInPBPointedCode(*SearchString.String, SearchKeyword$, ReplaceKeyword$, posdep = 0, CheckMode = #CheckAll, FMode = #PB_String_CaseSensitive)  ;  Protected Rep = 0  ;  If posdep : posdep - 1 : EndIf  Repeat    posdep = FindInPBPointedCode(*SearchString, SearchKeyword$, posdep + 1, CheckMode | #CheckOneKeyWordOnly, FMode)    If posdep      *SearchString\s = FastLeft(*SearchString\s, posdep - 1) + ReplaceKeyword$ + FastMid(*SearchString\s, posdep + Len(SearchKeyword$))      Rep + 1      posdep + Len(ReplaceKeyword$) - 1    EndIf  Until posdep = 0EndProcedure; IDE Options = PureBasic 6.11 LTS (Windows - x64); CursorPosition = 310; Folding = w; EnableXP; DPIAware