; *******************************************************;;               PB Browser Custom Tools;;; PB Browser is designed to be a PureBasic tool.; But this tool can also have tools added to it,; which you can write yourself, by tapping into the; library of functions already written to explore; your source code or to transform them in an; automated way.;; To add a tool to the list of PB Browser tools,; nothing could be simpler:; 1- Write a procedure without input parameters;    or with a parameter of type 'string$'.; 2- Set up a variable with the structure 'CommandDetails'.;    If you name your variable 'NCommand', for example, it would;    look like: NCommand.CommandDetails\CommandName$ = "Tool Name".;;    You need to fill in the following fields:;     \CommandName$          must contain the name of your tool.;     \Commandtype           must be '1' for procedures;                              without parameters, and '2' for;                              procedures with parameters.;     \CommandDescription$   must contain the tool's description.;     \CommandSimpleProcAdr  must contain the address of the procedure.; 3- Add the line 'AddCommandToList(NCommand)' (with your variable name;    as the parameter) following points 1- and 2-.;; And that's all. From that point, the tool will appear in the; list of PB Browser tools, and you can assign a keyboard shortcut; to it if you wish.;; A small possible subtlety: if you want to make your tool multilingual,; you can add lines in the 'Catalog' files, and indicate the names of these; lines with the mention 'InCatalog:' in the fields; \CommandName$ and \CommandDescription$, as you can see in the tool; 'ExportPBBSrcFile()' below. But this is completely optional.; To keep it simple, follow the example below:;; Procedure ToolExample();   AlertInPBBWindow ("Hello!"); EndProcedure; ;; NCommand.CommandDetails\CommandName$ = "Tool Example"; NCommand\Commandtype = 1; NCommand\CommandDontShow = 0; NCommand\CommandDescription$  = "Tool Example is a very simple tool which does absolutely nothing, except printing a message."; NCommand\CommandSimpleProcAdr = @ToolExample(); AddCommandToList(NCommand);; If you remove the comments from the lines of this example, you will see it; appear in the list of PB Browser tools.;;;Procedure CosmeticOneFile(FileName$, WGadget)  ;  ; Normalise les espaces dans la présentation du code pour le fichier 'FileName$'.  ;  ;  Protected PosInCode, PreceedingWord$, dTest, cont, pTest, CharP  Protected CodeContent.String     CodeContent\s = FileToText(FileName$)  Protected mCodeContent$ = CodeContent\s  ;  FindReplaceInPBPointedCode(CodeContent, " (", "(", 0, #CheckOnlyComAndQuote)  FindReplaceInPBPointedCode(CodeContent, ": ", ":", 0, #CheckOnlyComAndQuote)  FindReplaceInPBPointedCode(CodeContent, ":", ": ", 0, #CheckOnlyComAndQuote)  FindReplaceInPBPointedCode(CodeContent, "):", ") :", 0, #CheckOnlyComAndQuote)  FindReplaceInPBPointedCode(CodeContent, "Else:", "Else :", 0, #CheckOnlyComAndQuote)  ;  If IsGadget(WGadget)    txg$ + GetGadgetText(WGadget)    If Right(txg$, 1) <> Chr(13)      txg$ + Chr(13)    EndIf    txg$ + "."    SetGadgetText(WGadget, txg$)  EndIf  ;  ; On ajoute un espace avant ":" quand ce caractère est précédé d'un nombre:  PosInCode = 0  Repeat    PosInCode = FindInPBPointedCode(CodeContent, ":", PosInCode + 1, #CheckOnlyComAndQuote | #CheckOneKeyWordOnly)    If PosInCode And FastMid(CodeContent\s, PosInCode - 1, 1) <> " "      ; On va regarder quel est le mot qui précède:      PreceedingWord$ = ""      dTest = PosInCode      While dTest And PeekC(@CodeContent\s + (dTest - 1) * SizeOf(CHARACTER)) <> 32        dTest - 1      Wend      dTest + 1      PreceedingWord$ = Fastmid(CodeContent\s, dTest, PosInCode - dTest)      If IsStringNum(PreceedingWord$)        CodeContent\s = FastLeft(CodeContent\s, PosInCode - 1) + " " + FastMid(CodeContent\s, PosInCode)      EndIf    EndIf  Until PosInCode = 0  ;  ; On ajoute un espace avant et un espace après +-*/><=(&|,  ; avec une gestion particulière pour *(,  ctr = 0  PosInCode = 0  Repeat    ctr + 1    If ctr = 500      ctr = 0      If txg$        txg$ + "."        SetGadgetText(WGadget, txg$)      EndIf    EndIf    ;    PosInCode = FindInPBPointedCode(CodeContent, "+,-,*,/,>,<,=,\comma_,(,&,|", PosInCode + 1, #CheckOnlyComAndQuote)    If PosInCode      cont = 1      If FastMid(CodeContent\s, PosInCode, 1) = "*"        ; Le caractère "*" pose un problème particulier à cause de sa double fonction :        ; il peut représenter l'opérateur de multiplication ou bien indiquer qu'une        ; variable est un pointeur.        ; On va essayer d'identifier sa fonction en regardant ce qu'il y a avant.        ; On saute "*" et on se positionne sur le caractère précédent :        pTest = PosInCode - 1        ; On saute les espaces qui précèdent peut-être :        While pTest And PeekC(@CodeContent\s + (pTest - 1) * SizeOf(CHARACTER)) = 32          pTest - 1        Wend        ;        CharP = PeekC(@CodeContent\s + (pTest - 1) * SizeOf(CHARACTER))        If CharP = 10 Or CharP = 13          pTest = 0        EndIf        ;        ; On va regarder quel est le mot qui précède:        PreceedingWord$ = ""        If pTest          dTest = pTest          While dTest And PeekC(@CodeContent\s + (dTest - 1) * SizeOf(CHARACTER)) <> 32            dTest - 1          Wend          dTest + 1          PreceedingWord$ = "," + LCase(Fastmid(CodeContent\s, dTest, pTest - dTest + 1)) + ","        EndIf        ;        If pTest = 0 Or FindString("(,@+-/*=&:~<>|[" + Chr(13), Chr(PeekC(@CodeContent\s + (pTest - 1) * SizeOf(CHARACTER)))) Or (PreceedingWord$ And FindString(LCase(#OperatorAsWord$), PreceedingWord$))          ; Il y a un autre opérateur avant, ou bien un séparateur qui indique que le signe "*"          ; est à considérer comme un indicateur de pointeur. On intègre donc "*" au nom de la variable.          cont = 0        Else          cont = 1        EndIf        ;      ElseIf FastMid(CodeContent\s, PosInCode, 1) = "("        ; Le caractère "(" est un cas à part :        ; Dans les formules de calcul, il doit être précédé d'un espace,        ; mais lorsqu'il figure à la suite d'un nom de fonction ou de procédure,        ; il ne doit pas être précédé d'un espace.        pTest = PosInCode - 1        ; On saute les espaces qui précèdent peut-être :        While pTest And PeekC(@CodeContent\s + (pTest - 1) * SizeOf(CHARACTER)) = 32          pTest - 1        Wend        ;        CharP = PeekC(@CodeContent\s + (pTest - 1) * SizeOf(CHARACTER))        If CharP = 10 Or CharP = 13          pTest = 0        EndIf        ;        ; On va regarder quel est le mot qui précède:        PreceedingWord$ = ""        If pTest          dTest = pTest          While dTest And PeekC(@CodeContent\s + (dTest - 1) * SizeOf(CHARACTER)) <> 32            dTest - 1          Wend          dTest + 1          PreceedingWord$ = "," + LCase(Fastmid(CodeContent\s, dTest, pTest - dTest + 1)) + ","        EndIf        ;        If pTest = 0 Or FindString("(,@+-/*=&:~<>|[" + Chr(13), Chr(PeekC(@CodeContent\s + (pTest - 1) * SizeOf(CHARACTER)))) Or (PreceedingWord$ And FindString(LCase(#OperatorAsWord$), PreceedingWord$))          ; Il y a un autre opérateur avant, ou bien un séparateur qui indique que le signe "("          ; doit être précédé d'un espace.          cont = 1        Else          cont = 0        EndIf      EndIf      ;      If cont        If FindString(" <>=", FastMid(CodeContent\s, PosInCode - 1, 1)) = 0 And FastMid(CodeContent\s, PosInCode, 1) <> ","          CodeContent\s = FastLeft(CodeContent\s, PosInCode - 1) + " " + FastMid(CodeContent\s, PosInCode)          PosInCode + 1        EndIf        If FindString(" <>=", FastMid(CodeContent\s, PosInCode + 1, 1)) = 0 And FastMid(CodeContent\s, PosInCode, 1) <> "("          CodeContent\s = FastLeft(CodeContent\s, PosInCode) + " " + FastMid(CodeContent\s, PosInCode + 1)          PosInCode + 1        EndIf      EndIf    EndIf  Until PosInCode = 0  ;  FindReplaceInPBPointedCode(CodeContent, "( ", "(", 0, #CheckOnlyComAndQuote)  FindReplaceInPBPointedCode(CodeContent, " )", ")", 0, #CheckOnlyComAndQuote)  ;  FindReplaceInPBPointedCode(CodeContent, ", - ", ", -", 0, #CheckOnlyComAndQuote)  FindReplaceInPBPointedCode(CodeContent, "(- ",  "(-",  0, #CheckOnlyComAndQuote)  If txg$    txg$ + "."    SetGadgetText(WGadget, txg$)  EndIf  FindReplaceInPBPointedCode(CodeContent, "= - ", "= -", 0, #CheckOnlyComAndQuote)  FindReplaceInPBPointedCode(CodeContent, "> - ", "> -", 0, #CheckOnlyComAndQuote)  FindReplaceInPBPointedCode(CodeContent, "< - ", "< -", 0, #CheckOnlyComAndQuote)  FindReplaceInPBPointedCode(CodeContent, "* - ", "* -", 0, #CheckOnlyComAndQuote)  FindReplaceInPBPointedCode(CodeContent, "+ - ", "+ -", 0, #CheckOnlyComAndQuote)  FindReplaceInPBPointedCode(CodeContent, "/ - ", "/ -", 0, #CheckOnlyComAndQuote)  ;  If mCodeContent$ <> CodeContent\s    TexteDansFichier(FileName$, CodeContent\s, #PB_UTF8, 0, 1)    ProcedureReturn #True  Else    ProcedureReturn #False  EndIf  ;EndProcedure;Procedure CosmeticFileTransformer()  ;  ; Normalise les espaces dans la présentation du code pour tous les fichiers.  ;  Shared BackgroundTasksCompletion  ;  Protected Res, PosInFileList, WGadget, LineC$, FileName$, mPBBListOfFiles$, Reload, BOText$  Protected Modified = 0  ;  DisablePBBWindow()  Res = AlertYesNoCancel(GetTextFromCatalog("MakeACopy"), "", #AW_OKOrCancel_OKByDefault)  If Res = #PB_MessageRequester_Yes    PosInFileList = 0    ;    WGadget = OpenWaitWindow(GPBBGadgets\PBBWindow, "")    ;    ; On parcourt la liste des fichiers contenus dans PBBListOfFiles$    Repeat       PosInFileList + 1      LineC$ = StringField(PBBListOfFiles$, PosInFileList, Chr(13))      If LineC$        ; On extrait le nom de fichier :        FileName$ = StringField(LineC$, 1, Chr(9))        If FileSize(FileName$) > 1          ; Affichage de la fenêtre d'attente          If IsGadget(WGadget)            SetGadgetText(WGadget, GetTextFromCatalog("CosmeticFileTransformerTitle") + Chr(13) + GetFilePart(FileName$) + ".")          EndIf          If CosmeticOneFile(FileName$, WGadget)            Modified = 1          EndIf        EndIf      EndIf    Until LineC$ = ""    If IsGadget(WGadget)      DestroyParentWindow(WGadget)    EndIf    AlertInPBBWindow(GetTextFromCatalog("WorkDone"))    ;    If Modified      ; Beaucoup de fichiers on pu être transformés.      ; On relance donc une exploration complète.      BackgroundTasksCompletion = #BackgroundTasksMustRestart    EndIf  EndIf  EnablePBBWindow()EndProcedure;NCommand\CommandName$ = "InCatalog:CosmeticFileTransformerTitle"NCommand\Commandtype = 1NCommand\CommandDontShow = 0NCommand\CommandDescription$  = "InCatalog:CosmeticFileTransformerEx"NCommand\CommandSimpleProcAdr = @CosmeticFileTransformer()AddCommandToList(NCommand);Procedure CheckProcOfOneFile(FileName$, WGadget)  ;  ; Parcourt les procédures d'un fichier pour en extraire les procédures  ; et en vérifier les listes de variables déclarées et utilisées.  ; Le résultat figurera comme suit :  ; • Pour les variables déclarées et non-utilisée, une mention sera ajoutée dans le  ;   code des procédures.  ; • Pour les variables utilisées, mais non déclarées, une ligne comportant  ;   la mention 'Protected' suivie de la liste des variables concernées sera  ;   ajoutée dans le code des procédures.  ;  Protected CodeContent.String, ProcCode.String  Protected VList.VariableListings  ;  ; Récupération du code contenu dans le fichier  Protected cont = 0  Protected PosInCode, pf, ProcName$, NDeclare$, NDeclareAdd$, EndProcPos, mLenProc  Protected ProcCode$, PosInProc, PosFound, DefaultPosFound, Searchcont, mPosInProc  Protected FirstWordInLine$, SpaceBefore$, pd  Protected *OriginalCodeContent.String = GetPointedCodeFromFile(FileName$)  ;  ;  If IsGadget(WGadget)    txg$ + GetGadgetText(WGadget)    If Right(txg$, 1) <> Chr(13)      txg$ + Chr(13)    EndIf    txg$ + "."    SetGadgetText(WGadget, txg$)  EndIf  ;  ; On fait une copie du code car on va le modifier.  CodeContent\s = *OriginalCodeContent\s  PosInCode = 0  Repeat    ctr + 1    If ctr = 10      ctr = 0      If txg$        txg$ + "."        SetGadgetText(WGadget, txg$)      EndIf    EndIf    ; On cherche la mention "Procedure" dans tout le fichier    PosInCode = FindInPBPointedCode(CodeContent, "Procedure", PosInCode + 1)    If PosInCode      PosInCode + Len("Procedure")      ; On saute les espaces qui suivent :      While FastMid(CodeContent\s, PosInCode, 1) = " " : PosInCode + 1 : Wend      ; On élimine une éventuelle déclaration de type après le mot "Procedure".      If FastMid(CodeContent\s, PosInCode, 1) = "."        While FastMid(CodeContent\s, PosInCode, 1) <> " " : PosInCode + 1 : Wend        While FastMid(CodeContent\s, PosInCode, 1) = " " : PosInCode + 1 : Wend      EndIf      pf = FindInPBPointedCode(CodeContent, "(", PosInCode, #CheckOnlyComAndQuote | #CheckOneKeyWordOnly)      If pf        ProcName$ = FastMid(CodeContent\s, PosInCode, pf - PosInCode)        ;        ; On fait appelle à la procédure ListVariables() qui dresse la liste des variables        ; non protégées et déclarées mais non utilisées :        If ListVariables(ProcName$, VList) And (VList\Unprotected Or VList\Unused)          ; On prépare la mention que l'on va ajouter dans le code de la procédure.          NDeclare$ = ""          If VList\Unprotected            NDeclare$ = "Protected " + Trim(StringField(VList\Unprotected, 2, ":")) + " ; ********* Added by PPBrowser." + Chr(13)          EndIf          If VList\Unused            NDeclareAdd$ = "; " + VList\Unused + " ********* (PPBrowser comment)" + Chr(13)            If FindString(CodeContent\s, NDeclareAdd$) = 0 ; Au cas où la remarque figurerait déjà dans le fichier.              NDeclare$ + NDeclareAdd$            EndIf          EndIf          If NDeclare$            EndProcPos = FindInPBPointedCode(CodeContent, "EndProcedure", PosInCode, #CheckOneKeyWordOnly)            If EndProcPos              ; On extrait le code de la procédure :              ProcCode\s = FastMid(CodeContent\s, PosInCode, EndProcPos - PosInCode)              mLenProc = Len(ProcCode$)              ;              ; On va maintenant chercher où placer la mention :              PosInProc = 0              PosFound = 0              DefaultPosFound = 0              Searchcont = 1              Repeat                mPosInProc = PosInProc                PosInProc = FindString(ProcCode\s, Chr(13), PosInProc + 1)                If PosInProc                  PosInProc + 1                  If DefaultPosFound = 0                    ; La position par défaut sera la première ligne sous                    ; la déclaration de la procédure.                    DefaultPosFound = PosInProc                  EndIf                  ; On saute les espaces en début de ligne :                  While FastMid(ProcCode\s, PosInProc, 1) = " " : PosInProc + 1 : Wend                  ; On cherche le prochain espace :                  pf = FindInPBPointedCode(ProcCode, " ", PosInProc, #CheckOnlyComAndQuote | #CheckOneKeyWordOnly)                  If pf                    FirstWordInLine$ = FastMid(ProcCode\s, PosInProc, pf - PosInProc)                    If FirstWordInLine$ = "Protected" Or FirstWordInLine$ = "Static" Or FirstWordInLine$ = "Shared"                      PosFound = PosInProc                    ElseIf ReplaceString(FirstWordInLine$, Chr(13), "") And Left(FirstWordInLine$, 1) <> ";"                      ; Si la ligne n'est pas vide ou composée d'un commentaire,                      ; on arrête la recherche.                      Searchcont = 0                    EndIf                  EndIf                EndIf              Until PosInProc = 0 Or Searchcont = 0              If PosFound = 0                PosFound = DefaultPosFound              EndIf              If PosFound > 0                SpaceBefore$ = ""                pd = PosFound                While pd > 1 And FastMid(ProcCode\s, pd - 1, 1) = " "                  pd - 1                  SpaceBefore$ + " "                Wend                ; On intègre la mention dans le code de la procédure :                ProcCode\s = FastLeft(ProcCode\s, PosFound - 1) + NDeclare$ + SpaceBefore$ + FastMid(ProcCode\s, PosFound)                ; On ré-intègre le code de la procédure dans le fichier :                CodeContent\s  = FastLeft(CodeContent\s, PosInCode - 1) + ProcCode\s + FastMid(CodeContent\s, EndProcPos)                PosInCode - mLenProc + Len(ProcCode\s)                cont = 1              EndIf            EndIf          EndIf        EndIf      EndIf    EndIf  Until PosInCode = 0  If cont    TexteDansFichier(FileName$, CodeContent\s, #PB_UTF8, 0, 1)    ProcedureReturn #True  Else    ProcedureReturn #False  EndIfEndProcedure;Procedure CheckProcVar()  ;  ; Parcourt les procédures de tous les fichiers figurant dans la liste des fichiers  ; pour en extraire les procédures et en vérifier les listes de variables déclarées  ; et utilisées. Le résultat figurera comme suit :  ; • Pour les variables déclarées et non-utilisée, une mention sera ajoutée dans le  ;   code des procédures.  ; • Pour les variables utilisées, mais non déclarées, une ligne comportant  ;   la mention 'Protected' suivie de la liste des variables concernées sera  ;   ajoutée dans le code des procédures.  ;  Shared BackgroundTasksCompletion  ;  Protected Res, PosInFileList, WGadget, LineC$, FileName$, mPBBListOfFiles$, Reload, BOText$  Protected Modified = 0  ;  If ListCompletionAll(#PBBVariable) <> #ListCompletion_Done    ; On a besoin que la liste des variables soit établie pour    ; pouvoir continuer.    SetOneListOfAllElements(#PBBVariable, #FinishCompletionNow)  EndIf  ;  DisablePBBWindow()  Res = AlertYesNoCancel(GetTextFromCatalog("MakeACopy"), "", #AW_OKOrCancel_OKByDefault)  If Res = #PB_MessageRequester_Yes    PosInFileList = 0    ;    WGadget = OpenWaitWindow(GPBBGadgets\PBBWindow, "")    ;    ; On parcourt la liste des fichiers contenus dans PBBListOfFiles$    Repeat       PosInFileList + 1      LineC$ = StringField(PBBListOfFiles$, PosInFileList, Chr(13))      If LineC$        ; On extrait le nom de fichier :        FileName$ = StringField(LineC$, 1, Chr(9))        If FileSize(FileName$) > 1          ; Affichage de la fenêtre d'attente          If IsGadget(WGadget)            SetGadgetText(WGadget, GetTextFromCatalog("ProcVariablesTitle") + Chr(13) + GetFilePart(FileName$) + ".")          EndIf          If CheckProcOfOneFile(FileName$, WGadget)            Modified = 1          EndIf        EndIf      EndIf    Until LineC$ = ""    If IsGadget(WGadget)      DestroyParentWindow(WGadget)    EndIf    AlertInPBBWindow(GetTextFromCatalog("WorkDone"))    ;    If Modified      ; Beaucoup de fichiers on pu être transformés.      ; On relance donc une exploration complète.      BackgroundTasksCompletion = #BackgroundTasksMustRestart    EndIf  EndIf  EnablePBBWindow()EndProcedure;NCommand\CommandName$ = "InCatalog:ProcVariablesTitle"NCommand\Commandtype = 1NCommand\CommandDontShow = 0NCommand\CommandDescription$  = "InCatalog:ProcVariablesEx"NCommand\CommandSimpleProcAdr = @CheckProcVar()AddCommandToList(NCommand);Procedure ExportPBBSrcFile()  RunProgram("https://www.editions-humanis.com/downloads/PureBasic/ZapmanDowloads_EN.htm")EndProcedure;NCommand\CommandName$ = "InCatalog:ExportSourceCodeTitle"NCommand\Commandtype = 1NCommand\CommandDontShow = 1NCommand\CommandDescription$  = "InCatalog:ExportSourceCodeEx"NCommand\CommandSimpleProcAdr = @ExportPBBSrcFile()AddCommandToList(NCommand);; IDE Options = PureBasic 6.12 LTS (Windows - x86); CursorPosition = 490; FirstLine = 460; Folding = -; EnableXP; DPIAware; UseMainFile = ..\..\PBBrowser.pb