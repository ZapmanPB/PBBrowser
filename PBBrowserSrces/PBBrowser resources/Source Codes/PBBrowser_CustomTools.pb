; *******************************************************;;               PB Browser Custom Tools;;; PB Browser is designed to be a PureBasic tool.; But this tool can also have tools added to it,; which you can write yourself, by tapping into the; library of functions already written to explore; your source code or to transform them in an; automated way.;; To add a tool to the list of PB Browser tools,; nothing could be simpler:; 1- Write a procedure without input parameters; 2- Set up a variable with the structure 'CommandDetails'.;    If you name your variable 'NCommand', for example, it would;    look like: NCommand.CommandDetails\CommandName$ = "Tool Name".;;    You need to fill in the following fields:;     \CommandName$          must contain the name of your tool.;     \Commandtype           must be '1'.;     \CommandDescription$   must contain the tool's description.;     \CommandSimpleProcAddr  must contain the address of the procedure.; 3- Add the line 'AddCommandToList(NCommand)' (with your variable name;    as the parameter) following points 1- and 2-.;; And that's all. From that point, the tool will appear in the; list of PB Browser tools, and you can assign a keyboard shortcut; to it if you wish.;; A small possible subtlety: if you want to make your tool multilingual,; you can add lines in the 'Catalog' files, and indicate the names of these; lines with the mention 'InCatalog:' in the fields; \CommandName$ and \CommandDescription$, as you can see in the tool; 'ExportPBBSrcFile()' below. But this is completely optional.;; To keep it simple, follow the example below:;; Procedure ToolExample();   AlertInPBBWindow ("Hello!"); EndProcedure; ;; NCommand.CommandDetails\CommandName$ = "Tool Example"; NCommand\Commandtype = 1; NCommand\CommandDontShow = 0; NCommand\CommandDescription$  = "Tool Example is a very simple tool which does absolutely nothing, except printing a message."; NCommand\CommandSimpleProcAddr = @ToolExample(); AddCommandToList(NCommand);; If you remove the comments from the lines of this example, you will see it; appear in the list of PB Browser tools.;;;Procedure CosmeticOneFile(FileName$, WGadget)  ;  ; Normalize spaces in the code presentation for the file 'FileName$'.  ;  ;  Protected PosInCode, PreceedingWord$, dTest, cont  Protected pTest, CharP, txg$, ctr, LineOfCode$  Protected *CodeContent.String    *CodeContent = GetPointedCodeFromFile(FileName$)  Protected mCodeContent$ = *CodeContent\s  ;  FindReplaceInPBPointedCode(*CodeContent, " (", "(", 0, #CheckOnlyComAndQuote | #CheckOneKeyWordOnly)  FindReplaceInPBPointedCode(*CodeContent, ": ", ":", 0, #CheckOnlyComAndQuote | #CheckOneKeyWordOnly)  FindReplaceInPBPointedCode(*CodeContent, ":", ": ", 0, #CheckOnlyComAndQuote | #CheckOneKeyWordOnly)  FindReplaceInPBPointedCode(*CodeContent, "):", ") :", 0, #CheckOnlyComAndQuote | #CheckOneKeyWordOnly)  FindReplaceInPBPointedCode(*CodeContent, "Else:", "Else :", 0, #CheckOnlyComAndQuote | #CheckOneKeyWordOnly)  ;  If IsGadget(WGadget)    txg$ + GetGadgetText(WGadget)    If Right(txg$, 1) <> #CR$      txg$ + #CR$    EndIf    txg$ + "."    SetGadgetText(WGadget, txg$)  EndIf  ;  ; Add a space before ":" when it is preceeded by a number:  PosInCode = 0  Repeat    PosInCode = FindInPBPointedCode(*CodeContent, ":", PosInCode + 1, #CheckOnlyComAndQuote | #CheckOneKeyWordOnly)    If PosInCode And FastMid(*CodeContent\s, PosInCode - 1, 1) <> " "      ; Look for the preceding word:      PreceedingWord$ = ""      dTest = PosInCode      While dTest And PeekC(@*CodeContent\s + (dTest - 1) * SizeOf(CHARACTER)) <> #Space        dTest - 1      Wend      dTest + 1      PreceedingWord$ = Fastmid(*CodeContent\s, dTest, PosInCode - dTest)      If IsStringNum(PreceedingWord$)        *CodeContent\s = FastLeft(*CodeContent\s, PosInCode - 1) + " " + FastMid(*CodeContent\s, PosInCode)      EndIf    EndIf  Until PosInCode = 0  ;  ; Add a space before and after +-*/><=(&|,  ; with special handling for *(  ctr = 0  PosInCode = 0  Repeat    ctr + 1    If ctr = 500      ctr = 0      If txg$        txg$ + "."        SetGadgetText(WGadget, txg$)      EndIf    EndIf    ;    PosInCode = FindInPBPointedCode(*CodeContent, "+,-,*,/,>,<,=,\comma_,(,&,|", PosInCode + 1, #CheckOnlyComAndQuote)    If PosInCode      cont = 1      test$ = FastMid(*CodeContent\s, PosInCode, 40)      If PosInCode > 1 And PosInCode < Len(*CodeContent\s) And FastMid(*CodeContent\s, PosInCode, 1) = "*" And FindString(ListPBSep$, FastMid(*CodeContent\s, PosInCode + 1, 1)) = 0                              If FindString(test$, "PBData")        Debug test$        Debug FindString(ListPBSep$, FastMid(*CodeContent\s, PosInCode + 1, 1))        CallDebugger      EndIf                ; The "*" character has a particular issue due to its dual function:        ; it can represent either the multiplication operator or indicate that a        ; variable is a pointer.        ; We try to identify its function by looking at what comes before it.        pTest = PosInCode        Repeat          pTest - 1          CharP = PeekC(@*CodeContent\s + (pTest - 1) * SizeOf(CHARACTER))        Until pTest = 1 Or CharP = #LF Or CharP = #CR Or CharP = ':'        If CharP = #LF Or CharP = #CR Or CharP = ':' : pTest + 1 : EndIf        ;        LineOfCode$ = FastMid(*CodeContent\s, pTest, PosInCode - pTest + 2)        If RecognizePointer(LineOfCode$, Len(LineOfCode$))          cont = 0        EndIf        ;      ElseIf FastMid(*CodeContent\s, PosInCode, 1) = "("        ; The "(" character is a special case:        ; In mathematical formulas, it must be preceded by a space,        ; but when it follows a function or procedure name, it should not have a space before.        pTest = PosInCode - 1        ; Skip any spaces that may precede:        While pTest And PeekC(@*CodeContent\s + (pTest - 1) * SizeOf(CHARACTER)) = #Space          pTest - 1        Wend        ;        CharP = PeekC(@*CodeContent\s + (pTest - 1) * SizeOf(CHARACTER))        If CharP = #LF Or CharP = #CR          pTest = 0        EndIf        ;        ; Look for the preceding word:        PreceedingWord$ = ""        If pTest          dTest = pTest          While dTest And PeekC(@*CodeContent\s + (dTest - 1) * SizeOf(CHARACTER)) <> #Space            dTest - 1          Wend          dTest + 1          PreceedingWord$ = "," + LCase(Fastmid(*CodeContent\s, dTest, pTest - dTest + 1)) + ","        EndIf        ;        If pTest = 0 Or FindString("(,@+-/*=&:~<>|[" + #CR$, Chr(PeekC(@*CodeContent\s + (pTest - 1) * SizeOf(CHARACTER)))) Or (PreceedingWord$ And FindString(LCase(#OperatorAsWord$), PreceedingWord$))          ; There's another operator before, or a separator indicating that the "(" sign          ; should be preceded by a space.          cont = 1        Else          cont = 0        EndIf      EndIf      ;      If cont        If FindString(" <>='", FastMid(*CodeContent\s, PosInCode - 1, 1)) = 0 And FastMid(*CodeContent\s, PosInCode, 1) <> ","          *CodeContent\s = FastLeft(*CodeContent\s, PosInCode - 1) + " " + FastMid(*CodeContent\s, PosInCode)          PosInCode + 1        EndIf        If FindString(" <>='", FastMid(*CodeContent\s, PosInCode + 1, 1)) = 0 And FastMid(*CodeContent\s, PosInCode, 1) <> "("          *CodeContent\s = FastLeft(*CodeContent\s, PosInCode) + " " + FastMid(*CodeContent\s, PosInCode + 1)          PosInCode + 1        EndIf      EndIf    EndIf  Until PosInCode = 0  ;  FindReplaceInPBPointedCode(*CodeContent, "( ", "(", 0, #CheckOnlyComAndQuote | #CheckOneKeyWordOnly)  FindReplaceInPBPointedCode(*CodeContent, " )", ")", 0, #CheckOnlyComAndQuote | #CheckOneKeyWordOnly)  ;  FindReplaceInPBPointedCode(*CodeContent, ", - ", ", -", 0, #CheckOnlyComAndQuote | #CheckOneKeyWordOnly)  FindReplaceInPBPointedCode(*CodeContent, "(- ",  "(-",  0, #CheckOnlyComAndQuote | #CheckOneKeyWordOnly)  If txg$    txg$ + "."    SetGadgetText(WGadget, txg$)  EndIf  FindReplaceInPBPointedCode(*CodeContent, "= - ", "= -", 0, #CheckOnlyComAndQuote | #CheckOneKeyWordOnly)  FindReplaceInPBPointedCode(*CodeContent, "> - ", "> -", 0, #CheckOnlyComAndQuote | #CheckOneKeyWordOnly)  FindReplaceInPBPointedCode(*CodeContent, "< - ", "< -", 0, #CheckOnlyComAndQuote | #CheckOneKeyWordOnly)  FindReplaceInPBPointedCode(*CodeContent, "* - ", "* -", 0, #CheckOnlyComAndQuote | #CheckOneKeyWordOnly)  FindReplaceInPBPointedCode(*CodeContent, "+ - ", "+ -", 0, #CheckOnlyComAndQuote | #CheckOneKeyWordOnly)  FindReplaceInPBPointedCode(*CodeContent, "/ - ", "/ -", 0, #CheckOnlyComAndQuote | #CheckOneKeyWordOnly)  FindReplaceInPBPointedCode(*CodeContent, ": '", ":'", 0, #CheckOnlyComAndQuote | #CheckOneKeyWordOnly)  ;  If mCodeContent$ <> *CodeContent\s    ; Save with '-1' as third parameter, to ensure that the saving format is    ; the same as original format.    TexteDansFichier(FileName$, *CodeContent\s, -1, 0, 1)    ProcedureReturn #True  Else    ProcedureReturn #False  EndIf  ;EndProcedure;Procedure CosmeticFileTransformer()  ;  ; Normalize spaces in the code presentation for all files.  ;  Shared BackgroundTasksCompletion  ;  Protected Res, PosInFileList, WGadget, LineC$, FileName$  Protected Modified = 0  ;  If Left(GetFilePart(PBBFicPrincipalPB$), Len("PureBasic_TempFile")) = "PureBasic_TempFile"    AlertInPBBWindow(GetTextFromCatalogPB("NotForTempFile"))    ProcedureReturn #False  EndIf  ;  DisablePBBWindow()  Res = AlertInPBBWindow(GetTextFromCatalogPB("MakeACopy"), "", 1, 0, 0, 0, "", #AW_OKOrCancel_OKByDefault)  If Res = #PB_MessageRequester_Yes    PosInFileList = 0    ;    WGadget = OpenWaitWindow(GPBBGadgets\PBBWindow, "")    ;    ; Loop through the list of files contained in PBBListOfFiles$    Repeat       PosInFileList + 1      LineC$ = StringField(PBBListOfFiles$, PosInFileList, #CR$)      If LineC$        ; Extract the file name:        FileName$ = StringField(LineC$, 1, #TAB$)        If FileSize(FileName$) > 1          ; Display the waiting window          If IsGadget(WGadget)            SetGadgetText(WGadget, GetTextFromCatalogPB("CosmeticFileTransformerTitle") + #CR$ + GetFilePart(FileName$) + ".")          EndIf          If CosmeticOneFile(FileName$, WGadget)            Modified = 1          EndIf        EndIf      EndIf    Until LineC$ = ""    If IsGadget(WGadget)      DestroyParentWindow(WGadget)    EndIf    AlertInPBBWindow(GetTextFromCatalogPB("WorkDone"))    ;    If Modified      ; Many files may have been transformed.      ; Therefore, restart a full exploration.      BackgroundTasksCompletion = #BackgroundTasksMustRestart    EndIf  EndIf  EnablePBBWindow()EndProcedure;NCommand\CommandName$ = "InCatalog:CosmeticFileTransformerTitle"NCommand\Commandtype = 1NCommand\CommandDontShow = 0NCommand\CommandDescription$  = "InCatalog:CosmeticFileTransformerEx"NCommand\CommandSimpleProcAddr = @CosmeticFileTransformer()AddCommandToList(NCommand);Procedure CheckProcOfOneFile(FileName$, WGadget)  ;  ; Loops through the procedures of a file to extract the procedures  ; and check the lists of declared and used variables.  ; The result will appear as follows:  ; • For declared but unused variables, a mention will be added in the  ;   procedure code.  ; • For used but undeclared variables, a line with the word 'Protected'  ;   followed by the list of concerned variables will be added in the  ;   procedure code.  ;  Protected CodeContent.String, ProcCode.String  Protected VList.VariableListings  ;  Protected cont = 0  Protected PosInCode, pf, ProcName$, NDeclare$, NDeclareAdd$, EndProcPos, mLenProc  Protected ProcCode$, PosInProc, PosFound, DefaultPosFound, Searchcont, mPosInProc  Protected FirstWordInLine$, SpaceBefore$, pd, txg$, ctr  ;  ; Retrieving the code contained in the file:  Protected *OriginalCodeContent.String = GetPointedCodeFromFile(FileName$)  ;  ;  If IsGadget(WGadget)    txg$ + GetGadgetText(WGadget)    If Right(txg$, 1) <> #CR$      txg$ + #CR$    EndIf    txg$ + "."    SetGadgetText(WGadget, txg$)  EndIf  ;  ; Make a copy of the code, because it will be modified:  CodeContent\s = *OriginalCodeContent\s  PosInCode = 0  Repeat    ctr + 1    If ctr = 10      ctr = 0      If txg$        txg$ + "."        SetGadgetText(WGadget, txg$)      EndIf    EndIf    ; Search for the word "Procedure" throughout the file    PosInCode = FindInPBPointedCode(CodeContent, "Procedure", PosInCode + 1)    If PosInCode      PosInCode + Len("Procedure")      ; Skip the spaces that follow:      While FastMid(CodeContent\s, PosInCode, 1) = " " : PosInCode + 1 : Wend      ; Eliminate any type declaration after the word "Procedure".      If FastMid(CodeContent\s, PosInCode, 1) = "."        While FastMid(CodeContent\s, PosInCode, 1) <> " " : PosInCode + 1 : Wend        While FastMid(CodeContent\s, PosInCode, 1) = " " : PosInCode + 1 : Wend      EndIf      pf = FindInPBPointedCode(CodeContent, "(", PosInCode, #CheckOnlyComAndQuote | #CheckOneKeyWordOnly)      If pf        ProcName$ = FastMid(CodeContent\s, PosInCode, pf - PosInCode)        ;        ; Call the procedure ListVariables() to list the variables        ; that are unprotected and declared but unused:        If ListVariables(ProcName$, VList) And (VList\Unprotected Or VList\Unused)          ; Prepare the mention that will be added in the procedure's code.          NDeclare$ = ""          If VList\Unprotected            NDeclare$ = "Protected " + Trim(StringField(VList\Unprotected, 2, ":")) + " ; ********* Added by PBBrowser." + #CR$          EndIf          If VList\Unused            NDeclareAdd$ = "; " + VList\Unused + " ********* (PBBrowser comment)" + #CR$            If FindString(CodeContent\s, NDeclareAdd$) = 0 ; In case the remark is already in the file.              NDeclare$ + NDeclareAdd$            EndIf          EndIf          If NDeclare$            EndProcPos = FindInPBPointedCode(CodeContent, "EndProcedure", PosInCode, #CheckOneKeyWordOnly)            If EndProcPos              ; Extract the code of the procedure:              ProcCode\s = FastMid(CodeContent\s, PosInCode, EndProcPos - PosInCode)              mLenProc = Len(ProcCode$)              ;              ; Now, search where to place the mention:              PosInProc = 0              PosFound = 0              DefaultPosFound = 0              Searchcont = 1              Repeat                mPosInProc = PosInProc                PosInProc = FindString(ProcCode\s, #CR$, PosInProc + 1)                If PosInProc                  PosInProc + 1                  If DefaultPosFound = 0                    ; The default position will be the first line under                    ; the procedure declaration.                    DefaultPosFound = PosInProc                  EndIf                  ; Skip spaces at the beginning of the line:                  While FastMid(ProcCode\s, PosInProc, 1) = " " : PosInProc + 1 : Wend                  ; Search for the next space:                  pf = FindInPBPointedCode(ProcCode, " ", PosInProc, #CheckOnlyComAndQuote | #CheckOneKeyWordOnly)                  If pf                    FirstWordInLine$ = FastMid(ProcCode\s, PosInProc, pf - PosInProc)                    If FirstWordInLine$ = "Protected" Or FirstWordInLine$ = "Static" Or FirstWordInLine$ = "Shared"                      PosFound = PosInProc                    ElseIf ReplaceString(FirstWordInLine$, #CR$, "") And Left(FirstWordInLine$, 1) <> ";"                      ; If the line is not empty or is not a comment,                      ; stop the search.                      Searchcont = 0                    EndIf                  EndIf                EndIf              Until PosInProc = 0 Or Searchcont = 0              If PosFound = 0                PosFound = DefaultPosFound              EndIf              If PosFound > 0                SpaceBefore$ = ""                pd = PosFound                While pd > 1 And FastMid(ProcCode\s, pd - 1, 1) = " "                  pd - 1                  SpaceBefore$ + " "                Wend                ; Integrate the mention into the procedure's code:                ProcCode\s = FastLeft(ProcCode\s, PosFound - 1) + NDeclare$ + SpaceBefore$ + FastMid(ProcCode\s, PosFound)                ; Re-integrate the procedure's code into the file:                CodeContent\s  = FastLeft(CodeContent\s, PosInCode - 1) + ProcCode\s + FastMid(CodeContent\s, EndProcPos)                PosInCode - mLenProc + Len(ProcCode\s)                cont = 1              EndIf            EndIf          EndIf        EndIf      EndIf    EndIf  Until PosInCode = 0  If cont    ; Save with '-1' as third parameter, to ensure that the saving format is    ; the same as original format.    TexteDansFichier(FileName$, CodeContent\s, -1, 0, 1)    ProcedureReturn #True  Else    ProcedureReturn #False  EndIfEndProcedure;Procedure CheckProcVar()  ;  ; Loops through the procedures in all the files listed in the file list  ; to extract the procedures and check the lists of declared  ; and used variables. The result will appear as follows:  ; • For declared but unused variables, a note will be added in the  ;   procedure code.  ; • For used but undeclared variables, a line with the mention 'Protected'  ;   followed by the list of relevant variables will be added in the procedure code.  ;  Shared BackgroundTasksCompletion  ;  Protected Res, PosInFileList, WGadget, LineC$, FileName$  Protected Modified = 0  ;  If ListCompletionAll(#PBBVariable) <> #ListCompletion_Done    ; We need the list of variables to be established in order to continue.    SetOneListOfAllElements(#PBBVariable, #FinishCompletionNow)  EndIf  ;  If Left(GetFilePart(PBBFicPrincipalPB$), Len("PureBasic_TempFile")) = "PureBasic_TempFile"    AlertInPBBWindow(GetTextFromCatalogPB("NotForTempFile"))    ProcedureReturn #False  EndIf  ;  DisablePBBWindow()  Res = AlertInPBBWindow(GetTextFromCatalogPB("MakeACopy"), "", 1, 0, 0, 0, "", #AW_OKOrCancel_OKByDefault)  If Res = #PB_MessageRequester_Yes    PosInFileList = 0    ;    WGadget = OpenWaitWindow(GPBBGadgets\PBBWindow, "")    ;    ; Loop through the list of files in PBBListOfFiles$    Repeat       PosInFileList + 1      LineC$ = StringField(PBBListOfFiles$, PosInFileList, #CR$)      If LineC$        ; Extract the file name:        FileName$ = StringField(LineC$, 1, #TAB$)        If FileSize(FileName$) > 1          ; Display the wait window          If IsGadget(WGadget)            SetGadgetText(WGadget, GetTextFromCatalogPB("ProcVariablesTitle") + #CR$ + GetFilePart(FileName$) + ".")          EndIf          If CheckProcOfOneFile(FileName$, WGadget)            Modified = 1          EndIf        EndIf      EndIf    Until LineC$ = ""    If IsGadget(WGadget)      DestroyParentWindow(WGadget)    EndIf    AlertInPBBWindow(GetTextFromCatalogPB("WorkDone"))    ;    If Modified      ; Many files may have been modified.      ; Therefore, restart a full exploration.      BackgroundTasksCompletion = #BackgroundTasksMustRestart    EndIf  EndIf  EnablePBBWindow()EndProcedure;NCommand\CommandName$ = "InCatalog:ProcVariablesTitle"NCommand\Commandtype = 1NCommand\CommandDontShow = 0NCommand\CommandDescription$  = "InCatalog:ProcVariablesEx"NCommand\CommandSimpleProcAddr = @CheckProcVar()AddCommandToList(NCommand);Procedure.s CompleteProjectFileList(ProjectDescr$, ListOfFiles$, ProjectAddress$, PBFile = 1, LastOpen = 0)  ;  ; Explore the variable 'ListOfFiles$' to complete the project file list  ; for the project described in 'ProjectDescr$'.  ;  Protected EndOfSection, PosInDescr, fIndex, pf, PosInFileList  Protected EndOfDescr$, QuoteChar$, LineC$, FileName$, DeclaredFile$  ;  ProjectDescr$ = ReplaceDoubleSimpleQuoteByDoubleQuote(ProjectDescr$)  ;  PosInDescr = FindString(ProjectDescr$, "<section name=" + #DOUBLEQUOTE$ + "files" + #DOUBLEQUOTE$)  If PosInDescr = 0    ProjectDescr$ + "  <section name=['']files['']>" + #CR$    EndOfSection = 0  Else    ;    ; A file Section allready exists.    ; Cut all what is after it and put it in 'EndOfDescr$':    EndOfSection = FindString(ProjectDescr$, "</section>", PosInDescr)    FastFindPrecReturn(ProjectDescr$, EndOfSection)    EndOfDescr$ = FastMid(ProjectDescr$, EndOfSection + 1)    ProjectDescr$ = FastLeft(ProjectDescr$, EndOfSection)    ;    ; Get the last file-index value:    PosInDescr = ReverseFindString(ProjectDescr$, "sortindex=")    fIndex = 0    If PosInDescr      PosInDescr + Len("sortindex=")      QuoteChar$ = FastMid(ProjectDescr$, PosInDescr, 1)      If QuoteChar$ = #DOUBLEQUOTE$        PosInDescr + 1        pf = FindString(ProjectDescr$, QuoteChar$, PosInDescr)        If pf          fIndex = Val(FastMid(ProjectDescr$, PosInDescr, pf - PosInDescr))        EndIf      EndIf    EndIf  EndIf  ;  PosInFileList = 0  Repeat    PosInFileList + 1    LineC$ = StringField(ListOfFiles$, PosInFileList, #CR$)    If LineC$      FileName$ = StringField(LineC$, 1, #TAB$)      DeclaredFile$ = "<file name=" + #DOUBLEQUOTE$ + FullAddressToRelativeAddress(FileName$, ProjectAddress$) + #DOUBLEQUOTE$ + ">"      If FindString(ProjectDescr$, DeclaredFile$) = 0        fIndex + 1        ProjectDescr$ + "    " + DeclaredFile$ + #CR$        ProjectDescr$ + "      <config load=['']" + Str(PBFile) + "[''] scan=['']" + Str(PBFile) + "[''] panel=['']1[''] warn=['']" + Str(PBFile) + "[''] lastopen=['']" + Str(LastOpen) + "[''] sortindex=['']" + Str(fIndex) + "[''] panelstate=['']['']/>" + #CR$        ProjectDescr$ + "      <fingerprint md5=['']" + LCase(FileFingerprint(FileName$, #PB_Cipher_MD5)) + "['']/>" + #CR$        ProjectDescr$ + "    </file>" + #CR$      EndIf    EndIf  Until LineC$ = ""  ;  If EndOfSection = 0    ProjectDescr$ + "  </section>" + #CR$  Else    ProjectDescr$ + EndOfDescr$  EndIf  ;  ProcedureReturn ProjectDescr$  ;EndProcedure;Procedure.s DelFilesFromProject(ProjectDescr$, ListOfFiles$)  ;  ; Explore the variable 'ListOfFiles$' and erase its files  ; from the project described in 'ProjectDescr$'.  ;  Protected PosInFileList, LineC$, FileName$, PosInDescr, mPosInDescr, pf  ;  PosInFileList = 0  Repeat    PosInFileList + 1    LineC$ = StringField(ListOfFiles$, PosInFileList, #CR$)    If LineC$      FileName$ = StringField(LineC$, 1, #TAB$)      PosInDescr = FindString(ProjectDescr$, GetFilePart(FileName$) + #DOUBLEQUOTE$ + ">")      If PosInDescr        mPosInDescr = PosInDescr        FastFindPrecReturn(ProjectDescr$, PosInDescr)        If FindString(FastMid(ProjectDescr$, PosInDescr, mPosInDescr - PosInDescr), "<file")          pf = FindString(ProjectDescr$, "</file>", PosInDescr)          If pf            pf = FindString(ProjectDescr$, #CR$, pf)            If pf              ProjectDescr$ = FastLeft(ProjectDescr$, PosInDescr) + FastMid(ProjectDescr$, pf + 1)            EndIf          EndIf        EndIf      EndIf    EndIf  Until LineC$ = ""  ;  ProcedureReturn ProjectDescr$  ;EndProcedure;Procedure.s CompareTwoFileLists(ListOfFiles1$, ListOfFiles2$)  ;  Protected LineC$, FileName$, ListOfMissingFiles$  Protected PosInFileList = 0  ;  Repeat    PosInFileList + 1    LineC$ = StringField(ListOfFiles1$, PosInFileList, #CR$)    If LineC$      FileName$ = StringField(LineC$, 1, #TAB$)      If FindString(ListOfFiles2$, FileName$) = 0        ListOfMissingFiles$ + FileName$ + #CR$      EndIf    EndIf  Until LineC$ = ""  ProcedureReturn ListOfMissingFiles$EndProcedure;Procedure.s ChooseProjectCreation()  ;  ; Show a dialog asking the user details about the project creation.  ;  Protected ChooseProjectCreationWdw, GMess, Btn_Manual, Btn_Cancel, Btn_Create  Protected ReturnValue$, OX, OY, GadgetList$  Protected WWidth = 500  Protected WHeight = 100  Protected ParentWindowID = ComputeWinOrigins(@OX, @OY, WWidth, WHeight, GPBBGadgets\PBBWindow)  ;  DisablePBBWindow()  ChooseProjectCreationWdw = OpenWindow(#PB_Any, OX, OY, WWidth, WHeight, GetTextFromCatalogPB("Attention"), #PB_Window_SystemMenu, ParentWindowID)  If ChooseProjectCreationWdw    ApplyDarkModeToWindow(ChooseProjectCreationWdw)    StickyWindow(ChooseProjectCreationWdw, 1)    GMess = EditorGadget(#PB_Any, 5, 5, 490, 60, #PB_Editor_ReadOnly)    GadgetList$ + Str(GMess) + ","    SendMessage_(GadgetID(GMess), #EM_SETTARGETDEVICE, #Null, 0); <<--- Automatic line break.    SendMessage_(GadgetID(GMess), #EM_LIMITTEXT, -1, 0)         ;       Set unlimited content size.    SendMessage_(GadgetID(GMess), #EM_SETTEXTMODE, #TM_RICHTEXT, 0) ;   Enable rich text mode for EditorGadget.    Protected paraFormat.PARAFORMAT2    paraFormat\cbSize = SizeOf(PARAFORMAT2)    paraFormat\dwMask = #PFM_ALIGNMENT    paraFormat\wAlignment = #PFA_CENTER    SendMessage_(GadgetID(GMess), #EM_SETPARAFORMAT, #SCF_SELECTION, @paraFormat) ; Center text.    AddGadgetItem(GMess, -1, GetTextFromCatalogPB("NoProjectFound"))        Btn_Manual = ButtonGadget(#PB_Any, 5, 70, 210, 25,   GetTextFromCatalogPB("LookForProjectManually"))    GadgetList$ + Str(Btn_Manual) + ","    Btn_Cancel = ButtonGadget(#PB_Any, 220, 70, 100, 25, GetTextFromCatalogPB("Cancel"))    GadgetList$ + Str(Btn_Cancel) + ","    Btn_Create = ButtonGadget(#PB_Any, 325, 70, 170, 25, GetTextFromCatalogPB("CreateNewProject"))    GadgetList$ + Str(Btn_Create) + ","    SetFontAndGadgetsColors(ChooseProjectCreationWdw, InterfaceColorPresets(), GadgetList$)    ; Event Loop    Repeat      If EventWindow() <> ChooseProjectCreationWdw        SetActiveWindow(ChooseProjectCreationWdw)      EndIf      Select WaitWindowEvent()        Case #PB_Event_CloseWindow          Break          ;        ; Event Gadget        Case #PB_Event_Gadget          Select EventGadget()            Case Btn_Manual   ; Choose manually the project.              ReturnValue$ = "Manual"              Break            Case Btn_Cancel   ; Cancel the project's creation.              ReturnValue$ = "Cancel"              Break            Case Btn_Create   ; Create a new project.              ReturnValue$ = "Create"              Break          EndSelect        ;      EndSelect    ForEver  EndIf  CloseWindow(ChooseProjectCreationWdw)  EnablePBBWindow()  ProcedureReturn ReturnValue$EndProcedure;Procedure CreateUpdateProject()  ;  ; Values found into 'IDEDescr$':  Protected Exec$, Compiler$, optimizer, asm, thread, xpskin, admin  Protected dpiaware, dllprotection, onerror, pdebug, Icon$  Protected Debugger$, Warnings$, CompileCount$, BuildCount$  Protected CommandLine$, CurrentDirectory$, SubSystem$  Protected LinkerOptions$, ExecutableFormat$, CPU$, InfosList  Protected VersionField$, Field$, ResourcesList, Resource$  Protected ConstList, Const$, WTitle$  ;  ; Other variables  Protected ProjectAddress$, Choice$, WasOpen, ListProjectsFiles$  Protected ProjectIsModified, MissingFile$, Message$, pd, pf  Protected *Content.String, IDEPos, ProjectDescr$, IDEDescr$  ;  If Left(GetFilePart(PBBFicPrincipalPB$), Len("PureBasic_TempFile")) = "PureBasic_TempFile"    AlertInPBBWindow(GetTextFromCatalogPB("NotForTempFile"))    ProcedureReturn #False  EndIf  ;  UseMD5Fingerprint()  If PBBFicPrincipalPB$ ; 'PBBFicPrincipalPB$' is a Global variable.    ;    *Content = GetPointedCodeFromFile(PBBFicPrincipalPB$)    IDEPos = FindIDENotations(*Content)    ; IDEPos contains now the position of the IDE notations    ; inside the file 'PBBFicPrincipalPB$'.    ; Extract notations:    IDEDescr$ = FastMid(*Content\s, IDEPos)    ;    ; ------------------------------------------------------------    ;    ; Look for an existing project or create one.    ;    pd = FindString(IDEDescr$, "Project = ")    If pd      pd + Len("Project = ")      pf = FindString(IDEDescr$, #CR$, pd)      If pf = 0 : pf = Len(IDEDescr$) + 1 : EndIf      ProjectAddress$ = FastMid(IDEDescr$, pd, pf - pd)    EndIf    ;    If ProjectAddress$ = ""      If FileSize(ChangeFileExtension(PBBFicPrincipalPB$, "pbp")) > 1        ProjectAddress$ = ChangeFileExtension(PBBFicPrincipalPB$, "pbp")      EndIf    EndIf    ;    If ProjectAddress$ = ""      Choice$ = ChooseProjectCreation()      If Choice$ = "Manual"        DisablePBBWindow()        ProjectAddress$ = OpenFileRequester(GetTextFromCatalogPB("LookForProjectManually"), "", "PB Project|*.pbp", 0)        EnablePBBWindow()      ElseIf Choice$ = "Create"        ProjectAddress$ = ChangeFileExtension(PBBFicPrincipalPB$, "pbp")        ProjectAddress$ = SaveFileRequester(GetTextFromCatalogPB("CreateNewProject"), ProjectAddress$, "PB Project|*.pbp", 0)      EndIf    EndIf    ;    If ProjectAddress$ = ""      ProcedureReturn #False    EndIf    ;    If GetPBPOpenFile(PureBasicProgAddr$) = ProjectAddress$      WasOpen = 1      AlertInPBBWindow(GetTextFromCatalogPB("ProjectAllreadyOpen"))    EndIf    If GetPBPOpenFile(PureBasicProgAddr$) = ProjectAddress$      ProcedureReturn #False    EndIf    ;    ; ------------------------------------------------------------    ;    If FileSize(ProjectAddress$) > 1      ;      ; A project allready exists.      ; Udpate its file list with the authorisation of user.      ProjectDescr$ = FileToText(ProjectAddress$)      ListProjectsFiles$ = ListProjectsFiles(ProjectAddress$)      ProjectIsModified = 0      ;      MissingFile$ = CompareTwoFileLists(PBBListOfFiles$, ListProjectsFiles$)      If MissingFile$        Message$ = GetTextFromCatalogPB("WouldYouAdd") + #CR$ + #CR$ + GetTextFromCatalogPB("IncludedFilesIntro") + #CR$ + MissingFile$        WTitle$ = GetTextFromCatalogPB("IncludedFilesIntro")        If AlertInPBBWindow(Message$, WTitle$, 1, 0, 0, 0, "", #AW_YesOrNo_YesByDefault) = #PB_MessageRequester_Yes          ProjectDescr$ = CompleteProjectFileList(ProjectDescr$, MissingFile$, ProjectAddress$, 1)          ProjectIsModified = 1        EndIf      EndIf      ;      MissingFile$ = CompareTwoFileLists(PBBListOfBinaries$, ListProjectsFiles$)      If MissingFile$        Message$ = GetTextFromCatalogPB("WouldYouAdd") + #CR$ + #CR$ + GetTextFromCatalogPB("IncludedBinaries") + #CR$ + MissingFile$        WTitle$ = GetTextFromCatalogPB("IncludedBinaries")        If AlertInPBBWindow(Message$, WTitle$, 1, 0, 0, 0, "", #AW_YesOrNo_YesByDefault) = #PB_MessageRequester_Yes          ProjectDescr$ = CompleteProjectFileList(ProjectDescr$, MissingFile$, ProjectAddress$, 1)          ProjectIsModified = 1        EndIf      EndIf      ;      MissingFile$ = CompareTwoFileLists(ListProjectsFiles$, PBBListOfFiles$ + PBBListOfBinaries$)      If MissingFile$        Message$ = GetTextFromCatalogPB("WouldYouDel") + #CR$ + #CR$ + GetTextFromCatalogPB("FilesToDelete") + #CR$ + MissingFile$        WTitle$ = GetTextFromCatalogPB("FilesToDelete")        If AlertInPBBWindow(Message$, WTitle$, 1, 0, 0, 0, "", #AW_YesOrNo_YesByDefault) = #PB_MessageRequester_Yes          ProjectDescr$ = DelFilesFromProject(ProjectDescr$, MissingFile$)          ProjectIsModified = 1        EndIf      EndIf    Else      ; ------------------------------------------------------------      ;      ; Create a new project from the files included into sources.      ;      ProjectIsModified = 1      ;      ; Build the project header part:      ProjectDescr$ = "<?xml version=['']1.0[''] encoding=['']UTF-8['']?>" + #CR$ + #CR$      ; 'http://www.purebasic.com/namespace' is absolutely necessary for the projet      ; being recognized by the IDE:      ProjectDescr$ + "<project xmlns=['']http://www.purebasic.com/namespace[''] version=['']1.0[''] creator=['']PBBrowser['']>" + #CR$      ProjectDescr$ + "  <section name=['']config['']>" + #CR$      ProjectDescr$ + "    <options closefiles=['']0[''] openmode=['']0[''] name=['']" + FilePartSsExt(PBBFicPrincipalPB$) + "['']/>" + #CR$      ProjectDescr$ + "  </section>" + #CR$      ProjectDescr$ + "  <section name=['']data['']>" + #CR$      ProjectDescr$ + "    <explorer view=['']" + GetPathPart(PBBFicPrincipalPB$) + "[''] pattern=['']0['']/>" + #CR$      ProjectDescr$ + "    <log show=['']1['']/>" + #CR$      ProjectDescr$ + "    <lastopen date=['']" + FormatDate("%yyyy-%mm-%dd %hh:%ii", Date()) + "[''] user=['']" + GetUserName() + "[''] host=['']" + GetComputerName() + "['']/>" + #CR$      ProjectDescr$ + "  </section>" + #CR$      ; Add the main file to the project file list:      ProjectDescr$ = CompleteProjectFileList(ProjectDescr$, PBBFicPrincipalPB$, ProjectAddress$, 1, 1)      ; Explore the Global variable 'PBBListOfFiles$' to complete the file list:      ProjectDescr$ = CompleteProjectFileList(ProjectDescr$, PBBListOfFiles$, ProjectAddress$, 1)      ; Explore the Global variable 'PBBListOfBinaries$' to complete the file list:      ProjectDescr$ = CompleteProjectFileList(ProjectDescr$, PBBListOfBinaries$, ProjectAddress$, 0)      ;      ProjectDescr$ + "  <section name=['']targets['']>" + #CR$      ProjectDescr$ + "    <target name=['']" + GetTextFromCatalogPB("DefaultTarget") + "[''] enabled=['']1[''] default=['']1['']>" + #CR$      ProjectDescr$ + "      <inputfile value=['']" + FullAddressToRelativeAddress(PBBFicPrincipalPB$, ProjectAddress$) + "['']/>" + #CR$      ;      ; Examine IDEDescr$ (options registred by the IDE at the end      ; of the main .pb file (PBBFicPrincipalPB$)),      ; and duplicate values into the project options:      ;      pd = FindString(IDEDescr$, "Executable = ")      If pd        pd + Len("Executable = ")        pf = FindString(IDEDescr$, #CR$, pd)        If pf = 0 : pf = Len(IDEDescr$) + 1 : EndIf        Exec$ = FastMid(IDEDescr$, pd, pf - pd)      EndIf      If Exec$ = "" : Exec$ = ChangeFileExtension(PBBFicPrincipalPB$, ".exe") : EndIf      ;      ProjectDescr$ + "      <outputfile value=['']" + FullAddressToRelativeAddress(Exec$, ProjectAddress$) + "['']/>" + #CR$      ;      pd = FindString(IDEDescr$, "CommandLine = ")      If pd        pd + Len("CommandLine = ")        pf = FindString(IDEDescr$, #CR$, pd)        If pf = 0 : pf = Len(IDEDescr$) + 1 : EndIf        CommandLine$ = FastMid(IDEDescr$, pd, pf - pd)        ProjectDescr$ + "      <commandline value=['']" + CommandLine$ + "['']/>" + #CR$      EndIf      ;      pd = FindString(IDEDescr$, "CurrentDirectory = ")      If pd        pd + Len("CurrentDirectory = ")        pf = FindString(IDEDescr$, #CR$, pd)        If pf = 0 : pf = Len(IDEDescr$) + 1 : EndIf        CurrentDirectory$ = FastMid(IDEDescr$, pd, pf - pd)        ProjectDescr$ + "      <directory value=['']" + CurrentDirectory$ + "['']/>" + #CR$      EndIf      ;      pd = FindString(IDEDescr$, "Compiler = ")      If pd        pd + Len("Compiler = ")        pf = FindString(IDEDescr$, #CR$, pd)        If pf = 0 : pf = Len(IDEDescr$) + 1 : EndIf        Compiler$ = FastMid(IDEDescr$, pd, pf - pd)        ProjectDescr$ + "      <compiler version=['']" + Compiler$ + "['']/>" + #CR$      EndIf      ;      If FindString(IDEDescr$, "Optimizer")     : optimizer = 1 : EndIf      If FindString(IDEDescr$, "EnableAsm")     : asm = 1 : EndIf      If FindString(IDEDescr$, "EnableThread")  : thread = 1 : EndIf      If FindString(IDEDescr$, "EnableXP")      : xpskin = 1 : EndIf      If FindString(IDEDescr$, "EnableAdmin")   : admin = 1 : EndIf      If FindString(IDEDescr$, "DPIAware")      : dpiaware = 1 : EndIf      If FindString(IDEDescr$, "DllProtection") : dllprotection = 1 : EndIf      If FindString(IDEDescr$, "EnableOnError") : onerror = 1 : EndIf      If FindString(IDEDescr$, "DisableDebugger") = 0 : pdebug = 1 : EndIf      ProjectDescr$ + "      <options asm=['']" + Str(asm) + "[''] thread=['']" + Str(thread) + "[''] xpskin=['']" + Str(xpskin) + "[''] admin=['']" + Str(admin) + "[''] dpiaware=['']" + Str(dpiaware) + "[''] dllprotection=['']" + Str(dllprotection) + "[''] debug=['']" + Str(pdebug) + "[''] onerror=['']" + Str(onerror) + "[''] optimizer=['']" + Str(optimizer) + "['']/>" + #CR$      ;      If FindString(IDEDescr$, "EnablePurifier")        ProjectDescr$ + "      <purifier enable=['']1['']/>" + #CR$      EndIf      If FindString(IDEDescr$, "CompileSourceDirectory")        ProjectDescr$ + "      <temporaryexe value=['']source['']/>" + #CR$      EndIf      ;      pd = FindString(IDEDescr$, "SubSystem = ")      If pd        pd + Len("SubSystem = ")        pf = FindString(IDEDescr$, #CR$, pd)        If pf = 0 : pf = Len(IDEDescr$) + 1 : EndIf        SubSystem$ = FastMid(IDEDescr$, pd, pf - pd)        ProjectDescr$ + "      <subsystem value=['']" + SubSystem$ + "['']/>" + #CR$      EndIf      ;      pd = FindString(IDEDescr$, "LinkerOptions = ")      If pd        pd + Len("LinkerOptions = ")        pf = FindString(IDEDescr$, #CR$, pd)        If pf = 0 : pf = Len(IDEDescr$) + 1 : EndIf        LinkerOptions$ = FastMid(IDEDescr$, pd, pf - pd)        ProjectDescr$ + "      <linker value=['']" + LinkerOptions$ + "['']/>" + #CR$      EndIf      ;      pd = FindString(IDEDescr$, "ExecutableFormat = ")      If pd        pd + Len("ExecutableFormat = ")        pf = FindString(IDEDescr$, #CR$, pd)        If pf = 0 : pf = Len(IDEDescr$) + 1 : EndIf        ExecutableFormat$ = "exe=['']" + LCase(FastMid(IDEDescr$, pd, pf - pd)) + "['']"      EndIf      pd = FindString(IDEDescr$, "CPU = ")      If pd        pd + Len("CPU = ")        pf = FindString(IDEDescr$, #CR$, pd)        If pf = 0 : pf = Len(IDEDescr$) + 1 : EndIf        CPU$ = "cpu=['']" + FastMid(IDEDescr$, pd, pf - pd) + "['']"        If ExecutableFormat$ : CPU$ = " " + CPU$ : EndIf      EndIf      If ExecutableFormat$ Or CPU$        ProjectDescr$ + "      <format " + ExecutableFormat$ + CPU$ + "/>" + #CR$      EndIf      ;      InfosList = 0      If FindString(IDEDescr$, "IncludeVersionInfo")        ProjectDescr$ + "      <versioninfo enable=['']1['']>" + #CR$        InfosList = 1      EndIf      pd = 0      Repeat        pd = FindString(IDEDescr$, "VersionField", pd + 1)        If pd          pf = FindString(IDEDescr$, "=", pd)          If pf = 0 : pf = Len(IDEDescr$) + 1 : EndIf          VersionField$ = ReplaceString(LCase(Trim(FastMid(IDEDescr$, pd, pf - pd))), "version", "")          pd = pf + 2          pf = FindString(IDEDescr$, #CR$, pd)          If pf = 0 : pf = Len(IDEDescr$) + 1 : EndIf          Field$ = FastMid(IDEDescr$, pd, pf - pd)          If InfosList = 0            InfosList = 1            ProjectDescr$ + "      <versioninfo enable=['']0['']>" + #CR$          EndIf          ProjectDescr$ + "        <" + VersionField$ + " value=['']" + Field$ + "['']/>" + #CR$        EndIf      Until pd = 0      If InfosList        ProjectDescr$ + "      </versioninfo>" + #CR$      EndIf      ;      pd = 0      ResourcesList = 0      Repeat        pd = FindString(IDEDescr$, "AddResource = ", pd + 1)        If pd          pd + Len("AddResource = ")          pf = FindString(IDEDescr$, #CR$, pd)          If pf = 0 : pf = Len(IDEDescr$) + 1 : EndIf          Resource$ = FastMid(IDEDescr$, pd, pf - pd)          If ResourcesList = 0            ResourcesList = 1            ProjectDescr$ + "      <resources>" + #CR$          EndIf          ProjectDescr$ + "        <resource value=['']" + Resource$ + "['']/>" + #CR$        EndIf      Until pd = 0      If ResourcesList        ProjectDescr$ + "      </resources>" + #CR$      EndIf      ;      pd = 0      ConstList = 0      Repeat        pd = FindString(IDEDescr$, "Constant = ", pd + 1)        If pd          pd + Len("Constant = ")          pf = FindString(IDEDescr$, #CR$, pd)          If pf = 0 : pf = Len(IDEDescr$) + 1 : EndIf          Const$ = FastMid(IDEDescr$, pd, pf - pd)          If ConstList = 0            ConstList = 1            ProjectDescr$ + "      <constants>" + #CR$          EndIf          ProjectDescr$ + "        <constant value=['']" + Const$ + "[''] enable=['']1['']/>" + #CR$        EndIf      Until pd = 0      If ConstList        ProjectDescr$ + "      </constants>" + #CR$      EndIf      ;      pd = FindString(IDEDescr$, "UseIcon = ")      If pd        pd + Len("UseIcon = ")        pf = FindString(IDEDescr$, #CR$, pd)        If pf = 0 : pf = Len(IDEDescr$) + 1 : EndIf        Icon$ = RelativeAddressToFullAddress(FastMid(IDEDescr$, pd, pf - pd), PBBFicPrincipalPB$)        ProjectDescr$ + "      <icon enable=['']1['']>" + Icon$ + "</icon>" + #CR$      EndIf      ;      pd = FindString(IDEDescr$, "Debugger = ")      If pd        pd + Len("Debugger = ")        pf = FindString(IDEDescr$, #CR$, pd)        If pf = 0 : pf = Len(IDEDescr$) + 1 : EndIf        Debugger$ = FastMid(IDEDescr$, pd, pf - pd)        ProjectDescr$ + "      <debugger custom=['']1[''] type=['']" + LCase(Debugger$) + "['']/>" + #CR$      EndIf      ;      pd = FindString(IDEDescr$, "Warnings = ")      If pd        pd + Len("Warnings = ")        pf = FindString(IDEDescr$, #CR$, pd)        If pf = 0 : pf = Len(IDEDescr$) + 1 : EndIf        Warnings$ = FastMid(IDEDescr$, pd, pf - pd)        ProjectDescr$ + "      <warnings custom=['']1[''] type=['']" + LCase(Warnings$) + "['']/>" + #CR$      EndIf      ;      pd = FindString(IDEDescr$, "EnableCompileCount = ")      If pd        pd + Len("EnableCompileCount = ")        pf = FindString(IDEDescr$, #CR$, pd)        If pf = 0 : pf = Len(IDEDescr$) + 1 : EndIf        CompileCount$ = FastMid(IDEDescr$, pd, pf - pd)        ProjectDescr$ + "      <compilecount enable=['']1[''] value=['']" + CompileCount$ + "['']/>" + #CR$      EndIf      ;      pd = FindString(IDEDescr$, "EnableBuildCount = ")      If pd        pd + Len("EnableBuildCount = ")        pf = FindString(IDEDescr$, #CR$, pd)        If pf = 0 : pf = Len(IDEDescr$) + 1 : EndIf        BuildCount$ = FastMid(IDEDescr$, pd, pf - pd)        ProjectDescr$ + "      <buildcount enable=['']1[''] value=['']" + BuildCount$ + "['']/>" + #CR$      EndIf      ;      If FindString(IDEDescr$, "EnableExeConstant")        ProjectDescr$ + "      <execonstant enable=['']1['']/>" + #CR$      EndIf      ;      ProjectDescr$ + "    </target>" + #CR$      ProjectDescr$ + "  </section>" + #CR$      ;      ProjectDescr$ + "</project>" + #CR$      ;    EndIf    ;    If ProjectIsModified      ProjectDescr$ = ReplaceDoubleSimpleQuoteByDoubleQuote(ProjectDescr$)      ;      TexteDansFichier(ProjectAddress$, ProjectDescr$)    EndIf    ;    If ProjectIsModified Or WasOpen      ;      Message$ = GetTextFromCatalogPB("WouldYouOpenProject")      If WasOpen And ProjectIsModified = 0        Message$ = GetTextFromCatalogPB("ProjectNotModified") + #CR$ + #CR$ + Message$      EndIf      If AlertInPBBWindow(Message$, "", 1, 0, 0, 0, "", #AW_YesOrNo_YesByDefault) = #PB_MessageRequester_Yes        RunProgram(#DOUBLEQUOTE$ + PureBasicProgAddr$ + #DOUBLEQUOTE$, #DOUBLEQUOTE$ + ProjectAddress$ + #DOUBLEQUOTE$, GetPathPart(ProjectAddress$))      EndIf    Else      AlertInPBBWindow(GetTextFromCatalogPB("ProjectNotModified"))    EndIf  EndIfEndProcedure;NCommand\CommandName$ = "InCatalog:CreateUpdateProjectTitle"NCommand\Commandtype = 1NCommand\CommandDontShow = 0NCommand\CommandDescription$  = "InCatalog:CreateUpdateProjectEx"NCommand\CommandSimpleProcAddr = @CreateUpdateProject()AddCommandToList(NCommand);Procedure ExportPBBSrcFile()  RunProgram("https://www.editions-humanis.com/downloads/PureBasic/ZapmanDowloads_EN.htm")EndProcedure;NCommand\CommandName$ = "InCatalog:ExportSourceCodeTitle"NCommand\Commandtype = 1NCommand\CommandDontShow = 1NCommand\CommandDescription$  = "InCatalog:ExportSourceCodeEx"NCommand\CommandSimpleProcAddr = @ExportPBBSrcFile()AddCommandToList(NCommand);Procedure EraseCommentsOneFile(FileName$, WGadget)  ;  ; Erase comments for 'FileName$'  ;  Protected *CodeContent.String  *CodeContent = GetPointedCodeFromFile(FileName$)    Debug Left(*CodeContent\s,500)  ;  If IsGadget(WGadget)    txg$ + GetGadgetText(WGadget)    If Right(txg$, 1) <> #CR$      txg$ + #CR$    EndIf    txg$ + "."    SetGadgetText(WGadget, txg$)  EndIf  ;  DeleteCommentsAndSpacesFromPBCode(*CodeContent, #True, #True)  ; Save with '-1' as third parameter, to ensure that the saving format is  ; the same as original format.  Debug Left(*CodeContent\s,500)  TexteDansFichier(FileName$, *CodeContent\s, -1, 0, 1)  ;EndProcedure;Procedure EraseComments()  ;  ; Erase comments for all the files of the project  ;  Shared BackgroundTasksCompletion  ;  Protected Res, PosInFileList, WGadget, LineC$, FileName$  Protected Modified = 0  ;  If Left(GetFilePart(PBBFicPrincipalPB$), Len("PureBasic_TempFile")) = "PureBasic_TempFile"    AlertInPBBWindow(GetTextFromCatalogPB("NotForTempFile"))    ProcedureReturn #False  EndIf  ;  DisablePBBWindow()  Res = AlertInPBBWindow(GetTextFromCatalogPB("MakeACopy"), "", 1, 0, 0, 0, "", #AW_OKOrCancel_OKByDefault)  If Res = #PB_MessageRequester_Yes    PosInFileList = 0    ;    WGadget = OpenWaitWindow(GPBBGadgets\PBBWindow, "")    ;    ; Loop through the list of files contained in PBBListOfFiles$    Repeat       PosInFileList + 1      LineC$ = StringField(PBBListOfFiles$, PosInFileList, #CR$)      If LineC$        ; Extract the file name:        FileName$ = StringField(LineC$, 1, #TAB$)        If FileSize(FileName$) > 1          ; Display the waiting window          If IsGadget(WGadget)            SetGadgetText(WGadget, GetTextFromCatalogPB("CosmeticFileTransformerTitle") + #CR$ + GetFilePart(FileName$) + ".")          EndIf          If EraseCommentsOneFile(FileName$, WGadget)            Modified = 1          EndIf        EndIf      EndIf    Until LineC$ = ""    If IsGadget(WGadget)      DestroyParentWindow(WGadget)    EndIf    AlertInPBBWindow(GetTextFromCatalogPB("WorkDone"))    ;    If Modified      ; Many files may have been transformed.      ; Therefore, restart a full exploration.      BackgroundTasksCompletion = #BackgroundTasksMustRestart    EndIf  EndIf  EnablePBBWindow()EndProcedure;NCommand\CommandName$ = "InCatalog:EraseCommentsTitle"NCommand\Commandtype = 1NCommand\CommandDontShow = 1NCommand\CommandDescription$  = "InCatalog:EraseCommentsEx"NCommand\CommandSimpleProcAddr = @EraseComments()AddCommandToList(NCommand); IDE Options = PureBasic 6.20 (Windows - x64); CursorPosition = 1101; FirstLine = 313; Folding = D5-; EnableXP; DPIAware; UseMainFile = ..\..\PBBrowser.pb