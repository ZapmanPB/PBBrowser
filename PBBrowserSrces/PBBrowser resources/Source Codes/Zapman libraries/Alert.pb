;; ********************************************************************;;                           'Alert' library;;          An alternative to PureBasic's 'MessageRequester'.;                          For Windows only.;;       Examples usages can be found at the end of this file.;; ********************************************************************;Procedure.i IsMemoryValid(*ptr)  Protected result.i = #False  Protected mbi.MEMORY_BASIC_INFORMATION    If VirtualQuery_(*ptr, @mbi, SizeOf(MEMORY_BASIC_INFORMATION))    If mbi\State = #MEM_COMMIT And (mbi\Protect & (#PAGE_NOACCESS | #PAGE_GUARD)) = 0      result = #True    EndIf  EndIf    ProcedureReturn resultEndProcedure;Procedure.s TextError()  ;  ; When an error occure, this fonction retrieve the text of it  ; Quand une erreur survient, cette fonction récupère le text correspondant  ;  Protected  errorNb, MLength, *mem, length, e$, ErrorN, MHandle  ;  errorNb = GetLastError_()  If errorNb    MLength = 500    *mem = AllocateMemory(MLength)    length = FormatMessage_(#FORMAT_MESSAGE_FROM_SYSTEM, #Null, errorNb, 0, *mem, MLength, #Null)    If length > 1      e$ = "Erreur N° " + Str(errorNb) + " : " + PeekS(*mem, length - 2)    Else      #ERROR_INTERNET_EXTENDED_ERROR = 12003      If errorNb = #ERROR_INTERNET_EXTENDED_ERROR        ErrorN = 0        length = InternetGetLastResponseInfo_(@ErrorN, *mem, @MLength)        If length = 0          length = FormatMessage_(#FORMAT_MESSAGE_FROM_SYSTEM, #Null, GetLastError_(), 0, *mem, 255, #Null)        EndIf         e$  = "Erreur N° " + Str(errorNb) + " : " + PeekS(*mem)      Else        If errorNb > 11999 And errorNb < 13000          #FORMAT_MESSAGE_FROM_HMODULE = $00000800          MHandle = GetModuleHandle_("wininet.dll")          length = FormatMessage_(#FORMAT_MESSAGE_FROM_HMODULE, MHandle, errorNb, 0, *mem, MLength, #Null)          If length > 1            e$ = "Erreur N° " + Str(errorNb) + " : " + PeekS(*mem, length - 2)          Else            e$ = "Erreur N° " + Str(errorNb)          EndIf        Else          e$ = "Erreur N° " + Str(errorNb)        EndIf      EndIf     EndIf    FreeMemory(*mem)    ProcedureReturn e$  Else    ProcedureReturn ""  EndIfEndProcedure;Procedure ClearKeyboardBuffer(WindowID = 0)  If IsWindow(WindowID)    While WindowEvent() : Wend  EndIf  Protected msg.MSG  ; Boucle pour traiter tous les messages clavier en attente  While PeekMessage_(@msg, 0, #WM_KEYFIRST, #WM_KEYLAST, #PM_REMOVE)    ; On ne fait rien, on vide simplement les messages clavier du buffer  Wend  ;  Protected Dim keystate.b(256)  Protected i  ; Récupérer l'état actuel du clavier  GetKeyboardState_(@keystate())    ; Boucle pour vérifier toutes les touches  For i = 0 To 255    If keystate(i) & $80      ; Lire l'état de chaque touche pour vider le buffer      While GetAsyncKeyState_(i) & $8000      Wend    EndIf  Next iEndProcedure;Procedure.l GetTextSurfPix(gadget, Text$, *Width.Double, *Height.Double)  ; Renvoie les dimensions en pixels d'un texte quand on l'affiche dans le gadget "gadget"  Protected hDC, hFont, lpSize.SIZE  ;  If IsGadget(gadget)    hDC = GetDC_(GadgetID(gadget))    hFont = GetGadgetFont(gadget)    If hFont And hDC      SelectObject_(hDC, hFont)    EndIf    If GetTextExtentPoint32_(hDC, Text$, Len(Text$), lpSize.SIZE)      *Width\d  = lpSize\cx      *Height\d = lpSize\cy      ProcedureReturn    EndIf    ReleaseDC_(GadgetID(gadget), hDC)  EndIf  ; En cas d'échec, on retourne des valeurs arbitraires.  *Width\d  = 1000  *Height\d = 3000EndProcedure;Procedure.l GetTextWidthPix(gadget, Text$)  Protected TWidth.d, THeight.d  GetTextSurfPix(gadget, Text$, @TWidth.d, @THeight.d)  ProcedureReturn TWidthEndProcedure;Procedure.f GetMonitorDPI(Window.i = 0)  ; Récupère l'échelle d'affichage sur le moniteur  Protected hlib.i, *api, *proc, hmonitor.i, dpi_x.i, dpi_y, Result.f, wid  ProcedureReturn 1  hlib = LoadLibrary_("shcore.dll")  *api = Ascii("SetProcessDpiAwareness")  If *api    *proc = GetProcAddress_(hlib, *api)    FreeMemory(*api)    If *proc      hmonitor = CallCFunctionFast(*proc, 2) ; <- make process (per monitor) dpi aware if it isnt      If hmonitor = #S_OK Or hmonitor = #E_ACCESSDENIED        *api = Ascii("GetDpiForMonitor")        If *api          *proc = GetProcAddress_(hlib, *api)          FreeMemory(*api)          If *proc            If Window              wid = WindowID(Window)            EndIf            hmonitor = MonitorFromWindow_(wid, #MONITOR_DEFAULTTONEAREST)            If CallFunctionFast(*proc, hmonitor, #Null, @dpi_x, @dpi_y) = #S_OK              Result.f = dpi_x / 96              ProcedureReturn Result            EndIf          EndIf        EndIf      EndIf    EndIf  EndIf  ProcedureReturn #FalseEndProcedure;Procedure.l RE_StreamStringOutCallback(*dwCookiePtr, pbBuff, cb, pcb)  Protected result, StrPtr, ms  result = 0  If *dwCookiePtr ; Here, *dwCookiePtr is a pointer to a pointer    ;               along time, *dwCookiePtr will allways keep the same value (StrPtr pointer adress)    ;               while the value of StrPtr can change at each iteration.    StrPtr.i = PeekI(*dwCookiePtr)    If StrPtr = 0      StrPtr = AllocateMemory(cb)      CopyMemory(pbBuff, StrPtr, cb)    Else      ms = MemorySize(StrPtr)      StrPtr = ReAllocateMemory(StrPtr, ms + cb)      CopyMemory(pbBuff, StrPtr + ms, cb)    EndIf    PokeI(*dwCookiePtr, StrPtr)    ;  EndIf  PokeL(pcb, cb)  If cb = 0    result = 1  EndIf  ProcedureReturn resultEndProcedure;Procedure.s RE_GetContent_RTF(Gadget, format = #SF_RTF, UseDirectID = 0)  ; Get content of a RichEdit Gadget  ;  ; Resulting text will be RTF formated if 'format' parameter is undefined.  ; Resulting text will be simple text formated if 'format' parameter is set to zero,  ;     (in that case, resulting text is UTF8 encoded).  ; Resulting text will get whole content of the RichEdit Gadget  ;     or only selected content if 'format' is set To #SF_TEXT|#SFF_SELECTION Or #SF_RTF|#SFF_SELECTION  ;  ;'format' parameter can also be a combination of #SF_RTF and #SF_TEXT with some of the following values:  ; #SFF_PLAINRTF -- If specified, the rich edit control streams out only the keywords common To all languages, ignoring language-specific keywords. If Not specified, the rich edit control streams out all keywords. You can combine this flag With the SF_RTF Or SF_RTFNOOBJS flag.  ; #SFF_SELECTION -- If specified, the rich edit control streams out only the contents of the current selection. If Not specified, the control streams out the entire contents. You can combine this flag With any of Data format values.  ; #SF_UNICODE -- Microsoft Rich Edit 2.0 And later: Indicates Unicode text. You can combine this flag With the SF_TEXT flag.  ; #SF_USECODEPAGE -- Rich Edit 3.0 And later: Generates UTF-8 RTF As well As text using other code pages. The code page is set in the high word of wParam. For example, For UTF-8 RTF, set wParam To (CP_UTF8 << 16) | SF_USECODEPAGE | SF_RTF.  ;  Protected edstr.EDITSTREAM, StrPtr, Ghdl  Protected Str$ ; Return value  ;  #SF_USECODEPAGE   = $20  #CP_UTF8      = 65001  ;  If UseDirectID = 0    Ghdl = GadgetID(Gadget)  Else    Ghdl = Gadget  EndIf  ;  If format = 0 Or format & #SF_TEXT : format | (#CP_UTF8 << 16) | #SF_USECODEPAGE | #SF_TEXT : EndIf  ;  StrPtr = 0  edstr\dwCookie.i = @StrPtr ; Here, *dwCookie is a pointer to a pointer.  ;                            Along time, *dwCookie will allways keep the same value (StrPtr pointer adress)  ;                            while the value of StrPtr can change along iterations of RE_StreamStringOutCallback  edstr\pfnCallback = @RE_StreamStringOutCallback()  edstr\dwError = 0  SendMessage_(Ghdl, #EM_STREAMOUT, format, edstr)  If edstr\dwError    Str$ = ""    If StrPtr : FreeMemory(StrPtr) : EndIf  ElseIf StrPtr    Str$ = PeekS(StrPtr, MemorySize(StrPtr), #PB_UTF8 | #PB_ByteLength)    FreeMemory(StrPtr)  EndIf  ProcedureReturn Str$EndProcedure;Procedure.s RE_GetGadgetSelectedText(Gadget, format = #SFF_SELECTION | #SF_TEXT)  ; Get text content of a RichEdit Gadget formated in simple Text$ / UTF8  ProcedureReturn RE_GetContent_RTF(Gadget, format)EndProcedure;Procedure RE_SearchString(Gadget, SearchString$, MATCHCASE = 0, WHOLEWORD = 0, UP = 0, startPos = -2)  ; By Zapman  ;  ; Will search the string 'SearchString$' into the content of the RichEditGadget 'Gadget'  ; If the Gadget has a selected range of text, the search will be done after the position of the selection  ; (of before, if 'UP' is set to 1).  ; If a value different from '-2' is attributed to 'startpos", the search will be done after the startpos  ; (of before, if 'UP' is set to 1).  ;  ; Returned value is:  ; Position of SearchString$ into the content of the Gadget if string is found;  ; -2 if string is not found, but search have'nt been done on whole the Gadget content;  ; -1 if SearchString$ can't be found into the gagdet content.  ;  ;  If SearchString$ is found, the selection of the Gadget is changed to the position of found text  ;  Protected McpMin, McpMax, NUP, flg, Res  Protected text.FINDTEXT\lpstrText = @SearchString$  ;  If startPos <> -2 ; A start position is given for the search    text\chrg\cpMin = startPos    text\chrg\cpMax = startPos    SendMessage_(GadgetID(Gadget), #EM_EXSETSEL, 0, @text\chrg) ; set the cursor at the given position  EndIf  SendMessage_(GadgetID(Gadget), #EM_EXGETSEL, 0, @text\chrg) ; get the range of the selected text  If (text\chrg\cpMin <> text\chrg\cpMax)    ; Selected text range found, search from the end of it (or from the start, if UP = 1)    If UP = 0      text\chrg\cpMin = text\chrg\cpMax    Else      text\chrg\cpMax = text\chrg\cpMin    EndIf  EndIf  McpMin = text\chrg\cpMin   McpMax = text\chrg\cpMax  text\chrg\cpMax = -1 ; This must be set in all case for a successful search  ;set the search flags  If UP : NUP = 0 : Else : NUP = 1 : EndIf  flg = (MATCHCASE * #FR_MATCHCASE) | (WHOLEWORD * #FR_WHOLEWORD) | (NUP * #FR_DOWN)  Res = SendMessage_(GadgetID(Gadget), #EM_FINDTEXT, flg, @text)  If Res > -1 ; the searched text has been found!!    SendMessage_(GadgetID(Gadget), #EM_SETSEL, Res, Res + Len(SearchString$)) ; select found string into the Gadget  Else    ; If not found, is it possible to extend the search range?    ; If yes, return value will be -2    If UP = 0 And McpMin > 0 : Res = -2 : EndIf    If UP And McpMax <> -1 ; if McpMax was -1, we've yet search from end      text\chrg\cpMin = -1      text\chrg\cpMax = -1      SendMessage_(GadgetID(Gadget), #EM_EXSETSEL, 0, @text\chrg) ; go to the end      SendMessage_(GadgetID(Gadget), #EM_EXGETSEL, 0, @text\chrg) ; get end pos      If McpMax <> text\chrg\cpMax : Res = -2 : EndIf ; compare with last search pos      text\chrg\cpMin = McpMin       text\chrg\cpMax = McpMax      SendMessage_(GadgetID(Gadget), #EM_EXSETSEL, 0, @text\chrg) ; restore first selection    EndIf  EndIf  ProcedureReturn ResEndProcedure;Procedure RE_GetSelection(Gadget, *txtrange.CHARRANGE)  ProcedureReturn SendMessage_(GadgetID(Gadget), #EM_EXGETSEL, 0, *txtrange)EndProcedure;Procedure RE_SetSelection(Gadget, PosStart, PosEnd)  ;  Protected txtrange.CHARRANGE\cpMin = PosStart ;  début de la sélection.   txtrange\cpMax = PosEnd                       ; fin de la sélection  ProcedureReturn SendMessage_(GadgetID(Gadget), #EM_EXSETSEL, 0, @txtrange)  ;EndProcedure;Procedure RE_ReplaceSelection(Gadget, ReplaceString$)  ProcedureReturn SendMessage_(GadgetID(Gadget), #EM_REPLACESEL, 1, @ReplaceString$)EndProcedure;Procedure.s RE_GetGadgetWholeText(Gadget, format = #SF_TEXT)  ; Get text content of a RichEdit Gadget formated in simple Text$ / UTF8  ProcedureReturn RE_GetContent_RTF(Gadget, format)EndProcedure;Procedure RE_SaveContent(Gadget, FileName$, format = #SF_RTF, DelPict = 0)  ; Save content of a RichEdit Gadget formated in UTF8  ; If format is unsetted, the resulting file will content RTF data  ; If 'format' is set To #SF_TEXT|SFF_SELECTION Or #SF_RTF|SFF_SELECTION, only selected text will be saved  ;  Protected ct, p, pr, po, pf, hFile, Result  Protected Content$ = RE_GetContent_RTF(Gadget, format)  ;  If Content$    ; La couleur par défaut, qui apparaît bien en noir dans le REGadget, devient    ; transparente dans le fichier enregistré.    ; Il faut corriger.    Content$ = ReplaceString(Content$, "\red255\green255\blue255", "\red0\green0\blue0")    ;    If DelPict      ; On supprime les images      ct = 0      Repeat        p = FindString(Content$, "{\pict")        If p          ct = 1          pr = p + 5          Repeat            po = FindString(Content$, "{", pr + 1)            pf = FindString(Content$, "}", pr + 1)            If po And (po < pf Or pf = 0)              pr = po              ct + 1            EndIf            If pf And (pf < po Or po = 0)              pr = pf              ct - 1            EndIf          Until ct = 0 Or (pr = 0 And pf = 0)          If pr            pr + 1            While Mid(Content$, pr, 1) = " " : pr + 1 : Wend            While Mid(Content$, p - 1, 1) = " " : p - 1 : Wend            Content$ = Left(Content$, p - 1) + Mid(Content$, pr)          EndIf        EndIf      Until p = 0    EndIf    ;    ; Open file and write buffer content.    hFile = CreateFile(#PB_Any, Filename$)    ;    If hFile      ; Write content into file.      Result = WriteString(hFile, Trim(Content$))      CloseFile(hFile)    EndIf    ProcedureReturn Result  EndIfEndProcedure;Structure REFR_GadgetsTitles  WTitle$  Search$  ReplaceTitle$  Replace$  ReplaceAll$  Quit$  CaseSensitive$  WholeWord$  InAllDocument$  UnableToFind$  ReplacementMade$  SearchFromStart$  SearchFromEnd$EndStructure: Enumeration REFR_ShortCuts  #REFRShortCut_Quit  #REFRShortCut_Search  #REFRShortCut_TabEndEnumeration;Procedure RE_FindReplace(Gadget, Replace = 0, *TitlesPtr = 0)  ;  ; by Zapman  ;  ; Open a dialog allowing the user to find or replace a string into the content of a RichEdit Gadget  ; If parameter 'Replace' is omitted or set to zero, only find is possible  ;  Protected GTitles.REFR_GadgetsTitles  ;  Protected flags, WHeight ; Window format  Protected FRWindow, SearchStringGadget, BPrevious, BNext, VPos, ReplaceStringGadget ; Gadgets  Protected BReplace, BReplaceAll, BQuit, chk1, chk2, chk3                            ; Gadgets  Protected SelectedText$, DoSearch, Event, find.s, RewindSearch  Protected Pos, StartPos, FirstSearch, NbReplace, msg.s  Protected txtrange.CHARRANGE, repl.s  ;  If *TitlesPtr    CopyMemory(*TitlesPtr, @GTitles, SizeOf(REFR_GadgetsTitles))  Else    GTitles\WTitle$          = "Rechercher"    GTitles\Search$          = "Chercher :"    GTitles\ReplaceTitle$    = "Remplacer par :"    GTitles\Replace$         = "Remplacer"    GTitles\ReplaceAll$      = "Tout remplacer"    GTitles\Quit$            = "Quitter"    GTitles\CaseSensitive$   = "Respecter la casse"    GTitles\WholeWord$       = "Mot entier"    GTitles\InAllDocument$   = "Dans tout le document"    GTitles\UnableToFind$    = "Impossible de trouver"    GTitles\ReplacementMade$ = "remplacement(s) effectué(s)."    GTitles\SearchFromStart$ = "Rechercher depuis la fin ?"    GTitles\SearchFromEnd$   = "Rechercher depuis le début ?"  EndIf  flags = #PB_Window_SystemMenu | #PB_Window_ScreenCentered  If Replace    WHeight = 160  Else    WHeight = 120  EndIf  FRWindow = OpenWindow(#PB_Any, 0, 0, 500, WHeight, GTitles\WTitle$, flags)  StickyWindow(FRWindow, 1)  If FRWindow    StickyWindow(FRWindow, #True)    TextGadget(#PB_Any, 10, 20, 100, 22, GTitles\Search$)    SearchStringGadget = StringGadget(#PB_Any, 100, 15, 300, 25, "")    BPrevious = ButtonGadget(#PB_Any, 410, 15, 35, 26, "<<", #PB_Button_Default)    BNext = ButtonGadget(#PB_Any, 455, 15, 35, 26, ">>", #PB_Button_Default)    DisableGadget(BNext, #True)    If Replace      VPos = 55      TextGadget(#PB_Any, 10, VPos, 100, 22, GTitles\ReplaceTitle$)      ReplaceStringGadget = StringGadget(#PB_Any, 100, VPos - 5, 300, 25, "")      BReplace = ButtonGadget(#PB_Any, 410, VPos - 5, 80, 26, GTitles\Replace$)      DisableGadget(BReplace, #True)         BReplaceAll = ButtonGadget(#PB_Any, 410, VPos + 30, 80, 26, GTitles\ReplaceAll$)      DisableGadget(BReplaceAll, #True)    EndIf    BQuit = ButtonGadget(#PB_Any, 410, (WindowHeight(FRWindow) - 33), 80, 26, GTitles\Quit$)    VPos = 85    If Replace = 0      VPos - 40    EndIf    chk1 = CheckBoxGadget(#PB_Any, 10, VPos, 115, 26, GTitles\CaseSensitive$)    chk2 = CheckBoxGadget(#PB_Any, 135, VPos, 80, 26, GTitles\WholeWord$)    If Replace      chk3 = CheckBoxGadget(#PB_Any, 225, VPos, 180, 26, GTitles\InAllDocument$)    EndIf    ;    SendMessage_(GadgetID(Gadget), #EM_HIDESELECTION, #False, 0)    ;    ;get any selected text in the richedit    SelectedText$ = RE_GetGadgetSelectedText(Gadget)    If Len(SelectedText$) < 128      SetGadgetText(SearchStringGadget, SelectedText$)      ;focus the replace input field      If IsGadget(ReplaceStringGadget) : SetActiveGadget(ReplaceStringGadget) : EndIf      ;enable the buttons      DisableGadget(BNext, #False)      If Replace        DisableGadget(BReplace, #False)        DisableGadget(BReplaceAll, #False)      EndIf    EndIf    ;focus the findstring input field    SetActiveGadget(SearchStringGadget)    ;    AddKeyboardShortcut(FRWindow, #PB_Shortcut_Return, #REFRShortCut_Search)    AddKeyboardShortcut(FRWindow, #PB_Shortcut_Escape, #REFRShortCut_Quit)    AddKeyboardShortcut(FRWindow, #PB_Shortcut_Tab, #REFRShortCut_Tab)    ;    Repeat      event = WaitWindowEvent()      DoSearch = 0      If EventWindow() <> FRWindow        SetActiveWindow(FRWindow)      Else        If event = #PB_Event_Menu          If EventMenu() = #REFRShortCut_Tab            If GetActiveGadget() = SearchStringGadget              If IsGadget(ReplaceStringGadget)                While WindowEvent() : Wend                SetActiveGadget(ReplaceStringGadget)              EndIf            ElseIf IsGadget(ReplaceStringGadget) And GetActiveGadget() = ReplaceStringGadget              While WindowEvent() : Wend              SetActiveGadget(SearchStringGadget)            EndIf          ElseIf EventMenu() = #REFRShortCut_Search            DoSearch = 1            event = #PB_Event_Gadget          ElseIf EventMenu() = #REFRShortCut_Quit            Break          EndIf        ElseIf event = #PB_Event_CloseWindow          Break          EndIf        If event = #PB_Event_Gadget          If EventGadget() =  BNext            DoSearch = 1          EndIf          If EventGadget() = SearchStringGadget            ;find string            ;GadgetToolTip(SearchStringGadget, GetGadgetText(SearchStringGadget))            If Len(GetGadgetText(SearchStringGadget))              DisableGadget(BPrevious, #False)              DisableGadget(BNext, #False)              If Replace                DisableGadget(BReplace, #False)                DisableGadget(BReplaceAll, #False)              EndIf            Else              DisableGadget(BPrevious, #True)              DisableGadget(BNext, #True)              If Replace                DisableGadget(BReplace, #True)                DisableGadget(BReplaceAll, #True)              EndIf            EndIf          ElseIf Replace And EventGadget() =  ReplaceStringGadget            ;replace string            ;GadgetToolTip(ReplaceStringGadget, GetGadgetText(ReplaceStringGadget))          ElseIf DoSearch Or EventGadget() = BPrevious Or (Replace And EventGadget() =  BReplace Or EventGadget() =  BReplaceAll)            find.s = GetGadgetText(SearchStringGadget)            If Replace And (EventGadget() =  BReplace Or EventGadget() =  BReplaceAll) ; If replacing...              RE_GetSelection(Gadget, @txtrange.CHARRANGE)              If (txtrange\cpMin <> txtrange\cpMax) ; if there is a selection, go to the beginning of it                RE_SetSelection(Gadget, txtrange\cpMin, txtrange\cpMax)              EndIf            EndIf            ;            If EventGadget() = BPrevious : RewindSearch = 1 : Else : RewindSearch = 0 : EndIf            ;            StartPos = -2            If IsGadget(chk3) And GetGadgetState(chk3)              ;reset, search from the top (or from the end, if it's a << search)              SetGadgetState(chk3, 0)              If RewindSearch : StartPos = -1 : Else : StartPos = 0 : EndIf            EndIf            ;            FirstSearch = 0            NbReplace = 0            RE_RebootSearch:             FirstSearch + 1            Repeat              pos = RE_SearchString(Gadget, find, GetGadgetState(chk1), GetGadgetState(chk2), RewindSearch, StartPos)              If Replace And pos > -1 And (EventGadget() =  BReplace Or EventGadget() =  BReplaceAll)                repl.s = GetGadgetText(ReplaceStringGadget)                RE_ReplaceSelection(Gadget, repl)                RE_GetSelection(Gadget, @txtrange.CHARRANGE)                txtrange\cpMin = txtrange\cpMax - Len(repl)                If EventGadget() =  BReplaceAll Or (EventGadget() =  BReplace And FindString(repl, find, 0))                  txtrange\cpMin = txtrange\cpMax                EndIf                RE_SetSelection(Gadget, txtrange\cpMin, txtrange\cpMax)                NbReplace + 1              EndIf            Until EventGadget() <>  BReplaceAll Or pos < 0 Or Replace = 0            If pos = -2 ; String not found, but it is possible to extend the search range              If NbReplace = 0                msg.s = GTitles\UnableToFind$ + " " + find + Chr(13) + Chr(10)              Else                msg = ""                If EventGadget() =  BReplaceAll                  msg.s = Str(NbReplace) + " " + GTitles\ReplacementMade$ + Chr(13) + Chr(10)                EndIf              EndIf              If RewindSearch                msg + GTitles\SearchFromStart$                StartPos = -1              Else                msg + GTitles\SearchFromEnd$                StartPos = 0              EndIf              If MessageRequester(GTitles\WTitle$, msg, #PB_MessageRequester_YesNo) =  #PB_MessageRequester_Yes                Goto RE_RebootSearch                SetActiveGadget(Gadget)              EndIf            EndIf            ;            msg.s = ""            If Replace And EventGadget() =  BReplaceAll              msg.s = Str(NbReplace) + " " + GTitles\ReplacementMade$            ElseIf pos = -1              msg.s = GTitles\UnableToFind$ + " " + find            EndIf            If msg              MessageRequester(GTitles\WTitle$, msg, #PB_MessageRequester_Ok)              SetActiveGadget(Gadget)            EndIf          EndIf          If EventGadget() =  BQuit            Break          EndIf        EndIf        ;      EndIf      SetForegroundWindow_(WindowID(FRWindow))      SetActiveWindow(FRWindow)    ForEver    CloseWindow(FRWindow)  EndIfEndProcedure;Structure AlertWindowGList  WindowNum.i  RE_gadget.i  YesNoCancel.i  BOK.i  BCancel.i  BYes.i  BNo.i  BSearch.i  BCopy.i  BSave.i  Margins.i  BHeight.i  BWidth.iEndStructure;Structure AlertWindowTitles  WTitle$  BOK$  BCopy$  BSave$  BSearch$  BYes$  BNo$  BCancel$  SaveAs$  TextFile$  SearchGadgets.REFR_GadgetsTitlesEndStructure;Enumeration AlertYesNoCancel  #AW_AlertOnly  #AW_YesOrNo_YesByDefault  #AW_YesOrNo_NoByDefault  #AW_OKOrCancel_OKByDefault  #AW_OKOrCancel_CancelByDefault  #AW_YesNoOrCancel_YesByDefault  #AW_YesNoOrCancel_NoByDefault  #AW_YesNoOrCancel_CancelByDefaultEndEnumeration;Procedure ResizeAlertWindow()  ;  Shared AlertGList.AlertWindowGList ; Pour le partage des numéros de gadgets.  ;  Protected WWidth, WHeight, Margins, LowBPos, YesNoCancel  ;  WWidth  = WindowWidth(AlertGList\WindowNum)  WHeight = WindowHeight(AlertGList\WindowNum)  Margins = AlertGList\Margins  LowBPos = WHeight - AlertGList\BHeight - Margins  YesNoCancel = AlertGList\YesNoCancel  ;  ResizeGadget(AlertGList\RE_gadget,  #PB_Ignore, #PB_Ignore, (WWidth - Margins * 2), (WHeight - AlertGList\BHeight - Margins * 2))  ;  ; Bouton occupant la position la plus à droite :  If IsGadget(AlertGList\BOK) And (YesNoCancel = #AW_AlertOnly Or YesNoCancel = #AW_OKOrCancel_OKByDefault)    ResizeGadget(AlertGList\BOK,        WWidth - AlertGList\BWidth - Margins,     LowBPos, #PB_Ignore, #PB_Ignore)  EndIf  If IsGadget(AlertGList\BYes) And (YesNoCancel = #AW_YesOrNo_YesByDefault Or YesNoCancel = #AW_YesNoOrCancel_YesByDefault)    ResizeGadget(AlertGList\BYes,       WWidth - AlertGList\BWidth - Margins,     LowBPos, #PB_Ignore, #PB_Ignore)  EndIf  If IsGadget(AlertGList\BNo) And (YesNoCancel = #AW_YesOrNo_NoByDefault Or YesNoCancel = #AW_YesNoOrCancel_NoByDefault)    ResizeGadget(AlertGList\BNo,        WWidth - AlertGList\BWidth - Margins,     LowBPos, #PB_Ignore, #PB_Ignore)  EndIf  If IsGadget(AlertGList\BCancel) And (YesNoCancel = #AW_OKOrCancel_CancelByDefault Or YesNoCancel = #AW_YesNoOrCancel_CancelByDefault)    ResizeGadget(AlertGList\BCancel,    WWidth - AlertGList\BWidth - Margins,     LowBPos, #PB_Ignore, #PB_Ignore)  EndIf  ;  ; Bouton occupant la deuxième position à partir de la droite  If IsGadget(AlertGList\BOK) And (YesNoCancel = #AW_OKOrCancel_CancelByDefault)    ResizeGadget(AlertGList\BOK,        WWidth - (AlertGList\BWidth + Margins) * 2, LowBPos, #PB_Ignore, #PB_Ignore)  EndIf  If IsGadget(AlertGList\BYes) And (YesNoCancel = #AW_YesOrNo_NoByDefault Or YesNoCancel = #AW_YesNoOrCancel_NoByDefault)    ResizeGadget(AlertGList\BYes,       WWidth - (AlertGList\BWidth + Margins) * 2, LowBPos, #PB_Ignore, #PB_Ignore)  EndIf  If IsGadget(AlertGList\BNo) And (YesNoCancel = #AW_YesOrNo_YesByDefault Or YesNoCancel = #AW_YesNoOrCancel_YesByDefault Or YesNoCancel = #AW_YesNoOrCancel_CancelByDefault)    ResizeGadget(AlertGList\BNo,        WWidth - (AlertGList\BWidth + Margins) * 2, LowBPos, #PB_Ignore, #PB_Ignore)  EndIf  If IsGadget(AlertGList\BCancel) And YesNoCancel = #AW_OKOrCancel_OKByDefault    ResizeGadget(AlertGList\BCancel,    WWidth - (AlertGList\BWidth + Margins) * 2, LowBPos, #PB_Ignore, #PB_Ignore)  EndIf  ;  ; Bouton occupant la troisième position à partir de la droite  If IsGadget(AlertGList\BYes) And YesNoCancel = #AW_YesNoOrCancel_CancelByDefault    ResizeGadget(AlertGList\BYes,       WWidth - (AlertGList\BWidth + Margins) * 3, LowBPos, #PB_Ignore, #PB_Ignore)  EndIf  If IsGadget(AlertGList\BCancel) And (YesNoCancel = #AW_YesNoOrCancel_YesByDefault Or YesNoCancel = #AW_YesNoOrCancel_NoByDefault)    ResizeGadget(AlertGList\BCancel,    WWidth - (AlertGList\BWidth + Margins) * 3, LowBPos, #PB_Ignore, #PB_Ignore)  EndIf  ;    If IsGadget(AlertGList\BCopy) And YesNoCancel = #AW_AlertOnly    ResizeGadget(AlertGList\BCopy,      WWidth - (AlertGList\BWidth + Margins) * 2, LowBPos, #PB_Ignore, #PB_Ignore)    ResizeGadget(AlertGList\BSave,      WWidth - (AlertGList\BWidth + Margins) * 3, LowBPos, #PB_Ignore, #PB_Ignore)    ResizeGadget(AlertGList\BSearch,    WWidth - (AlertGList\BWidth + Margins) * 4, LowBPos, #PB_Ignore, #PB_Ignore)    ;    If WWidth < (AlertGList\BWidth + Margins) * 3 + Margins      HideGadget(AlertGList\BCopy,   #True)      HideGadget(AlertGList\BSave,   #True)      HideGadget(AlertGList\BSearch, #True)    ElseIf WWidth < (AlertGList\BWidth + Margins) * 4 + Margins      HideGadget(AlertGList\BCopy,   #False)      HideGadget(AlertGList\BSave,   #False)      HideGadget(AlertGList\BSearch, #True)    Else      HideGadget(AlertGList\BCopy,   #False)      HideGadget(AlertGList\BSave,   #False)      ;      ; On décide arbitrairement que les textes dont la longeur est inférieure      ; à 160000 caractères n'ont pas besoin d'un outil de recherche.      If (GadgetWidth(AlertGList\RE_gadget) * GadgetHeight(AlertGList\RE_gadget)) < 160000        HideGadget(AlertGList\BSearch, #True)      Else        HideGadget(AlertGList\BSearch, #False)      EndIf    EndIf  EndIfEndProcedure;Enumeration AlertWShortcuts  #AW_Shortcut_Quit  #AW_Shortcut_DefButton  #AW_Shortcut_Search  #AW_Shortcut_SaveEndEnumeration;#RTF_Marker = 23675;Procedure THG(EventGadget, Gadget)  ; Test Hyphotetical GagdetEvent  If IsGadget(Gadget) And EventGadget = Gadget    ProcedureReturn #True  EndIfEndProcedure  ;Procedure Alert(Message$, *STextPointeur = 0, WSticky = 1, WhiteBackGround = 0, Txtleft = 0, FixedWidth = 0, TabList$ = "", YesNoCancel = #AW_AlertOnly)  ;  ; Displays the message 'Message$' in a window whose dimensions are optimized  ; according to the size of the message.  ;  ; The window also includes 'Copy All', 'Save', and for  ; large texts, a 'Search' button that allows searching  ; within the displayed text.  ;  ; *STextPointer normally points to a structure 'AlertWindowTitles' which contains the names  ; to be given to the buttons and the title to be assigned to the window.  ;  ; To simplify the use of this procedure, it is not mandatory to provide  ; this structure. '*STextPointer' can be omitted at the time of the call, or '*STextPointer'  ; can simply point to a string containing the title to be given to the window.  ;  ; If WhiteBackGround contains a non-zero value, the text background will be white instead of yellow.  ; If TxtLeft contains a non-zero value, the text will always be left-aligned.  ; If FixedWidth contains a non-zero value, the window width will conform to it.  ; TabList$ can contain a list of tab positions in the form "pos1,pos2,pos3"  ; YesNoCancel can contain one of the values from the 'AlertYesNoCancel' enumeration, in which case  ; the buttons 'Yes', 'No', or 'OK' and 'Cancel' will appear in the window.  ; You can also cheat and give different titles to these buttons by adjusting the values of *STextPointer.  ;  ; The return value can be #PB_MessageRequester_Yes, #PB_MessageRequester_No, or #PB_MessageRequester_Cancel  ;  Shared AlertGList.AlertWindowGList ; Pour le partage des numéros de gadgets avec la procédure Resize                                     ;  Static AlertText.AlertWindowTitles ; Stocke les textes des boutons et le titre de la fenêtre  ;  Protected WWidth, WHeight, RTF  Protected TextSurf, TW.d, TH.d, ratio.f, SL  Protected WX, WY, scrollPos.Point  Protected EventID, QuitAll, NFile$  Protected *tabStops, PosInList, TabPos$  Protected *mem, BDefault  ;  Protected WindowTitle$ = ""  ;  If IsMemoryValid(*STextPointeur)    Protected *Test.AlertWindowTitles = *STextPointeur    If Not (IsMemoryValid(@*Test\WTitle$)) Or Not (IsMemoryValid(@*Test\BOK$)) Or Not (IsMemoryValid(@*Test\BSearch$)) Or Not (IsMemoryValid(@*Test\BCopy$)) Or Not (IsMemoryValid(@*Test\BSave$))      ; Les adresses mémoires qui devraient correspondre aux champs de *Test.AlertWindowTitles ne sont pas valides.      ; cela signifie que *STextPointeur ne pointe pas vers une structure 'AlertWindowTitles'.      ; Puisque *STextPointeur est malgré tout un pointeur valide, on suppose qu'il pointe      ; vers une simple chaîne string contenant le titre de la fenêtre.      ;      ; On attribue la valeur de la chaîne à 'WindowTitle$'      If IsMemoryValid(@*Test\WTitle$)        WindowTitle$ = *Test\WTitle$      EndIf    Else      ; *Test semble être un pointeur valide vers une structure 'AlertWindowTitles'.      ; Néenmoins, on ne va pas toucher aux valeurs de cette structure. On se contente      ; de les recopier, à condition qu'elles soient renseignées.      ; Ainsi, si l'utilisateur ne veut changer qu'une seule des valeurs, il lui suffit      ; de laisser les autres vides.      If *Test\WTitle$  : AlertText\WTitle$   = *Test\WTitle$  : EndIf      If *Test\BOK$     : AlertText\BOK$      = *Test\BOK$     : EndIf      If *Test\BCancel$ : AlertText\BCancel$  = *Test\BCancel$ : EndIf      If *Test\BYes$    : AlertText\BYes$     = *Test\BYes$    : EndIf      If *Test\BNo$     : AlertText\BNo$      = *Test\BNo$     : EndIf      If *Test\BCopy$   : AlertText\BCopy$    = *Test\BCopy$   : EndIf      If *Test\BSave$   : AlertText\BSave$    = *Test\BSave$   : EndIf      If *Test\BSearch$ : AlertText\BSearch$  = *Test\BSearch$ : EndIf      If *Test\SaveAs$  : AlertText\SaveAs$   = *Test\SaveAs$  : EndIf      If *Test\TextFile$: AlertText\TextFile$ = *Test\TextFile$: EndIf      If *Test\SearchGadgets        CopyStructure(@*Test\SearchGadgets, @AlertText\SearchGadgets, REFR_GadgetsTitles)      EndIf    EndIf  EndIf  ;  ; La version française est privilégiée dans les valeurs par défaut, parce que j'utilise énormément  ; cette procédure dans tous mes programmes, y compris ceux qui ne sont pas rendus traduisibles  ; dans d'autres langues.  ;  If AlertText\WTitle$ = ""  : AlertText\WTitle$ = "Attention"  : EndIf  If AlertText\BOK$ = ""     : AlertText\BOK$ = "OK"            : EndIf  If AlertText\BCancel$ = "" : AlertText\BCancel$ = "Annuler"   : EndIf  If AlertText\BYes$ = ""    : AlertText\BYes$ = "Oui"          : EndIf  If AlertText\BNo$ = ""     : AlertText\BNo$ = "Non"           : EndIf  If AlertText\BCopy$ = ""   : AlertText\BCopy$ = "Tout copier" : EndIf  If AlertText\BSave$ = ""   : AlertText\BSave$ = "Enregistrer" : EndIf  If AlertText\BSearch$ = "" : AlertText\BSearch$ = "Chercher"  : EndIf  If AlertText\SaveAs$ = ""  : AlertText\SaveAs$  = "Enregistrer sous..."   : EndIf  If AlertText\TextFile$ = "": AlertText\TextFile$ = "Fichiers Textes|*.txt" : EndIf  ;  ; AlertText contient à présent nos valeurs transmises ou nos valeurs par défaut.  ; On préserve le titre de fenêtre éventuellement passé en paramètre dans *STextPointeur.  If WindowTitle$ = "" : WindowTitle$ = AlertText\WTitle$ : EndIf  ;  If Message$    WWidth = 300    If FixedWidth      WWidth = FixedWidth    EndIf    WHeight = 120    ;    If PeekC(@Message$) = #RTF_Marker      ; Le texte à afficher provient d'un fichier enregistré en RTF.      RTF = 1    ElseIf Left(Message$, 5) = "{\rtf" Or Left(Message$, 6) = "{\urtf"      ; Le texte à afficher est codé en RTF.      RTF = 2    Else      RTF = 0    EndIf        AlertGList\WindowNum = OpenWindow(#PB_Any, 0, 0, WWidth, WHeight, WindowTitle$, #PB_Window_Invisible | #PB_Window_MinimizeGadget | #PB_Window_MaximizeGadget | #PB_Window_SystemMenu | #PB_Window_SizeGadget | #PB_Window_TitleBar | #PB_Window_ScreenCentered)    ;        If IsWindow(AlertGList\WindowNum)      WindowBounds(AlertGList\WindowNum, WWidth, WHeight, #PB_Ignore, #PB_Ignore)      ;      If WSticky        StickyWindow(AlertGList\WindowNum, 1)      EndIf      AlertGList\BHeight = 24      AlertGList\BWidth = 90      AlertGList\Margins = 8      AlertGList\YesNoCancel = YesNoCancel      ;      AlertGList\RE_gadget = EditorGadget(#PB_Any, AlertGList\Margins, 0, 1, 1)      If WhiteBackGround = 0        SetGadgetColor(AlertGList\RE_gadget, #PB_Gadget_BackColor, $F0FDFD)      EndIf      SendMessage_(GadgetID(AlertGList\RE_gadget), #EM_SETTARGETDEVICE, #Null, 0); <<--- retour à la ligne automatique      SendMessage_(GadgetID(AlertGList\RE_gadget), #EM_LIMITTEXT, -1, 0)         ; set unlimited content size      SendMessage_(GadgetID(AlertGList\RE_gadget), #EM_SETTEXTMODE, #TM_RICHTEXT, 0)      If TabList$        RE_SetSelection(AlertGList\RE_gadget, 0, -1)        ; Le paramètre 'TabList$' contient la liste des tabulations à placer dans le REgadget :        ; Cette liste doit avoir la forme "pos1,pos2,pos3".        ; On va convertir cette forme de liste en une suite de nombres au format WORD,        ; stockés dans une zone mémoire, afin de pouvoir l'utiliser dans un SendMessage_()        ;        ; On compte le nombre de virgules auquel on ajoute 1, puis on multiplie par 4        ; car la taille d'un WORD est de 4 octets :        *tabStops = AllocateMemory((CountString(TabList$, ",") + 1) * 4)        ;        PosInList = 0        Repeat          PosInList + 1          TabPos$ = StringField(TabList$, PosInList, ",")          If TabPos$            PokeW(*tabStops + 4 * (PosInList - 1), Val(TabPos$))          EndIf        Until TabPos$ = ""        SendMessage_(GadgetID(AlertGList\RE_gadget), #EM_SETTABSTOPS, CountString(TabList$, ",") + 1, *tabStops)        FreeMemory(*tabStops)      EndIf      ;      If RTF = 2        *mem = AllocateMemory(StringByteLength(Message$, #PB_UTF8) + 1)        PokeS(*mem, Message$, -1, #PB_UTF8) ; on écrit la chaine en UTF8        ; on relit la chaine en Unicode et on l'insert dans le Gadget        SendMessage_(GadgetID(AlertGList\RE_gadget), #EM_REPLACESEL, 0, PeekS(*mem, -1, #PB_Unicode))        FreeMemory(*mem)      Else        SendMessage_(GadgetID(AlertGList\RE_gadget), #EM_REPLACESEL, 0, @Message$)      EndIf      SendMessage_(GadgetID(AlertGList\RE_gadget), #EM_SETREADONLY, #True, 0)      ;      If YesNoCancel = #AW_AlertOnly Or YesNoCancel = #AW_OKOrCancel_OKByDefault Or YesNoCancel = #AW_OKOrCancel_CancelByDefault        If YesNoCancel = #AW_AlertOnly Or YesNoCancel = #AW_OKOrCancel_OKByDefault          BDefault = 1        Else          BDefault = 0        EndIf        AlertGList\BOK = ButtonGadget(#PB_Any, 1, 1, AlertGList\BWidth, AlertGList\BHeight, AlertText\BOK$, #PB_Button_Default * BDefault)      EndIf      If YesNoCancel = #AW_OKOrCancel_OKByDefault Or YesNoCancel = #AW_OKOrCancel_CancelByDefault Or YesNoCancel = #AW_YesNoOrCancel_YesByDefault Or YesNoCancel = #AW_YesNoOrCancel_NoByDefault Or YesNoCancel = #AW_YesNoOrCancel_CancelByDefault        If YesNoCancel = #AW_OKOrCancel_CancelByDefault Or YesNoCancel = #AW_YesNoOrCancel_CancelByDefault          BDefault = 1        Else          BDefault = 0        EndIf        AlertGList\BCancel = ButtonGadget(#PB_Any, 1, 1, AlertGList\BWidth, AlertGList\BHeight, AlertText\BCancel$, #PB_Button_Default * BDefault)      EndIf      If YesNoCancel = #AW_YesOrNo_YesByDefault Or YesNoCancel = #AW_YesOrNo_NoByDefault Or YesNoCancel = #AW_YesNoOrCancel_YesByDefault Or YesNoCancel = #AW_YesNoOrCancel_NoByDefault Or YesNoCancel = #AW_YesNoOrCancel_CancelByDefault        If YesNoCancel = #AW_YesOrNo_YesByDefault Or YesNoCancel = #AW_YesNoOrCancel_YesByDefault          BDefault = 1        Else          BDefault = 0        EndIf        AlertGList\BYes = ButtonGadget(#PB_Any, 1, 1, AlertGList\BWidth, AlertGList\BHeight, AlertText\BYes$, #PB_Button_Default * BDefault)        ;        If YesNoCancel = #AW_YesOrNo_NoByDefault Or YesNoCancel = #AW_YesNoOrCancel_NoByDefault          BDefault = 1        Else          BDefault = 0        EndIf        AlertGList\BNo  = ButtonGadget(#PB_Any, 1, 1, AlertGList\BWidth, AlertGList\BHeight, AlertText\BNo$, #PB_Button_Default * BDefault)      EndIf      If YesNoCancel = #AW_AlertOnly        AlertGList\BCopy   = ButtonGadget(#PB_Any, 1, 1, AlertGList\BWidth, AlertGList\BHeight, AlertText\BCopy$)        AlertGList\BSave   = ButtonGadget(#PB_Any, 1, 1, AlertGList\BWidth, AlertGList\BHeight, AlertText\BSave$)        AlertGList\BSearch = ButtonGadget(#PB_Any, 1, 1, AlertGList\BWidth, AlertGList\BHeight, AlertText\BSearch$)      EndIf      ;      ; Si le message était en RTF, on récupère son équivalent en texte.      Message$ = ReplaceString(GetGadgetText(AlertGList\RE_gadget), Chr(10), "")      ;      ; On va tenter de réajuster les dimensions de la fenêtre par rapport      ; à la taille du texte.      ;      ; On calcule la surface d'affichage nécessaire par rapport      ; à la longueur du texte :      ; On récupère les dimensions du texte :      RE_SetSelection(AlertGList\RE_gadget, 0, -1)      GetTextSurfPix(AlertGList\RE_gadget, Message$, @TW, @TH)      ; On calcule la surface d'affichage et on la gonfle un peu en la      ; multipliant par 1.2. Le résultat est approximatif, car les retours      ; chariot sont comptés comme des caractères ordinaires, alors qu'ils      ; font perdre de la surface d'affichage. De même, si le message était      ; en RTF et qu'il comporte des images, chaque image compte pour un seul      ; caractère, alors que l'image peut prendre beaucoup de place.      ; Cela nous donne cependant une approximation.      Protected MonitorDPI.f = GetMonitorDPI(AlertGList\WindowNum)      If MonitorDPI = 0 : MonitorDPI = 1 : EndIf      TextSurf = TW * TH * 1.2 / MonitorDPI      ;      ;      If RTF = 0        ; Légère mise en forme pour les textes non RTF :        ;        If TextSurf < 50000 And Txtleft = 0 And TabList$ = ""          ; Si le texte est court, on le centre.          Protected paraFormat.PARAFORMAT2          paraFormat\cbSize = SizeOf(PARAFORMAT2)          paraFormat\dwMask = #PFM_ALIGNMENT          paraFormat\wAlignment = #PFA_CENTER          SendMessage_(GadgetID(AlertGList\RE_gadget), #EM_SETPARAFORMAT, #SCF_SELECTION, @paraFormat)        EndIf        ;        ; On ajoute des petites marges à gauche et à droite,        ; pour que le texte ne soit pas collé aux bords.        Protected format.PARAFORMAT        format\cbSize = SizeOf(PARAFORMAT)        format\dwMask = #PFM_RIGHTINDENT | #PFM_OFFSETINDENT        format\dxStartIndent = 100        format\dxRightIndent = 100        SendMessage_(GadgetID(AlertGList\RE_gadget), #EM_SETPARAFORMAT, #SCF_SELECTION, @format)        ;      EndIf      ;      AW_ComputeWidthAndHeightFromSurf:       ;      If FixedWidth        WWidth = FixedWidth        SL = 0      Else        If TextSurf = 0          ; Cela peut se produire sur des vieux systèmes Windows          TextSurf = 400 * 500        EndIf        ; On recalcule les dimensions de la fenêtre :        ; Puisque TextSurf est une surface, on extrait sa racine carrée        ; pour avoir une idée de la longueur de son côté.        WWidth = Sqr(TextSurf)        ;        ; On va maintenant décider d'un ratio largeur/hauteur en partant        ; de l'idée que les petites fenêtres doivent être plus larges que        ; hautes, et les grandes, plus hautes que larges.        ratio = 1 + (800 - WWidth) / 1600        If ratio < 1          WWidth = 800        Else          WWidth * ratio * 1.2        EndIf        ;        SL = 0        ; On compare la largeur obtenue aux limites imposées par l'écran        ; et par les contraintes de lisibilité. Quand une fenêtre est trop        ; large, le texte qu'elle contient est pénible à lire.        If WWidth > 800 : WWidth = 800 : EndIf        ;        ExamineDesktops()        ;        If WWidth > (DesktopWidth(0) / MonitorDPI - 300)          WWidth = DesktopWidth(0) / MonitorDPI - 300          SL = 1        EndIf      EndIf      ;      ; La hauteur est égale à la surface divisée par la largeur :      WHeight = TextSurf / WWidth      If WHeight > (DesktopHeight(0) / MonitorDPI - 200)        WHeight = DesktopHeight(0) / MonitorDPI - 200        SL = 1      EndIf      ; On calcule le centre de l'écran courant :      WX = DesktopX(0) + DesktopWidth(0)  / 2      WY = DesktopY(0) + DesktopHeight(0) / 2      ; On calcule les origines X et Y de la fenêtre en faisant      ; en sorte qu'elle soit centrée sur l'écran :      WX / MonitorDPI - WWidth / 2      WY / MonitorDPI - WHeight / 2      ;      ResizeWindow(AlertGList\WindowNum, WX, WY, WWidth, WHeight)      ; On redimensionne les gadgets en fonctions de la nouvelle taille de fenêtre      ResizeAlertWindow()      ;      If SL = 0        ; Les dimensions calculées n'ont pas dépassé les limites de l'écran        ; et nous avons encore la possibilité d'agrandir la fenêtre si nécessaire.        ; On va donc regarder si l'ascenseur de la fenêtre s'est activé, ce qui        ; voudrait dire que les dimensions actuelles sont insuffisantes pour        ; afficher tout le texte.        ;        ; On se place à la fin de la sélection pour positionner l'ascenseur :        RE_SetSelection(AlertGList\RE_gadget, -1, -1)        SendMessage_(GadgetID(AlertGList\RE_gadget), #EM_GETSCROLLPOS, 0, @scrollPos)        If scrollPos\y          ; L'ascenseur s'est activé.          ; On agrandit la surface préalablement estimée          ; en lui ajoutant une hauteur de ligne multipliée par la largeur de fenêtre.          TextSurf + TH * WWidth          Goto AW_ComputeWidthAndHeightFromSurf        EndIf      EndIf      ;      ; Le calcul de dimensions de fenêtre est terminé.      ;      ; On efface la sélection:      RE_SetSelection(AlertGList\RE_gadget, 0, 0)      ;      ; La fenêtre était invisible jusqu'ici, car nous l'avons créée avec #PB_Window_Invisible.      ; On la rend visible.      HideWindow(AlertGList\WindowNum, #False)      ;      ; Si malgré tout le mal que nous nous sommes donné, l'utilisateur veut redimensionner      ; la fenêtre lui-même, on lui en donne la possibilité :      BindEvent(#PB_Event_SizeWindow, @ResizeAlertWindow(), AlertGList\WindowNum)      ;      AddKeyboardShortcut(AlertGList\WindowNum, #PB_Shortcut_Return, #AW_Shortcut_DefButton)      AddKeyboardShortcut(AlertGList\WindowNum, #PB_Shortcut_Escape, #AW_Shortcut_Quit)      AddKeyboardShortcut(AlertGList\WindowNum, #PB_Shortcut_Control | #PB_Shortcut_F, #AW_Shortcut_Search)      AddKeyboardShortcut(AlertGList\WindowNum, #PB_Shortcut_Control | #PB_Shortcut_S, #AW_Shortcut_Save)      ;      ClearKeyboardBuffer(AlertGList\WindowNum)      ;      Repeat        EventID = WaitWindowEvent()        If EventWindow() <> AlertGList\WindowNum And WSticky          SetActiveWindow(AlertGList\WindowNum)        Else          If EventID = #PB_Event_Gadget            EventGadget = EventGadget()          ElseIf EventID = #PB_Event_CloseWindow            QuitAll = #PB_MessageRequester_Cancel          ElseIf EventID = #PB_Event_Menu            If EventMenu() = #AW_Shortcut_Quit              QuitAll = #PB_MessageRequester_Cancel            ElseIf EventMenu() =   #AW_Shortcut_DefButton              If YesNoCancel = #AW_YesOrNo_YesByDefault Or YesNoCancel = #AW_YesNoOrCancel_YesByDefault Or YesNoCancel = #AW_OKOrCancel_OKByDefault                QuitAll = #PB_MessageRequester_Yes              ElseIf YesNoCancel = #AW_YesOrNo_NoByDefault Or YesNoCancel = #AW_YesNoOrCancel_NoByDefault                QuitAll = #PB_MessageRequester_No              Else                QuitAll = #PB_MessageRequester_Cancel              EndIf            ElseIf EventMenu() = #AW_Shortcut_Search              EventID = #PB_Event_Gadget              EventGadget = AlertGList\BSearch            ElseIf EventMenu() = #AW_Shortcut_Save              EventID = #PB_Event_Gadget              EventGadget = AlertGList\BSave            EndIf          EndIf          If EventID = #PB_Event_Gadget            If THG(EventGadget, AlertGList\BOK) Or THG(EventGadget, AlertGList\BYes)              QuitAll = #PB_MessageRequester_Yes            ElseIf THG(EventGadget, AlertGList\BCancel)              QuitAll = #PB_MessageRequester_Cancel            ElseIf THG(EventGadget, AlertGList\BNo)              QuitAll = #PB_MessageRequester_No            ElseIf THG(EventGadget, AlertGList\BSearch)              RE_FindReplace(AlertGList\RE_gadget, 0, AlertText\SearchGadgets)            ElseIf THG(EventGadget, AlertGList\BCopy)              SetClipboardText(RE_GetGadgetWholeText(AlertGList\RE_gadget))              RE_SetSelection(AlertGList\RE_gadget, 0, -1)            ElseIf THG(EventGadget, AlertGList\BSave)              NFile$ = SaveFileRequester(AlertText\SaveAs$, "", AlertText\TextFile$, 1)              If NFile$                If GetExtensionPart(NFile$) <> "txt" : NFile$ + ".txt" : EndIf                RE_SaveContent(AlertGList\RE_gadget, NFile$, 0)              EndIf            EndIf          EndIf        EndIf      Until QuitAll    EndIf    If IsWindow(AlertGList\WindowNum)      ClearKeyboardBuffer(AlertGList\WindowNum)      CloseWindow(AlertGList\WindowNum)    EndIf  EndIf  ProcedureReturn QuitAllEndProcedure; Procedure AlertWithTitle(Message$, Title$, WSticky = 1, WhiteBackGround = 0, Txtleft = 0, FixedWidth = 0, TabList$ = "", YesNoCancel = #AW_AlertOnly)  ; Appelle la procédure 'Alert()' en lui fournissant un titre de fenêtre.  ; Ce titre ne modifiera pas le titre pas défaut de la fenêtre Alert().  Protected Temp.AlertWindowTitles\WTitle$ = Title$  ProcedureReturn Alert(Message$, Temp, WSticky, WhiteBackGround, Txtleft, FixedWidth, TabList$, YesNoCancel)EndProcedure;Procedure AlertYesNoCancel(Message$, Title$ = "", Type = #AW_YesOrNo_YesByDefault)  ;  ; Type peut prendre l'une des valeurs suivantes :  ; #AW_AlertOnly  ; #AW_YesOrNo_YesByDefault  ; #AW_YesOrNo_NoByDefault  ; #AW_OKOrCancel_OKByDefault  ; #AW_OKOrCancel_CancelByDefault  ; #AW_YesNoOrCancel_YesByDefault  ; #AW_YesNoOrCancel_NoByDefault  ; #AW_YesNoOrCancel_CancelByDefault  Protected Temp.AlertWindowTitles\WTitle$ = Title$  ProcedureReturn Alert(Message$, Temp, 1, 0, 0, 0, "", Type)EndProcedure;Procedure InitAlertTexts()  ;  ;         Pour avoir une version française des textes, il suffit de  ;              désactiver la ligne 'InitAlertTexts()' qui figure  ;                       juste après cette procédure.  ;  Protected AlertText.AlertWindowTitles  ;  ;         Initialization of button texts and window title  ;                   for the 'Alert()' procedure.  ;         By default, the button texts are in French. This  ;       procedure is intended to translate them into English.  ;  ;         To have a German version or another language  ;      simply translate the list of texts that appear below:  ;  AlertText\WTitle$  = "Attention"  AlertText\BOK$     = "OK"  AlertText\BCancel$ = "Cancel"  AlertText\BYes$    = "Yes"  AlertText\BNo$     = "No"  AlertText\BCopy$   = "Copy All"  AlertText\BSearch$ = "Search"  AlertText\BSave$   = "Save"  AlertText\SaveAs$  = "Save as"  AlertText\TextFile$ = "TextFile"  AlertText\SearchGadgets\WTitle$ =       "Search"  AlertText\SearchGadgets\Search$ =       "Search:"  AlertText\SearchGadgets\ReplaceTitle$ = "Replace with:"  AlertText\SearchGadgets\Replace$ =      "Replace"  AlertText\SearchGadgets\ReplaceAll$ =   "Replace all"  AlertText\SearchGadgets\Quit$ =         "Quit"  AlertText\SearchGadgets\CaseSensitive$ = "Case sensitive"  AlertText\SearchGadgets\WholeWord$ =    "Whole word"  AlertText\SearchGadgets\InAllDocument$ = "In the entire document"  AlertText\SearchGadgets\UnableToFind$ = "Unable to find"  AlertText\SearchGadgets\ReplacementMade$ = "replacement(s) made."  AlertText\SearchGadgets\SearchFromStart$ = "Search from the end?"  AlertText\SearchGadgets\SearchFromEnd$ =   "Search from the beginning?"  ;  Alert("", AlertText) ; Initialize the names to be used  ; Since no text was provided in the first argument, this call  ; will have no other effect.EndProcedure;InitAlertTexts();;; *************************************************************************************CompilerIf #PB_Compiler_IsMainFile  ; The following won't run when this file is used as 'Included'.  ;  Alert("This a simple message.")  ;  tx$ = "{\rtf1\ansi\ansicpg1252\deff0\nouicompat\deflang1036{\fonttbl{\f0\fnil\fcharset0 Bauhaus 93;}{\f1\fnil\fcharset0 Calibri;}}" + Chr(13)  tx$ + "{\colortbl ;\red192\green80\blue77;}" + Chr(13)  tx$ + "{\*\generator Riched20 10.0.19041}\viewkind4\uc1 " + Chr(13)  tx$ + "\pard\sa200\sl276\slmult1\f0\fs22\lang12 Demonstration \f1\fs28 text \fs22 in \cf1\b\fs28 RTF \cf0\b0\fs22 format.\par" + Chr(13)  tx$ + "}"  Alert(tx$)  ;  tx$ = "This example shows how the 'Alert()' function window is able to automatically resize itself so that it can display "  tx$ + "text of any length without the need to rewrite code each time you need to display a message of particular length." + Chr(13)  tx$ + "There is no limit to the size of the message you can include here." + Chr(13)  tx$ + "The size of the window will be increased as much as possible, then a scrollbar will appear to the right of the text box,"  tx$ + " if the message is too large to fit entirely in the window."  Alert(tx$)  ;  tx$ + Chr(13) + tx$ + Chr(13) + tx$ + Chr(13) + tx$ + Chr(13) + tx$ + Chr(13) + tx$ + Chr(13) + tx$ + Chr(13)  tx$ + Chr(13) + tx$ + Chr(13) + tx$ + Chr(13) + tx$ + Chr(13) + tx$ + Chr(13) + tx$ + Chr(13) + tx$ + Chr(13)  tx$ = "When the printed text is really large, a “search” button automatically appears to allow a search within the text."   + Chr(13) + Chr(13) + Chr(13) + Chr(13) + tx$  Alert(tx$)  ;  tx$ = "A variant of the Alert() function, named AlertYesNoCancel() is intended to replace MessageRequester() with the parameters #PB_MessageRequester_YesNo or #PB_MessageRequester_YesNoCancel." + Chr(13)  tx$ + "It offers exactly the same flexibility As the 'Alert()' function."  AlertYesNoCancel(tx$, "Demonstration")  ;  tx$ + Chr(13) + Chr(13) + "Possible parameters for this variant are:" + Chr(13)  tx$ + "  #AW_AlertOnly" + Chr(13)  tx$ + "  #AW_YesOrNo_YesByDefault" + Chr(13)  tx$ + "  #AW_YesOrNo_NoByDefault" + Chr(13)  tx$ + "  #AW_OKOrCancel_OKByDefault" + Chr(13)  tx$ + "  #AW_OKOrCancel_CancelByDefault" + Chr(13)  tx$ + "  #AW_YesNoOrCancel_YesByDefault" + Chr(13)  tx$ + "  #AW_YesNoOrCancel_NoByDefault" + Chr(13)  tx$ + "  #AW_YesNoOrCancel_CancelByDefault" + Chr(13) + Chr(13)  tx$ + "Here is an exemple of result with #AW_YesNoOrCancel_CancelByDefault" + Chr(13) + Chr(13)  tx$ + "The return values are the same as those of the MessageRequester function." + Chr(13)  AlertYesNoCancel(tx$, "Demonstration", #AW_YesNoOrCancel_CancelByDefault)CompilerEndIf; IDE Options = PureBasic 6.12 LTS (Windows - x86); CursorPosition = 854; FirstLine = 746; Folding = --P4; EnableXP; DPIAware