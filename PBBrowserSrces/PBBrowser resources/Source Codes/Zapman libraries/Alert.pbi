;;- *******************************************************************;;                           'Alert' library;;          An alternative to PureBasic's 'MessageRequester'.;             For Windows only - Zapman, March 2025 - 5;;        This file should be saved under the name "Alert.pbi".;;; This library is organized into five distinct sections:;; 1. 'Language settings' contains functions that manage the multilingual;    aspect of the library. Read the comment at the beginning of this section;    for more details.; 2. 'Miscellaneous functions' includes general functions necessary for the;    library's operation but may also be useful in other contexts.; 3. 'RichEdit_BasicLibrary' contains functions useful for managing 'EditorGadgets';    such as 'RE_FindReplace(),' which, for example, handles the 'Find/Replace';    functionality in an EditorGadget.; 4. 'Alert library' is the main part of this file. This section contains;    the 'Alert()' function, designed as an alternative to the native;    'MessageRequester()' function in PureBasic.; 5. 'Demo' offers a set of demonstrations for the 'Alert()' function.;;; This library is compatible with the Zapman 'ApplyColorThemes.pb' library; that allows you to display your windows in 'Dark Mode' or with other color themes.;; ********************************************************************;;- 1. Language settings;; All Zapman libraries are now designed to be integrated into multilingual applications.; It is entirely possible to redefine the 'GetTextFromCatalog()' function in a file; that precedes this one in your 'IncludedFile' list. This way, you can store the; different translations of the texts used in your application's gadgets in a; different manner.; However, the functions in this section provide a simple (and portable) way to do it,; and if your language is not included in the list of translated languages, only a few; lines need to be added to address this omission (look at the end of this section).;; The translations were provided by ChatGPT from the English version.;Global MyLanguage$If MyLanguage$ = ""  MyLanguage$ = "EN" ; You can set MyLanguage$ to "EN", "RU", "DE", "IT", "ES", "ZH" or "FR".EndIf;CompilerIf Not Defined(LanguageListStructure, #PB_Structure)  Structure LanguageListStructure    Language$    LanguageEntry$    LanguageTranslation$  EndStructure  ;  Global NewList LanguageList.LanguageListStructure()CompilerEndIf;CompilerIf Not Defined(GetTextFromCatalog, #PB_Procedure)  Procedure.s GetTextFromCatalog(SName$)    ForEach LanguageList()      If LanguageList()\Language$ = MyLanguage$ And LCase(LanguageList()\LanguageEntry$) = LCase(SName$)        ProcedureReturn LanguageList()\LanguageTranslation$      EndIf    Next    ProcedureReturn SName$  EndProcedureCompilerEndIf;CompilerIf Not Defined(FillLanguageList, #PB_Procedure)  Procedure FillLanguageList(Language$, LanguageEntry$, LanguageTranslation$)    ;    Protected PosInList = 0, KeyWord$, Found    ;    Repeat      PosInList + 1      KeyWord$ = StringField(LanguageEntry$, PosInList, ",")      Found = 0      ForEach LanguageList()        If LanguageList()\Language$ = Language$ And LCase(LanguageList()\LanguageEntry$) = LCase(KeyWord$)          Found = 1          Break        EndIf      Next      If Found = 0        AddElement(LanguageList())        LanguageList()\Language$ = Language$        LanguageList()\LanguageEntry$ = KeyWord$        LanguageList()\LanguageTranslation$ = StringField(LanguageTranslation$, PosInList, ",")      EndIf    Until KeyWord$ = ""  EndProcedureCompilerEndIf;Define LanguageEntry$ = "SWTitle,SWSearch,SWReplaceTitle,SWReplace,SWReplaceAll,SWCaseSensitive,"       LanguageEntry$ + "SWWholeWord,SWInAllDocument,SWUnableToFind,SWReplacementMade,SWSearchFromStart,"       LanguageEntry$ + "SWSearchFromEnd,Attention,Quit,Yes,No,OK,Cancel,Save,SaveAs,Copy,CopyAll,TextFile,";; ------------- English list of expressions ---------------Define LanguageTranslation$ = "Search,Search:,Replace by:,Replace,Replace all,Case sensitive,"       LanguageTranslation$ + "Whole word,In the entire document,Unable to find,replacement(s) made.,Search from the beginning?,"       LanguageTranslation$ + "Search from the end?,Warning,Quit,Yes,No,OK,Cancel,Save,Save as...,Copy,Copy all,Text Files|*.txt"FillLanguageList("EN", LanguageEntry$, LanguageTranslation$);; ------------- Spanish list of expressions ---------------Define LanguageTranslation$ = "Buscar,Buscar:,Reemplazar por:,Reemplazar,Reemplazar todo,Sensible a mayúsculas,"       LanguageTranslation$ + "Palabra completa,En todo el documento,No se pudo encontrar,reemplazo(s) realizado(s).,¿Buscar desde el principio?,"       LanguageTranslation$ + "¿Buscar desde el final?,Advertencia,Salir,Sí,No,OK,Cancelar,Guardar,Guardar como...,Copiar,Copiar todo,Archivos de texto|*.txt"FillLanguageList("ES", LanguageEntry$, LanguageTranslation$);; ------------- Mandarin list of expressions ---------------Define LanguageTranslation$ = "搜索,搜索:,替换为:,替换,全部替换,区分大小写,"       LanguageTranslation$ + "整词匹配,全文搜索,无法找到,替换成功。,从开头搜索?,"       LanguageTranslation$ + "从结尾搜索?,警告,退出,是,否,确定,取消,保存,另存为...,全部复制,文本文件|*.txt"FillLanguageList("ZH", LanguageEntry$, LanguageTranslation$);; ------------- French list of expressions ---------------       LanguageTranslation$ = "Rechercher,Chercher :,Remplacer par :,Remplacer,Tout remplacer,Respecter la casse,"       LanguageTranslation$ + "Mot entier,Dans tout le document,Impossible de trouver,remplacement(s) effectué(s).,Rechercher depuis le début ?,"       LanguageTranslation$ + "Rechercher depuis la fin ?,Attention,Quitter,Oui,Non,OK,Annuler,Enregistrer,Enregistrer sous...,Copier,Tout copier,Fichiers texte|*.txt"FillLanguageList("FR", LanguageEntry$, LanguageTranslation$);      ; ------------- German list of expressions ---------------          LanguageTranslation$ = "Suchen,Suchen :,Ersetzen durch :,Ersetzen,Alle ersetzen,Groß-/Kleinschreibung beachten,"         LanguageTranslation$ + "Ganzes Wort,Im gesamten Dokument,Keine Treffer,Ersetzung(en) vorgenommen.,Von Anfang an suchen?,"         LanguageTranslation$ + "Von Ende an suchen?,Achtung,Beenden,Ja,Nein,OK,Abbrechen,Speichern,Speichern unter...,Kopieren,Alles kopieren,Textdateien|*.txt"  FillLanguageList("DE", LanguageEntry$, LanguageTranslation$)  ;; ------------- Russian list of expressions ---------------         LanguageTranslation$ = "Найти,Искать :,Заменить на :,Заменить,Заменить всё,Учитывать регистр,"         LanguageTranslation$ + "Целое слово,Во всём документе,Ничего не найдено,замена(ы) выполнена(ы).,Искать с начала?,"         LanguageTranslation$ + "Искать с конца?,Внимание,Выйти,Да,Нет,OK,Отмена,Сохранить,Сохранить как...,Копировать,Копировать всё,Текстовые файлы|*.txt"  FillLanguageList("RU", LanguageEntry$, LanguageTranslation$)       ;; ------------- Italian list of expressions ---------------Define LanguageTranslation$ = "Cerca,Cerca:,Sostituisci con:,Sostituisci,Sostituisci tutto,Sensibile al maiuscolo/minuscolo,"       LanguageTranslation$ + "Parola intera,Nell'intero documento,Impossibile trovare,sostituzione(i) effettuata(e).,Cerca dall'inizio?,"       LanguageTranslation$ + "Cerca dalla fine?,Attenzione,Esci,Sì,No,OK,Annulla,Salva,Salva con nome...,Copia,Copia tutto,File di testo|*.txt"FillLanguageList("IT", LanguageEntry$, LanguageTranslation$);; ------------- Add your own language here --------------;      LanguageTranslation$ = "Expression1,Expression2,etc.";FillLanguageList("XX", LanguageEntry$, LanguageTranslation$) ; and replace "XX" by the abbreviation of your language name.;;;**************************************************************;-               2. Miscellaneous functions;; This section includes general functions necessary for the; library's operation but may also be useful in other contexts.;;**************************************************************;Global PBBAllGadgetsFontIf PBBAllGadgetsFont = 0  PBBAllGadgetsFont = FontID(LoadFont(#PB_Any, "Segoe UI", 9))EndIf;Enumeration CWO_Positioning  #CWO_ActiveWindowPos = -1  #CWO_AbsolutePos     = -2  #CWO_MonitorPos      = -3EndEnumeration;Enumeration CWO_PositionAnchor  #CWO_Center = 0  #CWO_TopLeft  #CWO_TopRight  #CWO_BottomLeft  #CWO_BottomRightEndEnumeration;CompilerIf Not Defined(ComputeWinOrigins, #PB_Procedure)  Procedure ComputeWinOrigins(*OX.Integer, *OY.Integer, WWidth, WHeight, ParentWindow = #CWO_ActiveWindowPos, XShiftOrPos = 0, YShiftOrPos = 0, ParentAnchor = #CWO_Center, WindowAnchor = #CWO_Center)    ;    ; Compute the X and Y origins of a window from its width (WWidth) and height (WHeight)    ; and from the parent window position or from the monitor of the parent window.    ;    ; • If ParentWindow is a valid window number, the new window will be positionned relatively to it,    ;   and then shifted by XShiftOrPos and YShiftOrPos.    ; • If ParentWindow = #CWO_ActiveWindowPos and GetActiveWindow() returns a valid window number,    ;   GetActiveWindow() will be considered as the parent window.    ; • If ParentWindow = #CWO_ActiveWindowPos and GetActiveWindow() does NOT return a valid window number,    ;   the position will be calculated relatively to the main screen.    ; • It ParentWindow = #CWO_AbsolutePos, XShiftOrPos and YShiftOrPos will be the absolute coordinates    ;   of the new window.    ; • If ParentWindow = #CWO_MonitorPos, the position will be calculated relatively to the screen where    ;   GetActiveWindow() is found or relatively to the main screen if GetActiveWindow()    ;   is not a valid window.    ;    ; • The new window will be positionned relatively to the center, top-left, top-right, bottom-left    ;   or bottom-right of the parent window (or monitor), depending on the 'ParentAnchor' parameter.    ;    ; • The anchor of the new window can be the center, top-left, top-right, bottom-left or bottom-right    ;   of the new window, depending on the 'WindowAnchor' parameter.    ;    ; • In all case, except if ParentWindow = #CWO_AbsolutePos, the position of the new window will be    ;   shifted regarding the 'XShiftOrPos' and 'YShiftOrPos' parameters.    ;    Protected DesktopLeft, DesktopRight, DesktopTop, DesktopBottom    Protected ParentWindowID, MFWindow, hMonitor, mi.MONITORINFO    ;    If ParentWindow = #CWO_AbsolutePos      *OX\i = XShiftOrPos      *OY\i = YShiftOrPos      ProcedureReturn 0    EndIf    ;    If ParentWindow = #CWO_ActiveWindowPos And IsWindow(GetActiveWindow())      ; If ParentWindow = #CWO_ActiveWindowPos, use GetActiveWindow() as parent:      ParentWindow = GetActiveWindow()    EndIf    ;    ; Get the screen coordinates for the monitor where the parent window is found:    MFWindow = ParentWindow    If Not(IsWindow(MFWindow))      MFWindow = GetActiveWindow()    EndIf    If IsWindow(MFWindow)      MFWindow = WindowID(MFWindow)    Else      ; If there is no active-window, use the main monitor:      MFWindow = 0    EndIf    ;    hMonitor = MonitorFromWindow_(MFWindow, #MONITOR_DEFAULTTONEAREST)    mi\cbSize = SizeOf(MONITORINFO)    GetMonitorInfo_(hMonitor, @mi)    ;    DesktopLeft   = DesktopUnscaledX(mi\rcWork\left)    DesktopRight  = DesktopUnscaledX(mi\rcWork\Right)    DesktopTop    = DesktopUnscaledY(mi\rcWork\top)    DesktopBottom = DesktopUnscaledY(mi\rcWork\Bottom)    ;    ;____________________________________________    ;    ; Calculate the starting point coordinates:    If IsWindow(ParentWindow)      ParentWindowID = WindowID(ParentWindow)      ;      *OX\i = WindowX(ParentWindow)      *OY\i = WindowY(ParentWindow)      ;      If ParentAnchor = #CWO_Center        *OX\i + WindowWidth(ParentWindow) / 2        *OY\i + WindowHeight(ParentWindow) / 2      ElseIf ParentAnchor = #CWO_TopRight        *OX\i + WindowWidth(ParentWindow)      ElseIf ParentAnchor = #CWO_BottomLeft        *OY\i + WindowHeight(ParentWindow)      ElseIf ParentAnchor = #CWO_BottomRight        *OX\i + WindowWidth(ParentWindow)        *OY\i + WindowHeight(ParentWindow)      EndIf    Else      ;      *OX\i = DeskTopLeft      *OY\i = DesktopTop      ;      If ParentAnchor = #CWO_Center        *OX\i / 2 + DesktopRight / 2        *OY\i / 2 + DesktopBottom / 2      ElseIf ParentAnchor = #CWO_TopRight        *OX\i = DesktopRight      ElseIf ParentAnchor = #CWO_BottomLeft        *OY\i = DesktopBottom      ElseIf ParentAnchor = #CWO_BottomRight        *OX\i = DesktopRight        *OY\i = DesktopBottom      EndIf    EndIf    ;____________________________________________    ;    ; Adjust the final coordinates regarding the new window size:    ;    WHeight + MenuHeight() + 4 ; <-- Calculate the real total height of the new window                               ;     that will be created by "OpenWindow(#PB_Any, OX, OY, WWidth, WHeight..."    If WindowAnchor = #CWO_Center      *OX\i - WWidth / 2      *OY\i - WHeight / 2    ElseIf WindowAnchor = #CWO_TopRight      *OX\i - WWidth    ElseIf WindowAnchor = #CWO_BottomLeft      *OY\i - WHeight    ElseIf WindowAnchor = #CWO_BottomRight      *OX\i - WWidth      *OY\i - WHeight    EndIf    ;    ;____________________________________________    ;    ; Shift the final position:    *OX\i + XShiftOrPos    *OY\i + YShiftOrPos    ;    ; Test if window extends beyond screen bounds due to ParentWindow position or XShiftOrPos or YShiftOrPos:    If *OX\i < DesktopLeft      *OX\i = DesktopLeft + 10    ElseIf *OX\i + WWidth > DesktopRight      *OX\i =  DesktopRight - WWidth - 10    EndIf    If *OY\i < DesktopTop      *OY\i = DesktopTop + 10    ElseIf *OY\i + WHeight > DesktopBottom      *OY\i =  DesktopBottom - WHeight - 10    EndIf    ;    ProcedureReturn ParentWindowID  EndProcedureCompilerEndIf;Procedure ApplyFontToGadgetList(GadgetList$)  Protected PosInGadgetList = 0, Gadget  ;  Repeat    PosInGadgetList + 1    Gadget = Val(StringField(GadgetList$, PosInGadgetList, ","))    If IsGadget(Gadget)      SetGadgetFont(Gadget, PBBAllGadgetsFont)    EndIf  Until StringField(GadgetList$, PosInGadgetList, ",") = ""EndProcedure;Procedure ClearKeyboardBuffer(WindowID = 0)  If IsWindow(WindowID)    While WindowEvent() : Wend  EndIf  Protected msg.MSG  ; Loop to process all pending keyboard messages  While PeekMessage_(@msg, 0, #WM_KEYFIRST, #WM_KEYLAST, #PM_REMOVE)    ; Do nothing, just clear the keyboard messages from the buffer  Wend  ;  Protected Dim keystate.b(256)  Protected i  ; Retrieve the current state of the keyboard  GetKeyboardState_(@keystate())    ; Loop to check all keys  For i = 0 To 255    If keystate(i) & $80      ; Read the state of each key to clear the buffer      While GetAsyncKeyState_(i) & $8000      Wend    EndIf  Next iEndProcedure;Procedure.l GetTextSurfPix(gadget, Text$, *Width.Double, *Height.Double)  ;  ; Returns the pixel dimensions of a text when displayed in the gadget 'gadget'.  ;  If IsGadget(gadget)    Protected Font = GetGadgetFont(Gadget)    Protected Image = CreateImage(#PB_Any, 200, 200)    If Image And StartDrawing(ImageOutput(Image))      DrawingFont(Font)      *Width\d  = DesktopUnscaledX(TextWidth(Text$))      *Height\d = DesktopUnscaledY(TextHeight(Text$))      StopDrawing()      FreeImage(Image)    EndIf  EndIfEndProcedure;Procedure.l GetTextWidthPix(gadget, Text$)  ;  ; Returns the pixel width of a text when displayed in the gadget 'gadget'.  ;  Protected TWidth.d, THeight.d  ;  GetTextSurfPix(gadget, Text$, @TWidth.d, @THeight.d)  ProcedureReturn TWidthEndProcedure;;;**************************************************************;-                 3. RichEdit_BasicLibrary;;             Basic functions for EditorGadgets;            mainly collected on PureBasic forums;             and adapted by Zapman - Dec. 2024;;**************************************************************;Procedure.l RE_StreamStringOutCallback(*dwCookiePtr, pbBuff, cb, pcb)  ;  ; This function is called by 'RE_GetContent_RTF()' to collect  ; the content of an EditorGadget using a 'stream' mecanism.  ;  Protected result, StrPtr, ms  result = 0  If *dwCookiePtr ; Here, *dwCookiePtr is a pointer to a pointer    ;               along time, *dwCookiePtr will allways keep the same value (StrPtr pointer adress)    ;               while the value of StrPtr can change at each iteration.    StrPtr.i = PeekI(*dwCookiePtr)    If StrPtr = 0      StrPtr = AllocateMemory(cb)      CopyMemory(pbBuff, StrPtr, cb)    Else      ms = MemorySize(StrPtr)      StrPtr = ReAllocateMemory(StrPtr, ms + cb)      CopyMemory(pbBuff, StrPtr + ms, cb)    EndIf    PokeI(*dwCookiePtr, StrPtr)    ;  EndIf  PokeL(pcb, cb)  If cb = 0    result = 1  EndIf  ProcedureReturn resultEndProcedure;Procedure.s RE_GetContent_RTF(Gadget, format = #SF_RTF, UseDirectID = 0)  ;  ; Get the content of a RichEdit Gadget  ;  ; Resulting text will be RTF formated if 'format' parameter is undefined.  ; Resulting text will be simple text formated if 'format' parameter is set to zero,  ;     (in that case, resulting text is UTF8 encoded).  ; Resulting text will get whole content of the RichEdit Gadget  ;     or only selected content if 'format' is set To #SF_TEXT|#SFF_SELECTION Or #SF_RTF|#SFF_SELECTION  ;  ;'format' parameter can also be a combination of #SF_RTF and #SF_TEXT with some of the following values:  ; #SFF_PLAINRTF -- If specified, the rich edit control streams out only the keywords common to all languages, ignoring language-specific keywords. If not specified, the rich edit control streams out all keywords. You can combine this flag With the SF_RTF Or SF_RTFNOOBJS flag.  ; #SFF_SELECTION -- If specified, the rich edit control streams out only the contents of the current selection. If Not specified, the control streams out the entire contents. You can combine this flag With any of Data format values.  ; #SF_UNICODE -- Microsoft Rich Edit 2.0 And later: Indicates Unicode text. You can combine this flag With the SF_TEXT flag.  ; #SF_USECODEPAGE -- Rich Edit 3.0 And later: Generates UTF-8 RTF As well As text using other code pages. The code page is set in the high word of wParam. For example, For UTF-8 RTF, set wParam To (CP_UTF8 << 16) | SF_USECODEPAGE | SF_RTF.  ;  Protected edstr.EDITSTREAM, StrPtr, Ghdl  Protected Str$ ; Return value  ;  #SF_USECODEPAGE   = $20  #CP_UTF8      = 65001  ;  If UseDirectID = 0    Ghdl = GadgetID(Gadget)  Else    Ghdl = Gadget  EndIf  ;  If format = 0 Or format & #SF_TEXT : format | (#CP_UTF8 << 16) | #SF_USECODEPAGE | #SF_TEXT : EndIf  ;  StrPtr = 0  edstr\dwCookie.i = @StrPtr ; Here, *dwCookie is a pointer to a pointer.  ;                            Along time, *dwCookie will allways keep the same value (StrPtr pointer adress)  ;                            while the value of StrPtr can change along iterations of RE_StreamStringOutCallback  edstr\pfnCallback = @RE_StreamStringOutCallback()  edstr\dwError = 0  SendMessage_(Ghdl, #EM_STREAMOUT, format, edstr)  If edstr\dwError    Str$ = ""    If StrPtr : FreeMemory(StrPtr) : EndIf  ElseIf StrPtr    Str$ = PeekS(StrPtr, MemorySize(StrPtr), #PB_UTF8 | #PB_ByteLength)    FreeMemory(StrPtr)  EndIf  ProcedureReturn Str$EndProcedure;Procedure.s RE_GetGadgetSelectedText(Gadget, format = #SFF_SELECTION | #SF_TEXT)  ; Get text content of a RichEdit Gadget formated in simple Text$ / UTF8  ProcedureReturn RE_GetContent_RTF(Gadget, format)EndProcedure;Procedure RE_GetSelection(Gadget, *txtrange.CHARRANGE)  ProcedureReturn SendMessage_(GadgetID(Gadget), #EM_EXGETSEL, 0, *txtrange)EndProcedure;Procedure RE_SetSelection(Gadget, PosStart, PosEnd)  ;  Protected txtrange.CHARRANGE\cpMin = PosStart ; Start of selection.   txtrange\cpMax = PosEnd                       ; End of selection  ProcedureReturn SendMessage_(GadgetID(Gadget), #EM_EXSETSEL, 0, @txtrange)  ;EndProcedure;Procedure RE_ReplaceSelection(Gadget, ReplaceString$)  ProcedureReturn SendMessage_(GadgetID(Gadget), #EM_REPLACESEL, 1, @ReplaceString$)EndProcedure;Procedure.s RE_GetGadgetWholeText(Gadget, format = #SF_TEXT)  ; Get text content of a RichEdit Gadget formated in simple Text$ / UTF8  ProcedureReturn RE_GetContent_RTF(Gadget, format)EndProcedure;Procedure RE_SaveContent(Gadget, FileName$, format = #SF_RTF, DelPict = 0)  ; Save content of a RichEdit Gadget formated in UTF8  ; If format is unsetted, the resulting file will content RTF data  ; If 'format' is set To #SF_TEXT|SFF_SELECTION Or #SF_RTF|SFF_SELECTION, only selected text will be saved  ;  Protected ct, p, pr, po, pf, hFile, Result  Protected Content$ = RE_GetContent_RTF(Gadget, format)  ;  If Content$  ; The default color, which appears as black in the REGadget, becomes  ; transparent in the saved file.  ; This needs to be corrected.    Content$ = ReplaceString(Content$, "\red255\green255\blue255", "\red0\green0\blue0")    ;    If DelPict      ; Delete images      ct = 0      Repeat        p = FindString(Content$, "{\pict")        If p          ct = 1          pr = p + 5          Repeat            po = FindString(Content$, "{", pr + 1)            pf = FindString(Content$, "}", pr + 1)            If po And (po < pf Or pf = 0)              pr = po              ct + 1            EndIf            If pf And (pf < po Or po = 0)              pr = pf              ct - 1            EndIf          Until ct = 0 Or (pr = 0 And pf = 0)          If pr            pr + 1            While Mid(Content$, pr, 1) = " " : pr + 1 : Wend            While Mid(Content$, p - 1, 1) = " " : p - 1 : Wend            Content$ = Left(Content$, p - 1) + Mid(Content$, pr)          EndIf        EndIf      Until p = 0    EndIf    ;    ; Open file and write buffer content.    hFile = CreateFile(#PB_Any, Filename$)    ;    If hFile      ; Write content into file.      Result = WriteString(hFile, Trim(Content$))      CloseFile(hFile)    EndIf    ProcedureReturn Result  EndIfEndProcedure;Procedure RE_AdjustZoom(NoGadget, AdjFactor)  ;  Protected num.l, denom.l, Factor.f  ;  ; Obtenir le niveau de zoom actuel  SendMessage_(GadgetID(NoGadget), #EM_GETZOOM, @num, @denom)  ; Calculer le nouveau niveau de zoom  If num And denom    Factor = num / denom  Else    Factor = 1  EndIf  ;  If AdjFactor    Factor * (AdjFactor + 100) / 100  Else    Factor = 1  EndIf  ;  denom = 10  num = denom * Factor  ;  ; Mettre à jour le niveau de zoom  SendMessage_(GadgetID(NoGadget), #EM_SETZOOM, num, denom)EndProcedure;Procedure RE_SearchString(Gadget, SearchString$, MATCHCASE = 0, WHOLEWORD = 0, UP = 0, startPos = -2)  ; By Zapman  ;  ; Will search the string 'SearchString$' into the content of the RichEditGadget 'Gadget'  ; If the Gadget has a selected range of text, the search will be done after the position of the selection  ; (of before, if 'UP' is set to 1).  ; If a value different from '-2' is attributed to 'startpos", the search will be done after the startpos  ; (of before, if 'UP' is set to 1).  ;  ; Returned value is:  ; Position of SearchString$ into the content of the Gadget if string is found;  ; -2 if string is not found, but search have'nt been done on whole the Gadget content;  ; -1 if SearchString$ can't be found into the gagdet content.  ;  ;  If SearchString$ is found, the selection of the Gadget is changed to the position of found text  ;  Protected McpMin, McpMax, NUP, flg, Res  Protected text.FINDTEXT\lpstrText = @SearchString$  ;  If startPos <> -2 ; A start position is given for the search    text\chrg\cpMin = startPos    text\chrg\cpMax = startPos    SendMessage_(GadgetID(Gadget), #EM_EXSETSEL, 0, @text\chrg) ; set the cursor at the given position  EndIf  SendMessage_(GadgetID(Gadget), #EM_EXGETSEL, 0, @text\chrg) ; get the range of the selected text  If (text\chrg\cpMin <> text\chrg\cpMax)    ; Selected text range found, search from the end of it (or from the start, if UP = 1)    If UP = 0      text\chrg\cpMin = text\chrg\cpMax    Else      text\chrg\cpMax = text\chrg\cpMin    EndIf  EndIf  McpMin = text\chrg\cpMin   McpMax = text\chrg\cpMax  text\chrg\cpMax = -1 ; This must be set in all case for a successful search  ;set the search flags  If UP : NUP = 0 : Else : NUP = 1 : EndIf  flg = (MATCHCASE * #FR_MATCHCASE) | (WHOLEWORD * #FR_WHOLEWORD) | (NUP * #FR_DOWN)  Res = SendMessage_(GadgetID(Gadget), #EM_FINDTEXT, flg, @text)  If Res > -1 ; the searched text has been found!!    SendMessage_(GadgetID(Gadget), #EM_SETSEL, Res, Res + Len(SearchString$)) ; select found string into the Gadget  Else    ; If not found, is it possible to extend the search range?    ; If yes, return value will be -2    If UP = 0 And McpMin > 0 : Res = -2 : EndIf    If UP And McpMax <> -1 ; if McpMax was -1, we've yet search from end      text\chrg\cpMin = -1      text\chrg\cpMax = -1      SendMessage_(GadgetID(Gadget), #EM_EXSETSEL, 0, @text\chrg) ; go to the end      SendMessage_(GadgetID(Gadget), #EM_EXGETSEL, 0, @text\chrg) ; get end pos      If McpMax <> text\chrg\cpMax : Res = -2 : EndIf ; compare with last search pos      text\chrg\cpMin = McpMin       text\chrg\cpMax = McpMax      SendMessage_(GadgetID(Gadget), #EM_EXSETSEL, 0, @text\chrg) ; restore first selection    EndIf  EndIf  ProcedureReturn ResEndProcedure: Enumeration REFR_ShortCuts  #REFRShortCut_Quit  #REFRShortCut_Search  #REFRShortCut_TabEndEnumeration;Procedure RE_FindReplace(Gadget, Replace = 0, ParentID = #PB_Default, XShiftOrPos = #PB_Default, YShiftOrPos = #PB_Default, ParentAnchor = #CWO_Center, WindowAnchor = #CWO_Center)  ;  ; by Zapman  ;  ; Open a dialog allowing the user to find or replace a string into the content of a RichEdit Gadget  ; If parameter 'Replace' is omitted or set to zero, only find is possible.  ;  ; • If ParentID is a valid window number, the new window will be positionned relatively to it,  ;   and then shifted by XShiftOrPos and YShiftOrPos.  ; • If ParentID = #CWO_ActiveWindowPos and GetActiveWindow() returns a valid window number,  ;   GetActiveWindow() will be considered as the parent window.  ; • If ParentID = #CWO_ActiveWindowPos and GetActiveWindow() does NOT return a valid window number,  ;   the position will be calculated relatively to the main screen.  ; • It ParentID = #CWO_AbsolutePos, XShiftOrPos and YShiftOrPos will be the absolute coordinates  ;   of the new window.  ; • If ParentID = #CWO_MonitorPos, the position will be calculated relatively to the screen where  ;   GetActiveWindow() is found or relatively to the main screen if GetActiveWindow()  ;   is not a valid window.  ;  ; • The new window will be positionned relatively to the center, top-left, top-right, bottom-left  ;   or bottom-right of the parent window (or monitor), depending on the 'ParentAnchor' parameter.  ;  ; • The anchor of the new window can be the center, top-left, top-right, bottom-left or bottom-right  ;   of the new window, depending on the 'WindowAnchor' parameter.  ;  ; • In all case, except if ParentID = #CWO_AbsolutePos, the position of the new window will be  ;   shifted regarding the 'XShiftOrPos' and 'YShiftOrPos' parameters.  ;  Protected WParam, WWidth, WHeight ; Window format  Protected FRWindow, SearchStringGadget, BPrevious, BNext, VPos, ReplaceStringGadget ; Gadgets  Protected BReplace, BReplaceAll, BQuit, chk1, chk2, chk3                            ; Gadgets  Protected SelectedText$, DoSearch, Event, find.s, RewindSearch  Protected Pos, StartPos, FirstSearch, NbReplace, msg.s  Protected txtrange.CHARRANGE, repl.s  Protected OX, OY, TG1, GadgetList$, TG2  ;  Protected ParentWindow = #PB_Default  If IsWindow(ParentID)    ParentWindow = ParentID    ParentID = WindowID(ParentID)  ElseIf ParentID <> #PB_Default And IsWindow_(ParentID)    ParentWindow = GetProp_(ParentID, "PB_WindowID") - 1  ElseIf IsWindow(GetActiveWindow()) And ParentID = #PB_Default    ParentWindow = GetActiveWindow()    ParentID = WindowID(ParentWindow)  EndIf  If ParentWindow = #PB_Default    ParentWindow = ParentID  EndIf  ;  If Replace    WHeight = 160  Else    WHeight = 120  EndIf  WWidth = 510  If XShiftOrPos = #PB_Default    XShiftOrPos = 400  EndIf  If YShiftOrPos = #PB_Default    YShiftOrPos = 100  EndIf  ;  WParam = #PB_Window_Invisible | #PB_Window_SystemMenu  ;  Protected ParentWindowID = ComputeWinOrigins(@OX, @OY, WWidth, WHeight, ParentWindow, XShiftOrPos, YShiftOrPos, ParentAnchor, WindowAnchor)  FRWindow = OpenWindow(#PB_Any, OX, OY, WWidth, WHeight, GetTextFromCatalog("SWTitle"), WParam, ParentWindowID)  If FRWindow    CompilerIf Defined(ApplyDarkModeToWindow, #PB_Procedure)      ApplyDarkModeToWindow(FRWindow)    CompilerEndIf    StickyWindow(FRWindow, #True)    TG1 = TextGadget(#PB_Any, 10, 20, 100, 22, GetTextFromCatalog("SWSearch"))    GadgetList$ + Str(TG1) + ","    SearchStringGadget = StringGadget(#PB_Any, 100, 15, 300, 25, "")    GadgetList$ + Str(SearchStringGadget) + ","    BPrevious = ButtonGadget(#PB_Any, 410, 15, 35, 26, "<<", #PB_Button_Default)    GadgetList$ + Str(BPrevious) + ","    BNext = ButtonGadget(#PB_Any, 465, 15, 35, 26, ">>", #PB_Button_Default)    GadgetList$ + Str(BNext) + ","    DisableGadget(BNext, #True)    If Replace      VPos = 55      TG2 = TextGadget(#PB_Any, 10, VPos, 100, 22, GetTextFromCatalog("SWReplaceTitle"))      GadgetList$ + Str(TG2) + ","      ReplaceStringGadget = StringGadget(#PB_Any, 100, VPos - 5, 300, 25, "")      GadgetList$ + Str(ReplaceStringGadget) + ","      BReplace = ButtonGadget(#PB_Any, 410, VPos - 5, 90, 26, GetTextFromCatalog("SWReplace"))      GadgetList$ + Str(BReplace) + ","      DisableGadget(BReplace, #True)         BReplaceAll = ButtonGadget(#PB_Any, 410, VPos + 30, 90, 26, GetTextFromCatalog("SWReplaceAll"))      GadgetList$ + Str(BReplaceAll) + ","      DisableGadget(BReplaceAll, #True)    EndIf    BQuit = ButtonGadget(#PB_Any, 410, (WindowHeight(FRWindow) - 33), 90, 26, GetTextFromCatalog("Quit"))    GadgetList$ + Str(BQuit) + ","    VPos = 85    If Replace = 0      VPos - 40    EndIf    chk1 = CheckBoxGadget(#PB_Any, 10, VPos, 135, 26, GetTextFromCatalog("SWCaseSensitive"))    GadgetList$ + Str(chk1) + ","    chk2 = CheckBoxGadget(#PB_Any, 155, VPos, 100, 26, GetTextFromCatalog("SWWholeWord"))    GadgetList$ + Str(chk2) + ","    If Replace      chk3 = CheckBoxGadget(#PB_Any, 255, VPos, 150, 26, GetTextFromCatalog("SWInAllDocument"))      GadgetList$ + Str(chk3) + ","    EndIf    ;    SendMessage_(GadgetID(Gadget), #EM_HIDESELECTION, #False, 0)    ;    ;get any selected text in the richedit    SelectedText$ = RE_GetContent_RTF(Gadget, #SFF_SELECTION | #SF_TEXT)    If Len(SelectedText$) < 128      SetGadgetText(SearchStringGadget, SelectedText$)      ;focus the replace input field      If IsGadget(ReplaceStringGadget) : SetActiveGadget(ReplaceStringGadget) : EndIf      ;enable the buttons      DisableGadget(BNext, #False)      If Replace        DisableGadget(BReplace, #False)        DisableGadget(BReplaceAll, #False)      EndIf    EndIf    ;focus the findstring input field    SetActiveGadget(SearchStringGadget)    ;    AddKeyboardShortcut(FRWindow, #PB_Shortcut_Return, #REFRShortCut_Search)    AddKeyboardShortcut(FRWindow, #PB_Shortcut_Escape, #REFRShortCut_Quit)    AddKeyboardShortcut(FRWindow, #PB_Shortcut_Tab, #REFRShortCut_Tab)    ;    ApplyFontToGadgetList(GadgetList$)    ;    ; ---------------------------------------------------    ;    CompilerIf Defined(SetGadgetsColorsFromTheme, #PB_Procedure)      ;      ; Apply color theme if it exists.      ; The SetGadgetsColorsFromTheme() is defined into the Zapman 'ApplyColorThemes.pb' library      ; and this file must be included by your program before 'Alert.pb' to benefit from color      ; theme support.      ;      If ListSize(InterfaceColorPresets()) > 0        SetGadgetsColorsFromTheme(FRWindow, InterfaceColorPresets(), GadgetList$)      EndIf      ;    CompilerEndIf    ;    ; ---------------------------------------------------    ;    ; The window was invisible until now, because we created it with #PB_Window_Invisible.    ; We make it visible now.    HideWindow(FRWindow, #False)    ;    Repeat      event = WaitWindowEvent()      DoSearch = 0      If EventWindow() <> FRWindow        SetActiveWindow(FRWindow)      Else        If event = #PB_Event_Menu          If EventMenu() = #REFRShortCut_Tab            If GetActiveGadget() = SearchStringGadget              If IsGadget(ReplaceStringGadget)                While WindowEvent() : Wend                SetActiveGadget(ReplaceStringGadget)              EndIf            ElseIf IsGadget(ReplaceStringGadget) And GetActiveGadget() = ReplaceStringGadget              While WindowEvent() : Wend              SetActiveGadget(SearchStringGadget)            EndIf          ElseIf EventMenu() = #REFRShortCut_Search            DoSearch = 1            event = #PB_Event_Gadget          ElseIf EventMenu() = #REFRShortCut_Quit            Break          EndIf        ElseIf event = #PB_Event_CloseWindow          Break          EndIf        If event = #PB_Event_Gadget          If EventGadget() =  BNext            DoSearch = 1          EndIf          If EventGadget() = SearchStringGadget            ;find string            If Len(GetGadgetText(SearchStringGadget))              DisableGadget(BPrevious, #False)              DisableGadget(BNext, #False)              If Replace                DisableGadget(BReplace, #False)                DisableGadget(BReplaceAll, #False)              EndIf            Else              DisableGadget(BPrevious, #True)              DisableGadget(BNext, #True)              If Replace                DisableGadget(BReplace, #True)                DisableGadget(BReplaceAll, #True)              EndIf            EndIf          ElseIf Replace And EventGadget() =  ReplaceStringGadget            ;          ElseIf DoSearch Or EventGadget() = BPrevious Or (Replace And EventGadget() =  BReplace Or EventGadget() =  BReplaceAll)            find.s = GetGadgetText(SearchStringGadget)            If Replace And (EventGadget() =  BReplace Or EventGadget() =  BReplaceAll) ; If replacing...              SendMessage_(GadgetID(Gadget), #EM_EXGETSEL, 0, @txtrange.CHARRANGE) ; RE_GetSelection(Gadget, @txtrange.CHARRANGE)              If (txtrange\cpMin <> txtrange\cpMax) ; if there is a selection, go to the beginning of it                RE_SetSelection(Gadget, txtrange\cpMin, txtrange\cpMax)              EndIf            EndIf            ;            If EventGadget() = BPrevious : RewindSearch = 1 : Else : RewindSearch = 0 : EndIf            ;            StartPos = -2            If IsGadget(chk3) And GetGadgetState(chk3)              ;reset, search from the top (or from the end, if it's a << search)              SetGadgetState(chk3, 0)              If RewindSearch : StartPos = -1 : Else : StartPos = 0 : EndIf            EndIf            ;            FirstSearch = 0            NbReplace = 0            RE_RebootSearch:             FirstSearch + 1            Repeat              pos = RE_SearchString(Gadget, find, GetGadgetState(chk1), GetGadgetState(chk2), RewindSearch, StartPos)              If Replace And pos > -1 And (EventGadget() =  BReplace Or EventGadget() =  BReplaceAll)                repl.s = GetGadgetText(ReplaceStringGadget)                RE_ReplaceSelection(Gadget, repl)                RE_GetSelection(Gadget, @txtrange.CHARRANGE)                txtrange\cpMin = txtrange\cpMax - Len(repl)                If EventGadget() =  BReplaceAll Or (EventGadget() =  BReplace And FindString(repl, find, 0))                  txtrange\cpMin = txtrange\cpMax                EndIf                RE_SetSelection(Gadget, txtrange\cpMin, txtrange\cpMax)                NbReplace + 1              EndIf            Until EventGadget() <>  BReplaceAll Or pos < 0 Or Replace = 0            If pos = -2 ; String not found, but it is possible to extend the search range              If NbReplace = 0                msg.s = GetTextFromCatalog("SWUnableToFind") + " " + find + #CRLF$              Else                msg = ""                If EventGadget() =  BReplaceAll                  msg.s = Str(NbReplace) + " " + GetTextFromCatalog("SWReplacementMade") + #CRLF$                EndIf              EndIf              If RewindSearch                msg + GetTextFromCatalog("SWSearchFromEnd")                StartPos = -1              Else                msg + GetTextFromCatalog("SWSearchFromStart")                StartPos = 0              EndIf              If MessageRequester(GetTextFromCatalog("SWTitle"), msg, #PB_MessageRequester_YesNo) =  #PB_MessageRequester_Yes                Goto RE_RebootSearch                SetActiveGadget(Gadget)              EndIf            EndIf            ;            msg.s = ""            If Replace And EventGadget() =  BReplaceAll              msg.s = Str(NbReplace) + " " + GetTextFromCatalog("SWReplacementMade")            ElseIf pos = -1              msg.s = GetTextFromCatalog("SWUnableToFind") + " " + find            EndIf            If msg              MessageRequester(GetTextFromCatalog("SWTitle"), msg, #PB_MessageRequester_Ok)              SetActiveGadget(Gadget)            EndIf          EndIf          If EventGadget() =  BQuit            Break          EndIf        EndIf        ;      EndIf      SetForegroundWindow_(WindowID(FRWindow))      SetActiveWindow(FRWindow)    ForEver    CloseWindow(FRWindow)  EndIfEndProcedure;;*************************************************;;-                4. Alert library ;;*************************************************;Structure AlertWindowGList  WindowNum.i  Margins.i  BHeight.i  BWidth.i  CopyMenu.i  ;  RE_gadget.i  YesNoCancel.i  BOK.i  BCancel.i  BYes.i  BNo.i  BSearch.i  BCopy.i  BSave.iEndStructure;Enumeration AlertYesNoCancel  #AW_AlertOnly  #AW_YesOrNo_YesByDefault  #AW_YesOrNo_NoByDefault  #AW_OKOrCancel_OKByDefault  #AW_OKOrCancel_CancelByDefault  #AW_YesNoOrCancel_YesByDefault  #AW_YesNoOrCancel_NoByDefault  #AW_YesNoOrCancel_CancelByDefaultEndEnumeration;Procedure ResizeAlertWindow()  ;  Shared AlertGList.AlertWindowGList ; Pour le partage des numéros de gadgets.  ;  Protected WWidth, WHeight, Margins, LowBPos, YesNoCancel  ;  WWidth  = WindowWidth(AlertGList\WindowNum)  WHeight = WindowHeight(AlertGList\WindowNum)  Margins = AlertGList\Margins  LowBPos = WHeight - AlertGList\BHeight - Margins  YesNoCancel = AlertGList\YesNoCancel  ;  ResizeGadget(AlertGList\RE_gadget,  #PB_Ignore, #PB_Ignore, (WWidth - Margins * 2), (WHeight - AlertGList\BHeight - Margins * 3))  ;  ; Bouton occupant la position la plus à droite :  If IsGadget(AlertGList\BOK) And (YesNoCancel = #AW_AlertOnly Or YesNoCancel = #AW_OKOrCancel_OKByDefault)    ResizeGadget(AlertGList\BOK,        WWidth - AlertGList\BWidth - Margins,     LowBPos, #PB_Ignore, #PB_Ignore)  EndIf  If IsGadget(AlertGList\BYes) And (YesNoCancel = #AW_YesOrNo_YesByDefault Or YesNoCancel = #AW_YesNoOrCancel_YesByDefault)    ResizeGadget(AlertGList\BYes,       WWidth - AlertGList\BWidth - Margins,     LowBPos, #PB_Ignore, #PB_Ignore)  EndIf  If IsGadget(AlertGList\BNo) And (YesNoCancel = #AW_YesOrNo_NoByDefault Or YesNoCancel = #AW_YesNoOrCancel_NoByDefault)    ResizeGadget(AlertGList\BNo,        WWidth - AlertGList\BWidth - Margins,     LowBPos, #PB_Ignore, #PB_Ignore)  EndIf  If IsGadget(AlertGList\BCancel) And (YesNoCancel = #AW_OKOrCancel_CancelByDefault Or YesNoCancel = #AW_YesNoOrCancel_CancelByDefault)    ResizeGadget(AlertGList\BCancel,    WWidth - AlertGList\BWidth - Margins,     LowBPos, #PB_Ignore, #PB_Ignore)  EndIf  ;  ; Bouton occupant la deuxième position à partir de la droite  If IsGadget(AlertGList\BOK) And (YesNoCancel = #AW_OKOrCancel_CancelByDefault)    ResizeGadget(AlertGList\BOK,        WWidth - (AlertGList\BWidth + Margins) * 2, LowBPos, #PB_Ignore, #PB_Ignore)  EndIf  If IsGadget(AlertGList\BYes) And (YesNoCancel = #AW_YesOrNo_NoByDefault Or YesNoCancel = #AW_YesNoOrCancel_NoByDefault)    ResizeGadget(AlertGList\BYes,       WWidth - (AlertGList\BWidth + Margins) * 2, LowBPos, #PB_Ignore, #PB_Ignore)  EndIf  If IsGadget(AlertGList\BNo) And (YesNoCancel = #AW_YesOrNo_YesByDefault Or YesNoCancel = #AW_YesNoOrCancel_YesByDefault Or YesNoCancel = #AW_YesNoOrCancel_CancelByDefault)    ResizeGadget(AlertGList\BNo,        WWidth - (AlertGList\BWidth + Margins) * 2, LowBPos, #PB_Ignore, #PB_Ignore)  EndIf  If IsGadget(AlertGList\BCancel) And YesNoCancel = #AW_OKOrCancel_OKByDefault    ResizeGadget(AlertGList\BCancel,    WWidth - (AlertGList\BWidth + Margins) * 2, LowBPos, #PB_Ignore, #PB_Ignore)  EndIf  ;  ; Bouton occupant la troisième position à partir de la droite  If IsGadget(AlertGList\BYes) And YesNoCancel = #AW_YesNoOrCancel_CancelByDefault    ResizeGadget(AlertGList\BYes,       WWidth - (AlertGList\BWidth + Margins) * 3, LowBPos, #PB_Ignore, #PB_Ignore)  EndIf  If IsGadget(AlertGList\BCancel) And (YesNoCancel = #AW_YesNoOrCancel_YesByDefault Or YesNoCancel = #AW_YesNoOrCancel_NoByDefault)    ResizeGadget(AlertGList\BCancel,    WWidth - (AlertGList\BWidth + Margins) * 3, LowBPos, #PB_Ignore, #PB_Ignore)  EndIf  ;    If IsGadget(AlertGList\BCopy) And YesNoCancel = #AW_AlertOnly    ResizeGadget(AlertGList\BCopy,      WWidth - (AlertGList\BWidth + Margins) * 2, LowBPos, #PB_Ignore, #PB_Ignore)    ResizeGadget(AlertGList\BSave,      WWidth - (AlertGList\BWidth + Margins) * 3, LowBPos, #PB_Ignore, #PB_Ignore)    ResizeGadget(AlertGList\BSearch,    WWidth - (AlertGList\BWidth + Margins) * 4, LowBPos, #PB_Ignore, #PB_Ignore)    ;    If WWidth < (AlertGList\BWidth + Margins) * 3 + Margins      HideGadget(AlertGList\BCopy,   #True)      HideGadget(AlertGList\BSave,   #True)      HideGadget(AlertGList\BSearch, #True)    ElseIf WWidth < (AlertGList\BWidth + Margins) * 4 + Margins      HideGadget(AlertGList\BCopy,   #False)      HideGadget(AlertGList\BSave,   #False)      HideGadget(AlertGList\BSearch, #True)    Else      HideGadget(AlertGList\BCopy,   #False)      HideGadget(AlertGList\BSave,   #False)      ;      ; On décide arbitrairement que les textes dont la longeur est inférieure      ; à 160000 caractères n'ont pas besoin d'un outil de recherche.      If (GadgetWidth(AlertGList\RE_gadget) * GadgetHeight(AlertGList\RE_gadget)) < 160000        HideGadget(AlertGList\BSearch, #True)      Else        HideGadget(AlertGList\BSearch, #False)      EndIf    EndIf  EndIfEndProcedure;Enumeration AlertWShortcuts  #AW_Shortcut_Quit  #AW_Shortcut_DefButton  #AW_Shortcut_Search  #AW_Shortcut_Save  #AW_MenuCopy  #AW_MenuCopyAllEndEnumeration;#RTF_Marker = 23675;Procedure THG(EventGadget, Gadget)  ; Test Hyphotetical GagdetEvent  If IsGadget(Gadget) And EventGadget = Gadget    ProcedureReturn #True  EndIfEndProcedure;Procedure Alert(Message$, WindowTitle$ = "", WSticky = 1, WhiteBackGround = 0, Txtleft = 0, FixedWidth = 0, TabList$ = "", YesNoCancel = #AW_AlertOnly, ParentID = #PB_Default, XShiftOrPos = 0, YShiftOrPos = 0, ParentAnchor = #CWO_Center, WindowAnchor = #CWO_Center)  ;  ; Displays the message 'Message$' in a window whose dimensions are optimized  ; according to the size of the message.  ;  ; The window also includes 'Copy', 'Save', and for  ; large texts, a 'Search' button that allows searching  ; within the displayed text.  ;  ; • If WhiteBackGround contains a non-zero value, the text background will be white instead of yellow.  ; • If TxtLeft contains a non-zero value, the text will always be left-aligned.  ; • If FixedWidth contains a non-zero value, the window width will conform to its value.  ; • TabList$ can contain a list of tab positions in the form "pos1,pos2,pos3"  ; • YesNoCancel can contain one of the values from the 'AlertYesNoCancel' enumeration, in which case  ;   the buttons 'Yes', 'No', or 'OK' and 'Cancel' will appear in the window.  ;  ; • If ParentID is a valid window number, the new window will be positionned relatively to it,  ;   and then shifted by XShiftOrPos and YShiftOrPos.  ; • If ParentID = #CWO_ActiveWindowPos and GetActiveWindow() returns a valid window number,  ;   GetActiveWindow() will be considered as the parent window.  ; • If ParentID = #CWO_ActiveWindowPos and GetActiveWindow() does NOT return a valid window number,  ;   the position will be calculated relatively to the main screen.  ; • It ParentID = #CWO_AbsolutePos, XShiftOrPos and YShiftOrPos will be the absolute coordinates  ;   of the new window.  ; • If ParentID = #CWO_MonitorPos, the position will be calculated relatively to the screen where  ;   GetActiveWindow() is found or relatively to the main screen if GetActiveWindow()  ;   is not a valid window.  ;  ; • The new window will be positionned relatively to the center, top-left, top-right, bottom-left  ;   or bottom-right of the parent window (or monitor), depending on the 'ParentAnchor' parameter.  ;  ; • The anchor of the new window can be the center, top-left, top-right, bottom-left or bottom-right  ;   of the new window, depending on the 'WindowAnchor' parameter.  ;  ; • In all case, except if ParentID = #CWO_AbsolutePos, the position of the new window will be  ;   shifted regarding the 'XShiftOrPos' and 'YShiftOrPos' parameters.  ;  ;  ; • The return value can be #PB_MessageRequester_Yes, #PB_MessageRequester_No, or #PB_MessageRequester_Cancel  ;  Shared AlertGList.AlertWindowGList ; For sharing gadget numbers with the Resize procedure                                     ;  Protected ParentWindow = #PB_Default  If IsWindow(ParentID)    ParentWindow = ParentID    ParentID = WindowID(ParentID)  ElseIf ParentID <> #PB_Default And IsWindow_(ParentID)    ParentWindow = GetProp_(ParentID, "PB_WindowID") - 1  ElseIf IsWindow(GetActiveWindow()) And ParentID = #PB_Default    ParentWindow = GetActiveWindow()    ParentID = WindowID(ParentWindow)  EndIf  If ParentWindow = #PB_Default    ParentWindow = ParentID  EndIf  ;  Protected WWidth, WHeight, RTF, hMonitor, mi.MONITORINFO  Protected TextSurf, TW.d, TH.d, ratio.f, SL  Protected OX, OY  Protected EventID, QuitAll, NFile$  Protected *tabStops, PosInList, TabPos$  Protected *mem, BDefault  Protected BoundWidthMin, BoundHeightMin, BoundWidthMax, BoundHeightMax  Protected iGwlStyle, *GadgetAdress, GadgetList$, EventGadget  ;  If WindowTitle$ = "" : WindowTitle$ = GetTextFromCatalog("Attention") : EndIf  ;  If Message$    WWidth = 250    If FixedWidth      WWidth = FixedWidth    EndIf    WHeight = 100    ;    If PeekC(@Message$) = #RTF_Marker      ; The text to be displayed comes from a saved UTF8/RTF file.      RTF = 1    ElseIf LCase(Left(Message$, 5)) = "{\rtf" Or LCase(Left(Message$, 6)) = "{\urtf"      ; The text to be displayed is encoded in Unicode/RTF.      RTF = 2    Else      RTF = 0    EndIf    ;    Protected WParam = #PB_Window_Invisible | #PB_Window_MinimizeGadget | #PB_Window_MaximizeGadget | #PB_Window_SystemMenu | #PB_Window_SizeGadget | #PB_Window_TitleBar    Protected ActiveWindow = ParentWindow    If Not(IsWindow(ActiveWindow))      ActiveWindow = GetActiveWindow()    EndIf    Protected ParentWindowID = ComputeWinOrigins(@OX, @OY, WWidth, WHeight, ParentWindow, XShiftOrPos, YShiftOrPos, ParentAnchor, WindowAnchor)    ;    AlertGList\WindowNum = OpenWindow(#PB_Any, OX, OY, WWidth, WHeight, WindowTitle$, WParam, ParentWindowID)    ;        If IsWindow(AlertGList\WindowNum)      If IsWindow(ActiveWindow) And IsWindowEnabled_(WindowID(ActiveWindow))        DisableWindow(ActiveWindow, #True)        Protected ParentHasBeenDisabled = #True      EndIf      BoundWidthMin = WWidth      BoundHeightMin = WHeight      ;      hMonitor = MonitorFromWindow_(WindowID(AlertGList\WindowNum), #MONITOR_DEFAULTTONEAREST)      mi\cbSize = SizeOf(MONITORINFO)      GetMonitorInfo_(hMonitor, @mi)      BoundWidthMax  = DesktopUnscaledX(mi\rcWork\Right - mi\rcWork\left) - 80      BoundHeightMax = DesktopUnscaledY(mi\rcWork\Bottom - mi\rcWork\top) - 80      ;      WindowBounds(AlertGList\WindowNum, BoundWidthMin, BoundHeightMin, #PB_Ignore, #PB_Ignore)      ;      CompilerIf Defined(ApplyDarkModeToWindow, #PB_Procedure)        ApplyDarkModeToWindow(AlertGList\WindowNum)      CompilerEndIf      ;      If WSticky        StickyWindow(AlertGList\WindowNum, 1)      EndIf      AlertGList\BHeight = 24      AlertGList\BWidth = 90      AlertGList\Margins = 8      AlertGList\YesNoCancel = YesNoCancel      ;      AlertGList\RE_gadget = EditorGadget(#PB_Any, AlertGList\Margins, AlertGList\Margins, 1, 1)      SendMessage_(GadgetID(AlertGList\RE_gadget), #EM_SETTARGETDEVICE, #Null, 0); <<--- automatic line break      SendMessage_(GadgetID(AlertGList\RE_gadget), #EM_LIMITTEXT, -1, 0)         ; set unlimited content size      SendMessage_(GadgetID(AlertGList\RE_gadget), #EM_SETTEXTMODE, #TM_RICHTEXT, 0) ; enable rich text mode for EditorGadget      If TabList$        RE_SetSelection(AlertGList\RE_gadget, 0, -1)        ; The 'TabList$' parameter contains the list of tab positions to place in the REgadget:        ; This list must have the form "pos1,pos2,pos3".        ; We will convert this list format into a series of WORD values,        ; stored in a memory area, in order to use it in a SendMessage_().        ;        ; We count the number of commas, adding 1, then multiply by 4        ; because the size of a WORD is 4 bytes:        *tabStops = AllocateMemory((CountString(TabList$, ",") + 1) * 4)        ;        PosInList = 0        Repeat          PosInList + 1          TabPos$ = StringField(TabList$, PosInList, ",")          If TabPos$            PokeW(*tabStops + 4 * (PosInList - 1), Val(TabPos$))          EndIf        Until TabPos$ = ""        SendMessage_(GadgetID(AlertGList\RE_gadget), #EM_SETTABSTOPS, CountString(TabList$, ",") + 1, *tabStops)        FreeMemory(*tabStops)      EndIf      ;      If RTF = 2        *mem = AllocateMemory(StringByteLength(Message$, #PB_UTF8) + 1)        PokeS(*mem, Message$, -1, #PB_UTF8) ; write the string in UTF8        ; then we read the string in Unicode and insert it into the Gadget        SendMessage_(GadgetID(AlertGList\RE_gadget), #EM_REPLACESEL, 0, PeekS(*mem, -1, #PB_Unicode))        FreeMemory(*mem)      Else        SendMessage_(GadgetID(AlertGList\RE_gadget), #EM_REPLACESEL, 0, @Message$)      EndIf      SendMessage_(GadgetID(AlertGList\RE_gadget), #EM_SETREADONLY, #True, 0)      ;      If YesNoCancel = #AW_AlertOnly Or YesNoCancel = #AW_OKOrCancel_OKByDefault Or YesNoCancel = #AW_OKOrCancel_CancelByDefault        If YesNoCancel = #AW_AlertOnly Or YesNoCancel = #AW_OKOrCancel_OKByDefault          BDefault = 1        Else          BDefault = 0        EndIf        AlertGList\BOK = ButtonGadget(#PB_Any, 1, 1, AlertGList\BWidth, AlertGList\BHeight, GetTextFromCatalog("OK"), #PB_Button_Default * BDefault)      EndIf      If YesNoCancel = #AW_OKOrCancel_OKByDefault Or YesNoCancel = #AW_OKOrCancel_CancelByDefault Or YesNoCancel = #AW_YesNoOrCancel_YesByDefault Or YesNoCancel = #AW_YesNoOrCancel_NoByDefault Or YesNoCancel = #AW_YesNoOrCancel_CancelByDefault        If YesNoCancel = #AW_OKOrCancel_CancelByDefault Or YesNoCancel = #AW_YesNoOrCancel_CancelByDefault          BDefault = 1        Else          BDefault = 0        EndIf        AlertGList\BCancel = ButtonGadget(#PB_Any, 1, 1, AlertGList\BWidth, AlertGList\BHeight, GetTextFromCatalog("Cancel"), #PB_Button_Default * BDefault)      EndIf      If YesNoCancel = #AW_YesOrNo_YesByDefault Or YesNoCancel = #AW_YesOrNo_NoByDefault Or YesNoCancel = #AW_YesNoOrCancel_YesByDefault Or YesNoCancel = #AW_YesNoOrCancel_NoByDefault Or YesNoCancel = #AW_YesNoOrCancel_CancelByDefault        If YesNoCancel = #AW_YesOrNo_YesByDefault Or YesNoCancel = #AW_YesNoOrCancel_YesByDefault          BDefault = 1        Else          BDefault = 0        EndIf        AlertGList\BYes = ButtonGadget(#PB_Any, 1, 1, AlertGList\BWidth, AlertGList\BHeight, GetTextFromCatalog("Yes"), #PB_Button_Default * BDefault)        ;        If YesNoCancel = #AW_YesOrNo_NoByDefault Or YesNoCancel = #AW_YesNoOrCancel_NoByDefault          BDefault = 1        Else          BDefault = 0        EndIf        AlertGList\BNo  = ButtonGadget(#PB_Any, 1, 1, AlertGList\BWidth, AlertGList\BHeight, GetTextFromCatalog("No"), #PB_Button_Default * BDefault)      EndIf      If YesNoCancel = #AW_AlertOnly        AlertGList\BCopy   = ButtonGadget(#PB_Any, 1, 1, AlertGList\BWidth, AlertGList\BHeight, GetTextFromCatalog("Copy"))        AlertGList\BSave   = ButtonGadget(#PB_Any, 1, 1, AlertGList\BWidth, AlertGList\BHeight, GetTextFromCatalog("Save"))        AlertGList\BSearch = ButtonGadget(#PB_Any, 1, 1, AlertGList\BWidth, AlertGList\BHeight, GetTextFromCatalog("SWTitle"))      EndIf      ;      ; If the message was in RTF, Get its plain text equivalent.      Message$ = ReplaceString(GetGadgetText(AlertGList\RE_gadget), #LF$, "")      ;      ; We will attempt to resize the window based on      ; the size of the text.      ;      ; Calculate the display area required based on      ; the length of the text:      ; Retrieve the text dimensions:      RE_SetSelection(AlertGList\RE_gadget, 0, -1)      GetTextSurfPix(AlertGList\RE_gadget, Message$, @TW, @TH)      ; Calculate the display area and inflate it slightly by      ; multiplying by 1.4. The result is approximate because line breaks      ; are counted as regular characters, whereas they actually reduce the display area.      ; Also, if the message was in RTF and contains images, each image is counted as a single      ; character, even though the image may take up a lot of space.      ; This gives us an approximation.      ;      TextSurf = TW * TH * 1.4      ;      If RTF = 0        ; Slight formatting for non-RTF text:        ;        If TextSurf < 50000 And Txtleft = 0 And TabList$ = ""          ; If the text is short, center it.          Protected paraFormat.PARAFORMAT2          paraFormat\cbSize = SizeOf(PARAFORMAT2)          paraFormat\dwMask = #PFM_ALIGNMENT          paraFormat\wAlignment = #PFA_CENTER          SendMessage_(GadgetID(AlertGList\RE_gadget), #EM_SETPARAFORMAT, #SCF_SELECTION, @paraFormat)        EndIf        ;        ; Add small margins on the left and right,        ; so the text is not glued to the edges.        Protected format.PARAFORMAT        format\cbSize = SizeOf(PARAFORMAT)        format\dwMask = #PFM_RIGHTINDENT | #PFM_OFFSETINDENT        format\dxStartIndent = 100        format\dxRightIndent = 100        SendMessage_(GadgetID(AlertGList\RE_gadget), #EM_SETPARAFORMAT, #SCF_SELECTION, @format)        ;      EndIf      ;      AW_ComputeWidthAndHeightFromSurf:       ;      If FixedWidth        WWidth = FixedWidth        SL = 0      Else        If TextSurf = 0          ; This can happen on older Windows systems          TextSurf = 400 * 500        EndIf        ; Recalculate the window dimensions:        ; Since TextSurf is an area, we extract its square root        ; to get an idea of its side length.        WWidth = Sqr(TextSurf)        ;        ; We will now decide on a width/height ratio based on        ; the idea that smaller windows should be wider than        ; they are tall, and larger ones, taller than wide.        ratio = 1 + (800 - WWidth) / 1600        If ratio < 1          WWidth = 800        Else          WWidth * ratio * 1.2        EndIf        ;        SL = 0        ; Compare the calculated width to the screen limits        ; and readability constraints. When a window is too wide,        ; the text it contains is hard to read.        If WWidth > 800 : WWidth = 800 : SL = 1 : EndIf        ;        If WWidth > BoundWidthMax : WWidth = BoundWidthMax : SL = 1 : EndIf        If WWidth < BoundWidthMin : WWidth = BoundWidthMin : EndIf      EndIf      ;      ; Height is equal to the surface divided by the width:      WHeight = TextSurf / WWidth      If WHeight > BoundHeightMax : WHeight = BoundHeightMax : SL = 1 : EndIf      If WHeight < BoundHeightMin : WHeight = BoundHeightMin : EndIf      ;      ; Center the window to the screen:      ComputeWinOrigins(@OX, @OY, WWidth, WHeight, ParentWindow, XShiftOrPos, YShiftOrPos, ParentAnchor, WindowAnchor)      ;      ResizeWindow(AlertGList\WindowNum, OX, OY, WWidth, WHeight)      ;      ; Resize the gadgets based on the new window size      ResizeAlertWindow()      ;      If SL = 0        ; The calculated dimensions have not exceeded the screen limits        ; and we still have the possibility to enlarge the window if necessary.        ; We will check if the window scrollbar has activated, which        ; would mean that the current dimensions are insufficient to        ; display all the text.        ;        ; Test if scrollbar is visible:        iGwlStyle = GetWindowLongPtr_(GadgetID(AlertGList\RE_gadget), #GWL_STYLE)        If (iGwlStyle & #WS_VSCROLL)          ; The scrollbar has been activated.          ; Enlarge the previously estimated surface          ; by adding a line height multiplied by the window width.          TextSurf + TH * WWidth          Goto AW_ComputeWidthAndHeightFromSurf        EndIf      EndIf      ;      ; The window size calculation is complete.      ;      ; Clear the selection:      RE_SetSelection(AlertGList\RE_gadget, 0, 0)      ;      ; Establish the list of gadgets to colorize:      *GadgetAdress = @AlertGList\YesNoCancel      Repeat        GadgetList$ + Str(PeekI(*GadgetAdress)) + ","        *GadgetAdress + SizeOf(Integer)      Until *GadgetAdress > @AlertGList\BSave      ;      ApplyFontToGadgetList(GadgetList$)      ;      GadgetList$ + Str(AlertGList\RE_gadget) + ","      ;      ; ---------------------------------------------------      ;      CompilerIf Defined(SetGadgetsColorsFromTheme, #PB_Procedure)        ;        ; Apply color theme if it exists.        ; The SetGadgetsColorsFromTheme() is defined into the Zapman 'ApplyColorThemes.pb' library        ; and this file must be included by your program before 'Alert.pb' to benefit from color        ; theme support.        ;        If ListSize(InterfaceColorPresets()) > 0          SetGadgetsColorsFromTheme(AlertGList\WindowNum, InterfaceColorPresets(), GadgetList$)          If InterfaceColorPresets()\BackgroundColor <> -1            WhiteBackGround = 1          EndIf        EndIf        ;      CompilerEndIf      ;      ; ---------------------------------------------------      ;      If WhiteBackGround = 0        SetGadgetColor(AlertGList\RE_gadget, #PB_Gadget_BackColor, $F0FDFD)      EndIf      ;      ; The window was invisible until now, because we created it with #PB_Window_Invisible.      ; We make it visible now.      HideWindow(AlertGList\WindowNum, #False)      ;      ; If despite all the effort we've put in, the user wants to resize      ; the window themselves, we give them the option:      BindEvent(#PB_Event_SizeWindow, @ResizeAlertWindow(), AlertGList\WindowNum)      ;      AddKeyboardShortcut(AlertGList\WindowNum, #PB_Shortcut_Return, #AW_Shortcut_DefButton)      AddKeyboardShortcut(AlertGList\WindowNum, #PB_Shortcut_Escape, #AW_Shortcut_Quit)      AddKeyboardShortcut(AlertGList\WindowNum, #PB_Shortcut_Control | #PB_Shortcut_F, #AW_Shortcut_Search)      AddKeyboardShortcut(AlertGList\WindowNum, #PB_Shortcut_Control | #PB_Shortcut_S, #AW_Shortcut_Save)      ;      AlertGList\CopyMenu = CreatePopupMenu(#PB_Any)      MenuItem(#AW_MenuCopy,    GetTextFromCatalog("Copy"))      MenuItem(#AW_MenuCopyAll, GetTextFromCatalog("CopyAll"))      ;      CompilerIf Defined(ApplyThemesToMenu, #PB_Procedure)        ApplyThemesToMenu(AlertGList\CopyMenu)      CompilerEndIf      ;      ClearKeyboardBuffer(AlertGList\WindowNum)      ;      Repeat        EventID = WaitWindowEvent()        If EventWindow() <> AlertGList\WindowNum And WSticky          SetActiveWindow(AlertGList\WindowNum)        Else          If EventID = #PB_Event_Gadget            EventGadget = EventGadget()          ElseIf EventID = #PB_Event_CloseWindow            QuitAll = #PB_MessageRequester_Cancel          ElseIf EventID = #PB_Event_Menu            If EventMenu() = #AW_Shortcut_Quit              QuitAll = #PB_MessageRequester_Cancel            ElseIf EventMenu() =   #AW_Shortcut_DefButton              If YesNoCancel = #AW_YesOrNo_YesByDefault Or YesNoCancel = #AW_YesNoOrCancel_YesByDefault Or YesNoCancel = #AW_OKOrCancel_OKByDefault                QuitAll = #PB_MessageRequester_Yes              ElseIf YesNoCancel = #AW_YesOrNo_NoByDefault Or YesNoCancel = #AW_YesNoOrCancel_NoByDefault                QuitAll = #PB_MessageRequester_No              Else                QuitAll = #PB_MessageRequester_Cancel              EndIf            ElseIf EventMenu() = #AW_Shortcut_Search              EventID = #PB_Event_Gadget              EventGadget = AlertGList\BSearch            ElseIf EventMenu() = #AW_Shortcut_Save              EventID = #PB_Event_Gadget              EventGadget = AlertGList\BSave            ElseIf EventMenu() = #AW_MenuCopy              SetClipboardText(RE_GetGadgetSelectedText(AlertGList\RE_gadget))            ElseIf EventMenu() = #AW_MenuCopyAll              SetClipboardText(RE_GetGadgetWholeText(AlertGList\RE_gadget))              RE_SetSelection(AlertGList\RE_gadget, 0, -1)            EndIf          EndIf          If EventID = #PB_Event_Gadget            If THG(EventGadget, AlertGList\BOK) Or THG(EventGadget, AlertGList\BYes)              QuitAll = #PB_MessageRequester_Yes            ElseIf THG(EventGadget, AlertGList\BCancel)              QuitAll = #PB_MessageRequester_Cancel            ElseIf THG(EventGadget, AlertGList\BNo)              QuitAll = #PB_MessageRequester_No            ElseIf THG(EventGadget, AlertGList\BSearch)              RE_FindReplace(AlertGList\RE_gadget, 0, AlertGList\WindowNum)            ElseIf THG(EventGadget, AlertGList\BCopy)              If RE_GetGadgetSelectedText(AlertGList\RE_gadget)                DisplayPopupMenu(AlertGList\CopyMenu, WindowID(AlertGList\WindowNum))              Else                SetClipboardText(RE_GetGadgetWholeText(AlertGList\RE_gadget))                RE_SetSelection(AlertGList\RE_gadget, 0, -1)              EndIf            ElseIf THG(EventGadget, AlertGList\BSave)              NFile$ = SaveFileRequester(GetTextFromCatalog("SaveAs"), "", GetTextFromCatalog("TextFile"), 1)              If NFile$                If GetExtensionPart(NFile$) <> "txt" : NFile$ + ".txt" : EndIf                RE_SaveContent(AlertGList\RE_gadget, NFile$, 0)              EndIf            EndIf          EndIf        EndIf      Until QuitAll    EndIf    If IsWindow(AlertGList\WindowNum)      ClearKeyboardBuffer(AlertGList\WindowNum)      CloseWindow(AlertGList\WindowNum)    EndIf  EndIf  ;  If ParentHasBeenDisabled    DisableWindow(ActiveWindow, #False)  EndIf  ProcedureReturn QuitAllEndProcedure;Procedure AlertYesNoCancel(Message$, Title$ = "", Type = #AW_YesOrNo_YesByDefault, ParentID = #PB_Default, XShiftOrPos = 0, YShiftOrPos = 0)  ;  ; 'Type' can have one of the followwing value:  ; #AW_AlertOnly  ; #AW_YesOrNo_YesByDefault  ; #AW_YesOrNo_NoByDefault  ; #AW_OKOrCancel_OKByDefault  ; #AW_OKOrCancel_CancelByDefault  ; #AW_YesNoOrCancel_YesByDefault  ; #AW_YesNoOrCancel_NoByDefault  ; #AW_YesNoOrCancel_CancelByDefault  ;  ; Possible return values are:  ; #PB_MessageRequester_Yes  ; #PB_MessageRequester_No  ; #PB_MessageRequester_Cancel  ProcedureReturn Alert(Message$, Title$, 1, 0, 0, 0, "", Type, ParentID)EndProcedure;;; *************************************************************************************;;-                                      5. DEMO;; *************************************************************************************;CompilerIf #PB_Compiler_IsMainFile  ; The following won't run when this file is used as 'Included'.  ;  Alert("This a simple message.")  ;  tx$ = "{\rtf1\ansi\ansicpg1252\deff0\nouicompat\deflang1036{\fonttbl{\f0\fnil\fcharset0 Bauhaus 93;}{\f1\fnil\fcharset0 Calibri;}}" + #CR$ +        "{\colortbl ;\red192\green80\blue77;}" + #CR$ +        "{\*\generator Riched20 10.0.19041}\viewkind4\uc1 " + #CR$ +        "\pard\sa200\sl276\slmult1\f0\fs22\lang12 Demonstration \f1\fs28 text \fs22 in \cf1\b\fs28 RTF \cf0\b0\fs22 format.\par" + #CR$ +        "}"  Alert(tx$)  ;  tx$ = "This example shows how the 'Alert()' function window is able to automatically resize itself so that it can display " +        "text of any length without the need to rewrite code each time you need to display a message of particular length." + #CR$ +        "There is no limit to the size of the message you can include here." + #CR$ +        "The size of the window will be increased as much as possible, then a scrollbar will appear to the right of the text box," +        " if the message is too large to fit entirely in the window."  Alert(tx$, "My title")  ;  tx$ + #CR$ + tx$ + #CR$ + tx$ + #CR$ + tx$ + #CR$ + tx$ + #CR$ + tx$ + #CR$ + tx$ + #CR$ +        #CR$ + tx$ + #CR$ + tx$ + #CR$ + tx$ + #CR$ + tx$ + #CR$ + tx$ + #CR$ + tx$ + #CR$  tx$ = "When the printed text is really large, a “search” button automatically appears to allow a search within the text."   + #CR$ + #CR$ + #CR$ + #CR$ + tx$  Alert(tx$)  ;  tx$ = "A variant of the Alert() function, named AlertYesNoCancel() is intended to replace MessageRequester() with the parameters #PB_MessageRequester_YesNo or #PB_MessageRequester_YesNoCancel." + #CR$ +        "It offers exactly the same flexibility As the 'Alert()' function."  AlertYesNoCancel(tx$, "Demonstration")  ;  tx$ + #CR$ + #CR$ + "Possible parameters for this variant are:" + #CR$ +                      "  #AW_AlertOnly" + #CR$ +                      "  #AW_YesOrNo_YesByDefault" + #CR$ +                      "  #AW_YesOrNo_NoByDefault" + #CR$ +                      "  #AW_OKOrCancel_OKByDefault" + #CR$ +                      "  #AW_OKOrCancel_CancelByDefault" + #CR$ +                      "  #AW_YesNoOrCancel_YesByDefault" + #CR$ +                      "  #AW_YesNoOrCancel_NoByDefault" + #CR$ +                      "  #AW_YesNoOrCancel_CancelByDefault" + #CR$ + #CR$ +                      "Here is an exemple of result with #AW_YesNoOrCancel_CancelByDefault" + #CR$ + #CR$ +                      "The return values are the same as those of the MessageRequester function." + #CR$  AlertYesNoCancel(tx$, "Last Demonstration", #AW_YesNoOrCancel_CancelByDefault)CompilerEndIf; IDE Options = PureBasic 6.20 (Windows - x64); CursorPosition = 1420; FirstLine = 1047; Folding = -BC59-; EnableXP; DPIAware