;;***********************************************************;;                     --  Pipe.pbi --;           For Windows only - Zapman - Oct. 2024;;   This file should be saved under the name "Pipe.pbi".;;     This set of functions is intended To facilitate;   the usage of the 'Pipe' mode of communication offered;                        by Windows.;;***********************************************************;XIncludeFile "Alert.pbi";;Procedure.s GetConnectNamedPipeErrorDescription(errorCode)  Select errorCode    Case #INVALID_HANDLE_VALUE      ProcedureReturn "INVALID HANDLE VALUE"    Case #ERROR_BROKEN_PIPE      ProcedureReturn "The pipe has been ended."    Case #ERROR_PIPE_CONNECTED      ProcedureReturn "There is a process on the other end of the pipe."    Case #ERROR_PIPE_LISTENING      ProcedureReturn "Waiting for a process to open the other end of the pipe."    Case #ERROR_NO_DATA      ProcedureReturn "The pipe is being closed."    Case #ERROR_PIPE_NOT_CONNECTED      ProcedureReturn "No process is on the other end of the pipe."    Case #ERROR_PIPE_BUSY      ProcedureReturn "All pipe instances are busy."    Case 233 ; #ERROR_PIPE_DISCONNECTED = 233.      ProcedureReturn "The other end of the pipe is closed."    Case #ERROR_MORE_DATA      ProcedureReturn "More data is available."    Case #ERROR_IO_PENDING      ProcedureReturn "Attente."    Case #ERROR_PIPE_CONNECTED      ProcedureReturn "The pipe is already connected."    Case #ERROR_OPERATION_ABORTED      ProcedureReturn "The operation was aborted."    Case #ERROR_PIPE_LISTENING      ProcedureReturn "Waiting for a process to open the other end of the pipe."    Case #ERROR_FILE_NOT_FOUND      ProcedureReturn "The system cannot find the file specified."    Case #ERROR_ACCESS_DENIED      ProcedureReturn "Access is denied."    Case #ERROR_INVALID_HANDLE      ProcedureReturn "The handle is invalid."    Default      ProcedureReturn "Unknown error code: " + Str(errorCode)  EndSelectEndProcedure;Procedure CheckForOtherInstance(message$)  ;  ; Checks if another instance of the same program is already open.  ; For this to work, the main program loop needs to regularly call   ; ListenForPipeMessages(), which is located just after.  ;  ; Normally, the very beginning of the main program should include   ; the following lines:  ;     If CheckForOtherInstance(MyArguments$)  ;       End  ;     EndIf  ; with, in MyArguments$, the arguments that were passed to it upon launch.  ;  ; The goal of this system is to limit open instances to just one,  ; but to receive the arguments passed with each attempt to open a new instance.  ; Thus, a command-line program will be able to receive multiple   ; successive commands and respond to them in real time.  ;  Shared PBBrowserRunningPipe$  PBBrowserRunningPipe$ = "\\.\pipe\pbbrowserrunningpipe"  ;  Protected hRunningPipe, Overlapped.OVERLAPPED  Protected Stringbuffer$ = Space(2048)  Protected ConnectionAttempts, BytesTransmitted, Error, MemReboot  Protected wait  ;  ; Checks if the PBBrowserRunningPipe$ pipe is open.  ;  CFOI_Reboot:   ;  ConnectionAttempts = 0  ;  Repeat    hRunningPipe = CreateFile_(PBBrowserRunningPipe$, #GENERIC_READ | #GENERIC_WRITE, 0, 0, #OPEN_EXISTING, #FILE_FLAG_OVERLAPPED, 0)    If hRunningPipe <> #INVALID_HANDLE_VALUE      ; Another instance is already running      ; and waiting for our data.      Break    EndIf    ;    If GetLastError_() = #ERROR_FILE_NOT_FOUND      ; No other instance exists.      ProcedureReturn  #False    ElseIf GetLastError_() = #ERROR_PIPE_BUSY      Delay(20)    Else      ; Another instance is running, but an unusual      ; error occurred. Data won't be transmitted.      ProcedureReturn  #True    EndIf    ConnectionAttempts + 1  Until ConnectionAttempts > 110  ;  If ConnectionAttempts > 110 And hRunningPipe = #INVALID_HANDLE_VALUE    ; Another instance is running, but an unusual    ; error occurred. Data won't be transmitted    ProcedureReturn #True  EndIf  ;  If hRunningPipe <> #INVALID_HANDLE_VALUE    ; Sending the data.    ;    ; Prepare OVERLAPPED structure for asynchronous operation    Overlapped\hEvent = CreateEvent_(#Null, #True, #False, #Null)    If overlapped\hEvent = 0      ; Failure. Data won't be transmitted.      CloseHandle_(hRunningPipe)      ProcedureReturn  #True    EndIf    ;    ConnectionAttempts = 0    Repeat      wait = 0      While GetNamedPipeHandleState_(hRunningPipe, #Null, #Null, #Null, #Null, #Null, 0) = 0 And wait < 200        wait + 1        Delay(10)      Wend      If WriteFile_(hRunningPipe, @message$, StringByteLength(message$), @BytesTransmitted, @Overlapped)        Break      Else        If GetLastError_() = #ERROR_IO_PENDING          ; The write is pending, wait for it to complete          If GetOverlappedResult_(hRunningPipe, @Overlapped, @BytesTransmitted, #True) = 0            Error = 1          Else            Break          EndIf        ElseIf GetLastError_() = #ERROR_PIPE_NOT_CONNECTED          CloseHandle_(overlapped\hEvent)          CloseHandle_(hRunningPipe)          ;          MemReboot + 1          If MemReboot < 100            Delay(20)            Goto CFOI_Reboot          Else            Error = 1          EndIf        Else          ConnectionAttempts + 1          If ConnectionAttempts > 9            Error = 1          Else            Delay(20)          EndIf        EndIf      EndIf    Until Error    ;    If Error = 0      ;      ; We wait for confirmation that the data has been received before closing the connection.      ; Otherwise, the other instance may not be able to retrieve the entire data:      If ReadFile_(hRunningPipe, @Stringbuffer$, StringByteLength(Stringbuffer$), @BytesTransmitted, @Overlapped) = 0        If GetLastError_() = #ERROR_IO_PENDING          GetOverlappedResult_(hRunningPipe, @Overlapped, @BytesTransmitted, #True)        EndIf      EndIf    EndIf    ;    CloseHandle_(overlapped\hEvent)    CloseHandle_(hRunningPipe)    ProcedureReturn #True  EndIfEndProcedure;Procedure.s ListenForPipeMessages()  ;    Shared PBBrowserRunningPipe$  ;  Static Initialized, hRunningPipe, Overlapped.OVERLAPPED  ;  Protected Stringbuffer$ = Space(2048)  Protected BufferSize    = StringByteLength(Stringbuffer$)  Protected BytesTransmitted, Error  ;  If Initialized = 0    ; A pipe is created to signal to any potential new instances    ; of the program that one is already active.    hRunningPipe = CreateNamedPipe_(@PBBrowserRunningPipe$, #PIPE_ACCESS_DUPLEX | #FILE_FLAG_OVERLAPPED, #PIPE_TYPE_MESSAGE | #PIPE_READMODE_MESSAGE | #PIPE_WAIT, #PIPE_UNLIMITED_INSTANCES, BufferSize, BufferSize, 0, #Null)    If hRunningPipe <> #INVALID_HANDLE_VALUE      Overlapped\hEvent = CreateEvent_(#Null, #False, #True, #Null)      If Overlapped\hEvent        Initialized = 1      Else        CloseHandle_(hRunningPipe)      EndIf    EndIf  EndIf  ;  If Initialized = 0    MessageRequester("Error", "Unable to initialize the pipe: " + GetConnectNamedPipeErrorDescription(GetLastError_()))  EndIf  ;  If Initialized And (ConnectNamedPipe_(hRunningPipe, @Overlapped) Or GetLastError_() = #ERROR_PIPE_CONNECTED)    ; A new instance has been opened and connected to the pipe to send us data.    ; Receiving the data:    If ReadFile_(hRunningPipe, @Stringbuffer$, StringByteLength(Stringbuffer$), @BytesTransmitted, @Overlapped) = 0      If GetLastError_() = #ERROR_IO_PENDING        ; The write is pending, wait for it to complete        If GetOverlappedResult_(hRunningPipe, @Overlapped, @BytesTransmitted, #True) = 0          Error = 1        EndIf      Else        Error = 2      EndIf    EndIf    ;    If Error      MessageRequester("CheckForOtherInstance Error", "Unable to complete read operation: (" + Str(Error) + ") " + GetConnectNamedPipeErrorDescription(Error))    Else      ; The received string does not have a terminating character,      ; but for PureBasic, a string must end with the "0" character.      ; The solution is as follows:      Stringbuffer$ = Left(Stringbuffer$, BytesTransmitted / 2) ; Stringbuffer$ is a Unicode string. Each character occupies two bytes.      ;      ; Now, send a confirmation message to the instance      ; that transmitted the data:      If WriteFile_(hRunningPipe, "ACK", StringByteLength("ACK"), @BytesTransmitted, @Overlapped) = 0        If GetLastError_() = #ERROR_IO_PENDING          GetOverlappedResult_(hRunningPipe, @Overlapped, @BytesTransmitted, #True)        EndIf      EndIf    EndIf    ;    ; The connection with the other instance is closed, but we do NOT close hRunningPipe    ; (no CloseHandle_(hRunningPipe)), so it can stay in wait mode and be used    ; for a similar future event.    DisconnectNamedPipe_(hRunningPipe)    ;    ProcedureReturn Stringbuffer$  EndIfEndProcedure; IDE Options = PureBasic 6.12 LTS (Windows - x86); CursorPosition = 14; FirstLine = 1; Folding = -; EnableXP; DPIAware