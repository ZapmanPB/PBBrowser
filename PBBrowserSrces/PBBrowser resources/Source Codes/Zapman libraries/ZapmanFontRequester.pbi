;; ****************************************************************************;;                            Zapman Font Requester;                                March 2025 - 14;;     This file should be saved under the name "ZapmanFontRequester.pbi".;;            This library is intended to implement an alternative;              of the PureBasic native FontRequester() function.;;                Needs FontDescription.pbi as included files.;;  The main procedures of this library are 'FontRequesterEx()' and 'ZapmanFontRequester()';  which are quite similar but use different types of parameters (see comments at the;  beginning of these procedures).;; This library is organized into for distinct sections:;; 1. 'Language settings' contains functions that manage the multilingual;    aspect of the library. Read the comment at the beginning of this section;    for more details.; 2. 'General functions' includes functions necessary for the library's;    operation but may also be useful in other contexts. For example, 'GetFontName()';    gives you the name of a loaded font from it's ID.; 3. 'Zapman FontRequester specific functions' is a set of routines needed by;    the public functions to be executed.; 4. 'Zapman FontRequester public functions' are the main functions of this library.;    They offer two different manners to call a customizable font requester.;    Please read the comments at the beginning of each procedure to know how to use it.; 5. The 'DEMO' section illustrates the purpose of this library.;;; This library is compatible with the Zapman 'ApplyColorThemes.pb' library; that allows you to display your windows in 'Dark Mode' or with other color themes.; It's also compatible with (and will use) 'ZapmanColorRequester.pbi' if this; library is included in your project.;; ****************************************************************************;; "FontDescription.pbi" library is necessary for FontDescription string interpretation:XIncludeFile"FontDescription.pbi";;- 1. Language settings;; All Zapman libraries are now designed to be integrated into multilingual applications.; It is entirely possible to redefine the 'GetTextFromCatalog()' function in a file; that precedes this one in your 'IncludedFile' list. This way, you can store the; different translations of the texts used in your application's gadgets in a; different manner.; However, the functions in this section provide a simple (and portable) way to do it,; and if your language is not included in the list of translated languages, only a few; lines need to be added to address this omission (look at the end of this section).;; The translations were provided by ChatGPT from the English version.; For the poem in the 'Sample' section, it was asked to choose an excerpt from a classic; poem in the corresponding language.;CompilerIf #PB_Compiler_IsMainFile  EnableExplicitCompilerEndIf;Global MyLanguage$If MyLanguage$ = ""  MyLanguage$ = "EN" ; You can set MyLanguage$ to "EN", "RU", "DE", "IT", "ES", "ZH" or "FR".EndIf;CompilerIf Not Defined(LanguageListStructure, #PB_Structure)  Structure LanguageListStructure    Language$    LanguageEntry$    LanguageTranslation$  EndStructure  ;  Global NewList LanguageList.LanguageListStructure()CompilerEndIf;CompilerIf Not Defined(GetTextFromCatalog, #PB_Procedure)  Procedure.s GetTextFromCatalog(SName$)    ForEach LanguageList()      If LanguageList()\Language$ = MyLanguage$ And LCase(LanguageList()\LanguageEntry$) = LCase(SName$)        ProcedureReturn LanguageList()\LanguageTranslation$      EndIf    Next    ProcedureReturn SName$  EndProcedureCompilerEndIf;CompilerIf Not Defined(FillLanguageList, #PB_Procedure)  Procedure FillLanguageList(Language$, LanguageEntry$, LanguageTranslation$)    ;    Protected PosInList = 0, KeyWord$, Found    ;    Repeat      PosInList + 1      KeyWord$ = StringField(LanguageEntry$, PosInList, ",")      Found = 0      ForEach LanguageList()        If LanguageList()\Language$ = Language$ And LCase(LanguageList()\LanguageEntry$) = LCase(KeyWord$)          Found = 1          Break        EndIf      Next      If Found = 0        AddElement(LanguageList())        LanguageList()\Language$ = Language$        LanguageList()\LanguageEntry$ = KeyWord$        LanguageList()\LanguageTranslation$ = StringField(LanguageTranslation$, PosInList, ",")      EndIf    Until KeyWord$ = ""  EndProcedureCompilerEndIf;Define LanguageEntry$ = "ChooseAFont,Variants:,Size:,DetailsDwn,DetailsUp,Cancel,OK,Normal,Bold,Italic,Underline,StrikeOut,Color:,"       LanguageEntry$ + "fancyFont,unspecified,monospace,withSerif,handwriting,withoutSerif,Unknown,Type:,Family:,Style:,Script(s):,Metrics:,"       LanguageEntry$ + "Sample,"       LanguageEntry$ + "CAFDemoText";; ------------- English list of expressions ---------------Define LanguageTranslation$ = "Choose a font,Variants:,Size:,Details ⏷,Details ⏶,Cancel,OK,Normal,Bold,Italic,Underline,StrikeOut,Color:,"       LanguageTranslation$ + "fancy font,unspecified,monospace,with serif,handwriting,without serif,Unknown,Type:,Family:,Style:,Script(s):,Metrics:,"       LanguageTranslation$ + "Sample,"       LanguageTranslation$ + "The invisible worm" + #CR$       LanguageTranslation$ + "That flies in the night" + #CR$       LanguageTranslation$ + "In the howling storm" + #CR$       LanguageTranslation$ + "Has found out thy bed" + #CR$       LanguageTranslation$ + "Of crimson joy:" + #CR$       LanguageTranslation$ + "his dark secret love" + #CR$       LanguageTranslation$ + "thy life destroy."FillLanguageList("EN", LanguageEntry$, LanguageTranslation$);; ------------- Lista de expresiones en español ---------------Define LanguageTranslation$ = "Elige una fuente,Variantes:,Tamaño:,Detalles ⏷,Detalles ⏶,Cancelar,OK,Normal,Negrita,Cursiva,Subrayado,Tachado,Color:,"        LanguageTranslation$ + "fuente elegante,no especificada,monoespaciada,con serif,escritura manual,sin serif,Desconocido,Tipo:,Familia:,Estilo:,Guion(es):,Métricas:,"       LanguageTranslation$ + "Muestra,"        LanguageTranslation$ + "Recuerde el alma dormida" + #CR$       LanguageTranslation$ + "avive el seso y despierte" + #CR$       LanguageTranslation$ + "contemplando cómo se pasa la vida" + #CR$       LanguageTranslation$ + "cómo se viene la muerte tan callando."FillLanguageList("ES", LanguageEntry$, LanguageTranslation$);; ------------- French list of expressions ----------------       LanguageTranslation$ = "Choisir une police,Variantes :,Taille :,Détails ⏷,Détails ⏶,Annuler,OK,Normal,Gras,Italique,Souligné,Barré,Couleur :,"       LanguageTranslation$ + "police fantaisie,non spécifié,monospace,avec empattement,écriture manuelle,sans empattement,Inconnu,Type :,Famille :,Style :,Script(s) :,Métriques :,"       LanguageTranslation$ + "Exemple,"       LanguageTranslation$ + "Toujours avec l'espoir de rencontrer la mer" + #CR$       LanguageTranslation$ + "Ils voyageaient sans pain sans bâtons et sans urnes" + #CR$       LanguageTranslation$ + "Mordant au citron d'or de l'idéal amer."FillLanguageList("FR", LanguageEntry$, LanguageTranslation$);; ------------- German list of expressions ----------------Define LanguageTranslation$ = "Wählen Sie eine Schriftart,Varianten:,Größe:,Einzelheiten ⏷,Einzelheiten ⏶,Abbrechen,OK,Normal,Fett,Kursiv,Unterstrichen,Durchgestrichen,Farbe:,"       LanguageTranslation$ + "elegante Schrift,nicht angegeben,monospaced,mit serifen,handschrift,ohne serifen,Unbekannt,Typ:,Familie:,Stil:,Schriftart(en):,Metriken:,"       LanguageTranslation$ + "Probe,"       LanguageTranslation$ + "Wer reitet so spät durch Nacht und Wind?" + #CR$       LanguageTranslation$ + "Es ist der Vater mit seinem Kind;" + #CR$       LanguageTranslation$ + "Er hat den Knaben wohl in dem Arm" + #CR$       LanguageTranslation$ + "Er fasst ihn sicher er hält ihn warm."FillLanguageList("DE", LanguageEntry$, LanguageTranslation$);; ------------- Italian list of expressions ---------------Define LanguageTranslation$ = "Scegli un carattere,Varianti:,Dimensione:,Dettagli ⏷,Dettagli ⏶,Annulla,OK,Normale,Grassetto,Corsivo,Sottolineato,StrikeOut,Colore:,"       LanguageTranslation$ + "carattere elegante,non specificato,monospaziato,con grazie,scrittura a mano,sans-serif,Sconosciuto,Tipo:,Famiglia:,Stile:,Script:,Metriche:,"       LanguageTranslation$ + "Campione,"       LanguageTranslation$ + "Sempre caro mi fu quest'ermo colle" + #CR$       LanguageTranslation$ + "E questa siepe che da tanta parte" + #CR$       LanguageTranslation$ + "Dell'ultimo orizzonte il guardo esclude."FillLanguageList("IT", LanguageEntry$, LanguageTranslation$);; ------------- Russian list of expressions ---------------Define LanguageTranslation$ = "Выберите шрифт,Варианты:,Размер:,Подробности ⏷,Подробности ⏶,Отмена,OK,Обычный,Жирный,Курсив,Подчеркнутый,Зачеркнутый,Цвет:,"       LanguageTranslation$ + "изящный шрифт,неопределено,моноширинный,с засечками,почерк,без засечек,Неизвестно,Тип:,Семейство:,Стиль:,Скрипт(ы):,Метрика:,"       LanguageTranslation$ + "Образец,"       LanguageTranslation$ + "Уснул ове́щий Оле́г" + #CR$       LanguageTranslation$ + "Привиделась ему́ злая мечта:" + #CR$       LanguageTranslation$ + "Он встретил во́льного ворона" + #CR$       LanguageTranslation$ + "И воскликнул: ''О как я жив!''"FillLanguageList("RU", LanguageEntry$, LanguageTranslation$);; ------------- Mandarin list of expressions ---------------Define LanguageTranslation$ = "选择字体,变种:,大小:,细节 ⏷,细节 ⏶,取消,确定,正常,加粗,斜体,下划线,删除线,颜色:,"       LanguageTranslation$ + "优雅字体,未指定,等宽字体,有衬线,手写体,无衬线,未知,类型:,家族:,风格:,脚本(们):,度量:,"       LanguageTranslation$ + "示例,"       LanguageTranslation$ + "床前明月光" + #CR$       LanguageTranslation$ + "疑是地上霜" + #CR$       LanguageTranslation$ + "举头望明月" + #CR$       LanguageTranslation$ + "低头思故乡" + #CR$       LanguageTranslation$ + "孤帆远影碧空尽。"FillLanguageList("ZH", LanguageEntry$, LanguageTranslation$);; ----------- Add your own language here -------------;      LanguageTranslation$ = "Expression1,Expression2,etc.";FillLanguageList("XX", LanguageEntry$, LanguageTranslation$) ; and replace "XX" by the abbreviation of your language name.;;; ****************************************************************************;;-                 2. General functions for font recognition;; ****************************************************************************;Global PBBAllGadgetsFontIf PBBAllGadgetsFont = 0  ; Define the font used to print gadgets of the FontRequesterEx() window.  PBBAllGadgetsFont = FontID(LoadFont(#PB_Any, "Segoe UI", 9))EndIf;; ****************************************************************************;;-                3. Zapman FontRequester specific functions;; ****************************************************************************;#ZFR_ChooseColor   = $4000000#ZFR_NORASTERFONTS = $8000000#ZFR_ShowSize      = $10000000#ZFR_FontRequester_Effects = #PB_Font_Bold | #PB_Font_Italic | #PB_Font_StrikeOut | #PB_Font_Underline | #ZFR_ChooseColor | #ZFR_ShowSize | #CF_NOVERTFONTS#ZFR_FontRequester_Default = #PB_Font_Bold | #PB_Font_Italic | #ZFR_ShowSize | #CF_NOVERTFONTS;Global ZFR_FontDescription$ ; Will contain the font description after a call to ZapmanFontRequester() or FontRequesterEx().;Enumeration CWO_Positioning  #CWO_ActiveWindowPos = -1  #CWO_AbsolutePos     = -2  #CWO_MonitorPos      = -3EndEnumeration;Enumeration CWO_PositionAnchor  #CWO_Center = 0  #CWO_TopLeft  #CWO_TopRight  #CWO_BottomLeft  #CWO_BottomRightEndEnumeration;CompilerIf Not Defined(ComputeWinOrigins, #PB_Procedure)  Procedure ComputeWinOrigins(*OX.Integer, *OY.Integer, WWidth, WHeight, ParentWindow = #CWO_ActiveWindowPos, XShiftOrPos = 0, YShiftOrPos = 0, ParentAnchor = #CWO_Center, WindowAnchor = #CWO_Center)    ;    ; Compute the X and Y origins of a window from its width (WWidth) and height (WHeight)    ; and from the parent window position or from the monitor of the parent window.    ;    ; • If ParentWindow is a valid window number, the new window will be positionned relatively to it,    ;   and then shifted by XShiftOrPos and YShiftOrPos.    ; • If ParentWindow = #CWO_ActiveWindowPos and GetActiveWindow() returns a valid window number,    ;   GetActiveWindow() will be considered as the parent window.    ; • If ParentWindow = #CWO_ActiveWindowPos and GetActiveWindow() does NOT return a valid window number,    ;   the position will be calculated relatively to the main screen.    ; • It ParentWindow = #CWO_AbsolutePos, XShiftOrPos and YShiftOrPos will be the absolute coordinates    ;   of the new window.    ; • If ParentWindow = #CWO_MonitorPos, the position will be calculated relatively to the screen where    ;   GetActiveWindow() is found or relatively to the main screen if GetActiveWindow()    ;   is not a valid window.    ;    ; • The new window will be positionned relatively to the center, top-left, top-right, bottom-left    ;   or bottom-right of the parent window (or monitor), depending on the 'ParentAnchor' parameter.    ;    ; • The anchor of the new window can be the center, top-left, top-right, bottom-left or bottom-right    ;   of the new window, depending on the 'WindowAnchor' parameter.    ;    ; • In all case, except if ParentWindow = #CWO_AbsolutePos, the position of the new window will be    ;   shifted regarding the 'XShiftOrPos' and 'YShiftOrPos' parameters.    ;    Protected DesktopLeft, DesktopRight, DesktopTop, DesktopBottom    Protected ParentWindowID, MFWindow, hMonitor, mi.MONITORINFO    ;    If ParentWindow = #CWO_AbsolutePos      *OX\i = XShiftOrPos      *OY\i = YShiftOrPos      ProcedureReturn 0    EndIf    ;    If ParentWindow = #CWO_ActiveWindowPos And IsWindow(GetActiveWindow())      ; If ParentWindow = #CWO_ActiveWindowPos, use GetActiveWindow() as parent:      ParentWindow = GetActiveWindow()    EndIf    ;    ; Get the screen coordinates for the monitor where the parent window is found:    MFWindow = ParentWindow    If Not(IsWindow(MFWindow))      MFWindow = GetActiveWindow()    EndIf    If IsWindow(MFWindow)      MFWindow = WindowID(MFWindow)    Else      ; If there is no active-window, use the main monitor:      MFWindow = 0    EndIf    ;    hMonitor = MonitorFromWindow_(MFWindow, #MONITOR_DEFAULTTONEAREST)    mi\cbSize = SizeOf(MONITORINFO)    GetMonitorInfo_(hMonitor, @mi)    ;    DesktopLeft   = DesktopUnscaledX(mi\rcWork\left)    DesktopRight  = DesktopUnscaledX(mi\rcWork\Right)    DesktopTop    = DesktopUnscaledY(mi\rcWork\top)    DesktopBottom = DesktopUnscaledY(mi\rcWork\Bottom)    ;    ;____________________________________________    ;    ; Calculate the starting point coordinates:    If IsWindow(ParentWindow)      ParentWindowID = WindowID(ParentWindow)      ;      *OX\i = WindowX(ParentWindow)      *OY\i = WindowY(ParentWindow)      ;      If ParentAnchor = #CWO_Center        *OX\i + WindowWidth(ParentWindow) / 2        *OY\i + WindowHeight(ParentWindow) / 2      ElseIf ParentAnchor = #CWO_TopRight        *OX\i + WindowWidth(ParentWindow)      ElseIf ParentAnchor = #CWO_BottomLeft        *OY\i + WindowHeight(ParentWindow)      ElseIf ParentAnchor = #CWO_BottomRight        *OX\i + WindowWidth(ParentWindow)        *OY\i + WindowHeight(ParentWindow)      EndIf    Else      ;      *OX\i = DeskTopLeft      *OY\i = DesktopTop      ;      If ParentAnchor = #CWO_Center        *OX\i / 2 + DesktopRight / 2        *OY\i / 2 + DesktopBottom / 2      ElseIf ParentAnchor = #CWO_TopRight        *OX\i = DesktopRight      ElseIf ParentAnchor = #CWO_BottomLeft        *OY\i = DesktopBottom      ElseIf ParentAnchor = #CWO_BottomRight        *OX\i = DesktopRight        *OY\i = DesktopBottom      EndIf    EndIf    ;____________________________________________    ;    ; Adjust the final coordinates regarding the new window size:    ;    WHeight + MenuHeight() + 4 ; <-- Calculate the real total height of the new window                               ;     that will be created by "OpenWindow(#PB_Any, OX, OY, WWidth, WHeight..."    If WindowAnchor = #CWO_Center      *OX\i - WWidth / 2      *OY\i - WHeight / 2    ElseIf WindowAnchor = #CWO_TopRight      *OX\i - WWidth    ElseIf WindowAnchor = #CWO_BottomLeft      *OY\i - WHeight    ElseIf WindowAnchor = #CWO_BottomRight      *OX\i - WWidth      *OY\i - WHeight    EndIf    ;    ;____________________________________________    ;    ; Shift the final position:    *OX\i + XShiftOrPos    *OY\i + YShiftOrPos    ;    ; Test if window extends beyond screen bounds due to ParentWindow position or XShiftOrPos or YShiftOrPos:    If *OX\i < DesktopLeft      *OX\i = DesktopLeft + 10    ElseIf *OX\i + WWidth > DesktopRight      *OX\i =  DesktopRight - WWidth - 10    EndIf    If *OY\i < DesktopTop      *OY\i = DesktopTop + 10    ElseIf *OY\i + WHeight > DesktopBottom      *OY\i =  DesktopBottom - WHeight - 10    EndIf    ;    ProcedureReturn ParentWindowID  EndProcedureCompilerEndIf;Structure FontInfoStruct  FontName$  FontStyle$  ScriptList$  FontType.i  PitchAndFamily.l  ntmFlags.i  ;  MainFontName$  Variants$EndStructure;Define NewList FontList.FontInfoStruct();Procedure.s ZFR_GetFontTypeNameFromNum(FontType)  Protected FontTypeStr$  Select FontType    Case #TRUETYPE_FONTTYPE      FontTypeStr$ = "TrueType"    Case #DEVICE_FONTTYPE      FontTypeStr$ = "Device"    Case #RASTER_FONTTYPE      FontTypeStr$ = "Raster"    Default      FontTypeStr$ = "Unknown"  EndSelect  ProcedureReturn FontTypeStr$EndProcedure;Procedure.s ZFR_GetFontFamilyNameFromNum(PitchAndFamily)  Protected FontFamilyStr$  Protected FamilyNum = PitchAndFamily & $FFF0  Select FamilyNum    Case #FF_DECORATIVE      FontFamilyStr$ = "DECORATIVE (" + GetTextFromCatalog("fancyFont") + ")"    Case #FF_DONTCARE      FontFamilyStr$ = "DONTCARE (" + GetTextFromCatalog("unspecified") + ")"    Case #FF_MODERN      FontFamilyStr$ = "MODERN (" + GetTextFromCatalog("monospace") + ")"    Case #FF_ROMAN      FontFamilyStr$ = "ROMAN (" + GetTextFromCatalog("withSerif") + ")"    Case #FF_SCRIPT      FontFamilyStr$ = "SCRIPT (" + GetTextFromCatalog("handwriting") + ")"    Case #FF_SWISS      FontFamilyStr$ = "SWISS (" + GetTextFromCatalog("withoutSerif") + ")"    Default      FontFamilyStr$ = "Unknown"  EndSelect  If PitchAndFamily & 1 And FindString(FontFamilyStr$, GetTextFromCatalog("monospace")) = 0    FontFamilyStr$ + " (" + GetTextFromCatalog("monospace") + ")"  EndIf  ProcedureReturn FontFamilyStr$EndProcedure;Procedure ZFR_EnumFontProc(*lpelfex.ENUMLOGFONTEX, *lpntm.NEWTEXTMETRIC, FontType, lParam)  ;  ; Callback to enumerate fonts with informations.  ;  Shared FontList()  Protected FontName$ = PeekS(@*lpelfex\elfLogFont\lfFaceName[0]) ; Retrieve the font name  Protected ScriptList$ = PeekS(@*lpelfex\elfScript[0])                                                                  ;  If Left(FontName$, 1) <> "@" Or lParam & #CF_NOVERTFONTS = 0                                     ; Exclude vertical fonts if asked.    If *lpelfex\elfLogFont\lfPitchAndFamily & #TMPF_FIXED_PITCH Or lParam & #CF_FIXEDPITCHONLY = 0 ; Exclude non monospace fonts if asked.      If FontType <> #RASTER_FONTTYPE Or lParam & #ZFR_NORASTERFONTS = 0                           ; Exclude raster fonts if asked        If FontType & #TMPF_TRUETYPE Or lParam & #CF_TTONLY = 0                                    ; Exclude non truetype fonts if asked          If FindString(ScriptList$, "OEM") = 0 Or (lParam & #CF_NOOEMFONTS = 0 And lParam & #CF_NOVECTORFONTS = 0) ; Exclude OEM fonts if asked            If (FindString(ScriptList$, "OEM") = 0 And FindString(ScriptList$, "Symbol") = 0) Or lParam & #CF_SCRIPTSONLY = 0  ; Exclude OEM and Symbol fonts if asked              If ListSize(FontList()) < 1 Or FontName$ <> FontList()\FontName$                AddElement(FontList())                FontList()\FontName$      = FontName$                FontList()\FontStyle$     = PeekS(@*lpelfex\elfStyle[0])                FontList()\FontType       = FontType                FontList()\PitchAndFamily = *lpelfex\elfLogFont\lfPitchAndFamily                FontList()\ScriptList$    = ScriptList$                FontList()\ntmFlags       = *lpntm\ntmFlags                FontList()\MainFontName$  = ""                FontList()\Variants$      = ""              Else                FontList()\ScriptList$ + ", " + PeekS(@*lpelfex\elfScript[0])              EndIf                            If *lpntm\tmWeight >= 600                ; The font is too bold to be embolded.                ; In case the #NTM_BOLD flag is not already set, set it:                FontList()\ntmFlags | #NTM_BOLD              EndIf            EndIf          EndIf        EndIf      EndIf    EndIf  EndIf  ProcedureReturn 1EndProcedure;Procedure ZFR_ListFonts(Window, FontListGadget, Options)  ;  Protected PosInList, Pos, Indic$, PPos, MMainFontName$, VariantList$, Variant$  Shared FontList()  ;  Protected VariantIndicators$ = "Extra,Semi,Demi,Light,Med,Bold,Black,Heavy,Ultra,Cond,Italic,SmBd,Bd,Cn,Bk,Blk,Hv,Lt,Md,XBlk,Thin"  If Window    If IsWindow(Window)      Window = WindowID(Window)    EndIf    ;    Protected hdc = GetDC_(Window)    If hdc      ; Call the enumeration function with ENUMLOGFONTEX      ClearList(FontList())      EnumFontFamiliesEx_(hdc, 0, @ZFR_EnumFontProc(), Options, 0)      SortStructuredList(FontList(), #PB_Sort_Ascending, OffsetOf(FontInfoStruct\FontName$), TypeOf(FontInfoStruct\FontName$))      ;      ; Look for variants names (as 'Bold', 'Light', etc.) in the name of the font:      ForEach(FontList())        PosInList = 0        Pos = 0        Repeat          ; Explore the list of variants names:          PosInList + 1          Indic$ = StringField(VariantIndicators$, PosInList, ",")          If Indic$            PPos = FindString(FontList()\FontName$, Indic$)            If PPos And (PPos < Pos Or Pos = 0)              Pos = PPos            EndIf          EndIf        Until Indic$ = ""        If Pos > 1          ; Take off the variant name from MainFontName$          FontList()\MainFontName$ = Trim(Left(FontList()\FontName$, Pos -1))        Else          FontList()\MainFontName$ = FontList()\FontName$        EndIf        ;      Next      ;      ; Sort the list again, without the varients names:      SortStructuredList(FontList(), #PB_Sort_Ascending, OffsetOf(FontInfoStruct\MainFontName$), TypeOf(FontInfoStruct\MainFontName$))      ;      ; Complete the FontListGadget with the main font names:      MMainFontName$ = ""      ForEach(FontList())        If FontList()\MainFontName$ <> MMainFontName$          MMainFontName$ = FontList()\MainFontName$          AddGadgetItem(FontListGadget, -1, MMainFontName$)          VariantList$ = ""          Protected *Main = @FontList()          While FontList()\MainFontName$ = MMainFontName$            ;            ; Register all variants for a main font name:            Variant$ = Trim(Mid(FontList()\FontName$, Len(FontList()\MainFontName$) + 1))            If Variant$ = ""              Variant$ = "Normal"            EndIf            VariantList$ + Variant$ + ","            FontList()\Variants$ = Variant$            If NextElement(FontList()) = 0              MMainFontName$ = ""            EndIf          Wend          Protected *LastFLE = @FontList()          ChangeCurrentElement(FontList(), *Main)          FontList()\Variants$ = VariantList$          ChangeCurrentElement(FontList(), *LastFLE)          If MMainFontName$            PreviousElement(FontList())          EndIf        EndIf        ;      Next      ReleaseDC_(Window, hDC)    EndIf  EndIfEndProcedure;Procedure.s ZFR_GetFontInfosText()  ;  Shared FontList()  Protected FontInfos$, tm.TEXTMETRIC  ;  FontInfos$ = GetTextFromCatalog("Name:") + " " + FontList()\FontName$ + #CR$  FontInfos$ + GetTextFromCatalog("Type:") + " " + ZFR_GetFontTypeNameFromNum(FontList()\FontType) + "  -  "  FontInfos$ + GetTextFromCatalog("Family:") + " " + ZFR_GetFontFamilyNameFromNum(FontList()\PitchAndFamily) + "  -  "  FontInfos$ + GetTextFromCatalog("Style:") + " " + FontList()\FontStyle$ + #CR$  FontInfos$ + GetTextFromCatalog("Script(s):") + " " + FontList()\ScriptList$ + #CR$  ;  Protected Font = LoadFont(#PB_Any, FontList()\FontName$, 48)  Protected hDC = GetDC_(0)  SelectObject_(hDC, FontID(Font))  GetTextMetrics_(hDC, @tm)  ReleaseDC_(0, hDC)  FreeFont(Font)  FontInfos$ + GetTextFromCatalog("Metrics:") + " Height=" + Str(tm\tmHeight/2) + ", Ascent=" + Str(tm\tmAscent/2) + ", Descent=" + Str(tm\tmDescent/2) + ", IntLeading=" + Str(tm\tmInternalLeading/2) + ", ExtLeading=" + Str(tm\tmExternalLeading/2) + ", Weight=" + Str(tm\tmWeight) + #CR$  ProcedureReturn FontInfos$EndProcedure;Procedure.s ZFR_RetreiveFontListElementFromGadgets(CFont, CBVariants, CFontOnly = #False, itemNumCFont = -1, itemNumCBVariants = -1)  ;  Protected Found = 0, FontName$, Variant$  Shared FontList()  ;  If itemNumCFont = -1      : itemNumCFont      = GetGadgetState(CFont)      : EndIf  If itemNumCBVariants = -1 : itemNumCBVariants = GetGadgetState(CBVariants) : EndIf  ;  FontName$ = GetGadgetItemText(CFont, itemNumCFont)  ;  ForEach FontList()    If Left(FontList()\MainFontName$, Len(FontName$)) = FontName$      If CFontOnly        Found = 1      Else        Protected *Main = @FontList()        While FontList()\MainFontName$ = FontName$          Variant$ = Trim(Mid(FontList()\FontName$, Len(FontName$) + 1))          If Variant$ = ""            Variant$ = "Normal"          EndIf          If Variant$ = GetGadgetItemText(CBVariants, itemNumCBVariants)            Found = 1            Break          EndIf          NextElement(FontList())        Wend      EndIf      Break    EndIf  Next  If Found = 0 And *Main    ChangeCurrentElement(FontList(), *Main)  EndIf  ProcedureReturn FontList()\FontName$EndProcedure;Procedure ZFR_ApplyFontToExample(CFont, CBVariants, SSize, CBBold, CBItalic, CBUnderline, CBStrikeOut, FontColor, TExample, TDetails, DetailsToggle, Reset = 0)  ;  Shared FontList()  Static mItalicState = -1,  mBoldState = -1, TextFont  If Reset    mItalicState = -1 : mBoldState = -1  EndIf  Protected FontStyle = 0, Size, ObjectTheme  ;  ZFR_RetreiveFontListElementFromGadgets(CFont, CBVariants)  ;  If IsGadget(CBItalic)    If FontList()\ntmFlags & #NTM_ITALIC      ; If ntmFlags & #NTM_ITALIC, it means that the font is allready italic      ; and cannot be more set to italic. Disable the Italic CheckBox:      mItalicState = GetGadgetState(CBItalic)      SetGadgetState(CBItalic, 1)      DisableGadget(CBItalic, #True)    Else      If mItalicState <> -1        SetGadgetState(CBItalic, mItalicState)        mItalicState = -1      EndIf      DisableGadget(CBItalic, #False)    EndIf  EndIf  ;  If IsGadget(CBBold)    If FontList()\ntmFlags & #NTM_BOLD      ; If ntmFlags & #NTM_BOLD, it means that the font is allready bold      ; and cannot be more embolded. Disable the Bold CheckBox:      mBoldState = GetGadgetState(CBBold)      SetGadgetState(CBBold, 1)      DisableGadget(CBBold, #True)    Else      If mBoldState <> -1        SetGadgetState(CBBold, mBoldState)        mBoldState = -1      EndIf      DisableGadget(CBBold, #False)    EndIf  EndIf  ;  If IsGadget(CBBold) And GetGadgetState(CBBold)    FontStyle | #PB_Font_Bold  EndIf  If IsGadget(CBItalic) And GetGadgetState(CBItalic)    FontStyle | #PB_Font_Italic  EndIf  If IsGadget(CBUnderline) And GetGadgetState(CBUnderline)    FontStyle | #PB_Font_Underline  EndIf  If IsGadget(CBStrikeOut) And GetGadgetState(CBStrikeOut)    FontStyle | #PB_Font_StrikeOut  EndIf  ;  If IsFont(TextFont)    FreeFont(TextFont)  EndIf  If IsGadget(SSize)    Size = Val(GetGadgetText(SSize))  Else    Size = 10  EndIf  TextFont = LoadFont(#PB_Any, FontList()\FontName$, Size, FontStyle)  SetGadgetFont(TExample, FontID(TextFont))  ;  If FontColor = -1    CompilerIf Defined(SetGadgetsColorsFromTheme, #PB_Procedure)      If ListSize(InterfaceColorPresets()) > 0        FontColor = GetRealColorFromType("TextColor", InterfaceColorPresets()\TextColor)      Else        FontColor = 0      EndIf    CompilerElseIf Defined(ObjectTheme, #PB_Module)      ; Manage compatibility with the ObjectTheme.pbi library:      FontColor = ObjectTheme::GetObjectThemeAttribute(#PB_GadgetType_Button, #PB_Gadget_FrontColor)    CompilerElse      FontColor = 0    CompilerEndIf  EndIf  SetGadgetColor(TExample, #PB_Gadget_FrontColor, FontColor)  ;  If DetailsToggle    SetGadgetText(TDetails, ZFR_GetFontInfosText())  EndIf  EndProcedure;Macro ZFR_ExtractParametersFromFontDescription(FontDescription)  ;  FontName$ = "" : FontSize = 0 : FontColor = -1  ;  mFontDescription$ = FontDescription  FontDescription = NormalizeFontDescription(FontDescription)  ;  If FindString(FontDescription, "name(")    parameter$ = FD_ExtractParameter(FontDescription, "name")    If parameter$ And parameter$ <> "default"      FontName$ = parameter$      ; Restore capital letters for the font name:      pp = FindString(mFontDescription$, FontName$, 0, #PB_String_NoCase)      If pp        FontName$ = Mid(mFontDescription$, pp, Len(FontName$))      EndIf    EndIf  EndIf  ;  If FindString(FontDescription, "size(")    parameter$ = FD_ExtractParameter(FontDescription, "size")    If parameter$ And parameter$ <> "default"      FontSize = ValF(parameter$)      If FontSize = 0        FontSize = Val(parameter$)      EndIf    EndIf  EndIf  ;  If FindString(FontDescription, "forecolor(")    parameter$ = FD_ExtractParameter(FontDescription, "forecolor")    If parameter$ And parameter$ <> "default"      FontColor = Val(parameter$)    EndIf  EndIf  ;  FontStyle = GetNumStyleFromAttributesDescription(FontDescription)  If FontName$ = "" : FontName$ = "Segoe UI" : EndIf  If FontSize = 0 : FontSize = 9 : EndIf  ;EndMacro;Procedure ZFR_UpdateCBVariantsFromCFont(CFont, CBVariants)  ;  Shared FontList()  Protected Pos, Variant$  ;  ForEach(FontList())    If FontList()\MainFontName$ = GetGadgetText(CFont)      Break    EndIf  Next  ;  ClearGadgetItems(CBVariants)  Pos = 0  Repeat    Pos + 1    Variant$ = StringField(FontList()\Variants$, Pos, ",")    If Variant$      AddGadgetItem(CBVariants, -1, Variant$)    EndIf  Until Variant$ = ""  ;  SetGadgetState(CBVariants, 0)  If CountGadgetItems(CBVariants) < 2    DisableGadget(CBVariants, #True)  Else    DisableGadget(CBVariants, #False)  EndIf  InvalidateRect_(GadgetID(CBVariants), 0, #True)EndProcedure;Global ZFR_CFont, ZFR_CBVariants;Procedure ZFR_OwnerDrawCallback(hWnd, uMsg, wParam, lParam)  ;  ; Callback for ownerdrawing ZFR_CFont ListViewGadget and ZFR_CBVariants ComboBoxGadget  ;  Shared FontList()  Protected *drawItem.DRAWITEMSTRUCT, HighLight = 0  Protected hDC, rc.RECT, rcBack.RECT, Text$, DSize.Size, Font, Size, Height  Protected itemNum, ODTType, hBrush, FontName$, NFontName$  Protected tm.TEXTMETRIC, ObjectTheme  ;  Select uMsg    Case #WM_MEASUREITEM      Protected *measureItem.MEASUREITEMSTRUCT = lParam      ;      ODTType = *measureItem\CtlType      If ODTType = #ODT_COMBOBOX        *measureItem\itemHeight = DesktopScaledY(20)        ProcedureReturn #True      EndIf    Case #WM_DRAWITEM      *drawItem = lParam      itemNum = *drawItem\itemID      Protected CtlID = GetProp_(*drawItem\hwndItem, "PB_ID")      If (CtlID = ZFR_CFont Or CtlID = ZFR_CBVariants) And itemNum > -1        ;        hDC = *drawItem\hdc        rc = *drawItem\rcItem        CopyStructure(rc, rcBack, RECT)        ODTType = *drawItem\CtlType        ;        If ODTType = #ODT_COMBOBOX And (*drawItem\rcItem\bottom - *drawItem\rcItem\top) < SendMessage_(*drawItem\hwndItem, #CB_GETITEMHEIGHT, 0, 0)          Protected DrawingComboTitle = 1        EndIf        ;        If *drawItem\itemState & #ODS_SELECTED          If ODTType = #ODT_COMBOBOX            If DrawingComboTitle = 0 ; Never highlight the combo title.              HighLight = 1            EndIf          Else            HighLight = 1          EndIf        EndIf        ;        ; Draw back-rectangle:        If HighLight          Protected BackColor = GetSysColor_(#COLOR_HIGHLIGHT)          Protected TextColor = GetSysColor_(#COLOR_HIGHLIGHTTEXT)          SetTextColor_(hDC, TextColor)        Else          BackColor = GetSysColor_(#COLOR_WINDOW)          TextColor = GetSysColor_(#COLOR_WINDOWTEXT)          If DrawingComboTitle = 0 ; Don't colorize the title: this will be done by SetGadgetColorEx.            CompilerIf Defined(SetGadgetsColorsFromTheme, #PB_Procedure)              If ListSize(InterfaceColorPresets()) > 0                BackColor = GetRealColorFromType("BackgroundColor", InterfaceColorPresets()\BackgroundColor)                TextColor = GetRealColorFromType("TextColor", InterfaceColorPresets()\TextColor)              EndIf            CompilerEndIf          EndIf          CompilerIf Defined(ObjectTheme, #PB_Module)            ; Manage compatibility with the ObjectTheme.pbi library:            BackColor = ObjectTheme::GetObjectThemeAttribute(0, #PB_Gadget_BackColor)            TextColor = ObjectTheme::GetObjectThemeAttribute(#PB_GadgetType_Button, #PB_Gadget_FrontColor)          CompilerEndIf          SetTextColor_(hDC, TextColor)        EndIf        ;        hBrush = CreateSolidBrush_(BackColor)        If ODTType = #ODT_COMBOBOX ; Extend the background rectangle          rcBack\left - 1 : rcBack\top - 1 : rcBack\right + 1 : rcBack\bottom + 1          SelectClipRgn_(hDC, 0)        EndIf        ;        FillRect_(hDC, @rcBack, hBrush)        DeleteObject_(hBrush)        ;        rc\left + DesktopScaledY(2)        ;        ; Retrieve the line text:        Text$ = GetGadgetItemText(CtlID, itemNum)        ;        If CtlID = ZFR_CFont          FontName$ = ZFR_RetreiveFontListElementFromGadgets(ZFR_CFont, ZFR_CBVariants, #True, itemNum, -1)        Else          FontName$ = ZFR_RetreiveFontListElementFromGadgets(ZFR_CFont, ZFR_CBVariants, #False, -1, itemNum)        EndIf        ;        ; Draw the font name using the font itself        ;        If FontList()\ScriptList$ = "Symbole"          ; The font may not contain readable characteres. Use Segoe instead:          NFontName$ = "Segoe UI"        Else          NFontName$ = FontName$        EndIf        ;        ; Adjust the font size to get approximately the same visual size for each font:        ;        ; Get metrics to measure the font height:        Size = DesktopScaledY(10)        Font = LoadFont(#PB_Any, NFontName$, Size)        SelectObject_(hDC, FontID(Font))        GetTextMetrics_(hDC, @tm.TEXTMETRIC)        FreeFont(Font)        ;        ; Try to correct some weird font metrics:        If (tm\tmInternalLeading + tm\tmExternalLeading) < tm\tmHeight / 4          tm\tmInternalLeading = tm\tmHeight / 4        EndIf        ;        ; Adjust the size:        Height = tm\tmHeight - tm\tmInternalLeading        Size = Round(Size * DesktopScaledY(12) / Height, #PB_Round_Nearest)        ;        ; Load the font and draw the text:        Font = LoadFont(#PB_Any, NFontName$, Size)        SelectObject_(hDC, FontID(Font))        SetBkMode_(hDC, #TRANSPARENT)        DrawText_(hDC, Text$, Len(Text$), @rc, #DT_LEFT | #DT_VCENTER | #DT_SINGLELINE)        ;        If CtlID = ZFR_CFont And FontList()\ScriptList$ = "Symbole"          ; The 'Symbole' font has been represented using Segoe UI.          ; Add a short sample of what it looks like:          GetTextExtentPoint32_(hDC, Text$, Len(Text$), @DSize)          rc\left + DSize\cx + DesktopScaledX(8)          FreeFont(Font)          Font = LoadFont(#PB_Any, FontName$, Size)          SelectObject_(hDC, FontID(Font))          DrawText_(hDC, "Aaz1", Len("Aaz1"), @rc, #DT_LEFT | #DT_VCENTER | #DT_SINGLELINE)        EndIf        ;        FreeFont(Font)        ;        ProcedureReturn #True      EndIf  EndSelect  ;  ; Normal callback for all other messages:  Protected ZFR_OldCallBack = GetProp_(hWnd, "ZFR_OldCallBack")  ProcedureReturn CallWindowProc_(ZFR_OldCallBack, hWnd, uMsg, wParam, lParam)EndProcedure;; ****************************************************************************;;-                4. Zapman FontRequester public functions;; ****************************************************************************;Procedure.s FontRequesterEx(FontDescription$, AvailableStyles = #ZFR_FontRequester_Default, *UserChoice.Integer = 0, ParentID = #PB_Default, XShiftOrPos = 0, YShiftOrPos = 0, ParentAnchor = #CWO_Center, WindowAnchor = #CWO_Center)  ;  ; Alternative FontRequester of the PureBasic 'FontRequester()' function.  ;  ;  ; ------------------------- RETURNED VALUE --------------------------  ; • The returned value is a text description of the selected font, presented as follows :  ;       'FontName, FontSize, FontColor, Bold, Italic, ...'  ; • You can call the 'LoadFontFromDescription(FontDescription$)'  ;       function to obtain a font from the returned value.  ;  ; • On return, you can also call 'ZapmanFontName()' to get only the name of the chosen font,  ;   or 'ZapmanFontSize()' or 'ZapmanFontColor()' or 'ZapmanFontStyle()' to get other chosen attributes.  ;  ;  ; ------------------------------ NOTE -------------------------------  ; • Instead of calling this function, you can also call ZapmanFontRequester()  ;   with parameters similar to the native PureBasic 'FontRequester()' function.  ;  ;  ; ------------------------ ENTRY PARAMETERS -------------------------  ; • FontDescription$ must contain a text description of the font that is displayed by default when the requester is opened.  ;   First specify the name of the font, then its size, then, possibly, its color, then, possibly, a list of styles.  ;  ;   - The size value can be specified by 'Size(xxxxx)', 'Size:xxxxx' or simply a number.  ;   - The color value can be specified by 'Color(xxxxx)', 'Color:xxxxx' or simply a decimal or hexadecimal number.  ;   - All parts of the description must be separated by commas.  ;   - The list of styles added to the description can contain : Bold, Italic, Underline and StrikeOut.  ;   Example: "Segoe UI, 9, Color:$FF0020, Italic"  ;  ;  ; • AvailableStyles allows you to customize the font requester by defining the options proposed to the user.  ;   This parameter is a numeric combination of the following flags:  ;   #PB_Font_Bold       add a 'Bold' CheckBox to the dialog  ;   #PB_Font_Italic     add an 'Italic' CheckBox to the dialog  ;   #PB_Font_StrikeOut  add a 'StrikeOut' CheckBox to the dialog  ;   #PB_Font_Underline  add an 'Underline' CheckBox to the dialog  ;   #ZFR_ChooseColor    allow to modify/choose a color for the font  ;   #ZFR_ShowSize       allow to modify/choose the size of the font  ;   #CF_NOVERTFONTS     Exclude vertical fonts from the list (font names beginning by "@")  ;   #CF_FIXEDPITCHONLY  Print only monospace fonts in the list  ;   #ZFR_NORASTERFONTS  Exclude raster fonts from the list  ;   #CF_TTONLY          Exclude non truetype from the list  ;   #CF_NOVECTORFONTS   Exclude OEM fonts from the list  ;   #CF_SCRIPTSONLY     Exclude OEM and Symbol fonts from the list  ;  ;   You can, for example, set it to #PB_Font_Bold | #PB_Font_Italic to allow usage of these styles, but prevent any  ;   other FontStyle variations.  ;  ;   You can set this parameter to '#ZFR_FontRequester_Effects' which is a combination of  ;   #PB_Font_Bold | #PB_Font_Italic | #PB_Font_StrikeOut | #PB_Font_Underline | #ZFR_ChooseColor | #ZFR_ShowSize | #CF_NOVERTFONTS  ;  ;   You can also set this parameter to '#ZFR_FontRequester_Default' which is a combination of  ;   #PB_Font_Bold | #PB_Font_Italic | #ZFR_ShowSize | #CF_NOVERTFONTS  ;  ;  ; • If ParentID is a valid window number, the new window will be positionned relatively to it,  ;   and then shifted by XShiftOrPos and YShiftOrPos.  ; • If ParentID = #CWO_ActiveWindowPos and GetActiveWindow() returns a valid window number,  ;   GetActiveWindow() will be considered as the parent window.  ; • If ParentID = #CWO_ActiveWindowPos and GetActiveWindow() does NOT return a valid window number,  ;   the position will be calculated relatively to the main screen.  ; • It ParentID = #CWO_AbsolutePos, XShiftOrPos and YShiftOrPos will be the absolute coordinates  ;   of the new window.  ; • If ParentID = #CWO_MonitorPos, the position will be calculated relatively to the screen where  ;   GetActiveWindow() is found or relatively to the main screen if GetActiveWindow()  ;   is not a valid window.  ;  ; • The new window will be positionned relatively to the center, top-left, top-right, bottom-left  ;   or bottom-right of the parent window (or monitor), depending on the 'ParentAnchor' parameter.  ;  ; • The anchor of the new window can be the center, top-left, top-right, bottom-left or bottom-right  ;   of the new window, depending on the 'WindowAnchor' parameter.  ;  ; • In all case, except if ParentID = #CWO_AbsolutePos, the position of the new window will be  ;   shifted regarding the 'XShiftOrPos' and 'YShiftOrPos' parameters.  ;  If AvailableStyles = -1    AvailableStyles = #ZFR_FontRequester_Effects  EndIf  ;  Protected ParentWindow = #PB_Default  If IsWindow(ParentID)    ParentWindow = ParentID    ParentID = WindowID(ParentID)  ElseIf ParentID <> #PB_Default And IsWindow_(ParentID)    ParentWindow = GetProp_(ParentID, "PB_WindowID") - 1  ElseIf IsWindow(GetActiveWindow()) And ParentID = #PB_Default    ParentWindow = GetActiveWindow()    ParentID = WindowID(ParentWindow)  EndIf  If ParentWindow = #PB_Default    ParentWindow = ParentID  EndIf  ;  Shared FontList()  ;  Protected FontName$, FontSize$, FontSize.f, FontColor, FontStyle  Protected pp, ct, Event, EventGadget, Gadget, GetOut, OX, OY  Protected BSizePlus, BSizeMinus, BVariantState, NFontColor  Protected CFontState, Found, Windowskey, parameter$, CBBold  ;  Protected mFontDescription$ = FontDescription$  ;  Protected DetailsToggle = 0  ;  ZFR_ExtractParametersFromFontDescription(FontDescription$)  ;  ; Load the font corresponding to FontDescription$.  ; If the given font name is not found, the LoadFont() function  ; will use the nearest existing font.  ;  Protected TextFont = LoadFont(#PB_Any, FontName$, FontSize, FontStyle)  ;  ; Now, recover the font name given by LoadFont():  FontName$ = GetFontName(TextFont)  FreeFont(TextFont)  ;  ; Window creation:  Protected WWidth      = 480  Protected WHeight     = 230  Protected Margins     = 10  Protected Intergadget = 7  Protected LineHeight  = 22  Protected NbStyles    = 0  ;  If AvailableStyles & #PB_Font_Bold    NbStyles + 1  EndIf  If AvailableStyles & #PB_Font_Italic    NbStyles + 1  EndIf  If AvailableStyles & #PB_Font_StrikeOut    NbStyles + 1  EndIf  If AvailableStyles & #PB_Font_Underline    NbStyles + 1  EndIf  If AvailableStyles & #ZFR_ChooseColor    NbStyles + 1  EndIf  If AvailableStyles & #ZFR_ShowSize    NbStyles + 1  EndIf  WHeight + ((LineHeight + Intergadget) * (NbStyles - 1)) / 2  If WHeight < 240 : WHeight = 240 : EndIf  ;  Protected WParam = #PB_Window_SystemMenu | #PB_Window_Invisible  Protected ActiveWindow = ParentWindow  If Not(IsWindow(ActiveWindow))    ActiveWindow = GetActiveWindow()  EndIf  ;  Protected ParentWindowID = ComputeWinOrigins(@OX, @OY, WWidth, WHeight, ParentWindow, XShiftOrPos, YShiftOrPos, ParentAnchor, WindowAnchor)  Protected CFWindow = OpenWindow(#PB_Any, OX, OY, WWidth, WHeight, GetTextFromCatalog("ChooseAFont"), WParam, ParentWindowID)  If CFWindow    If IsWindow(ActiveWindow) And IsWindowEnabled_(WindowID(ActiveWindow))      DisableWindow(ActiveWindow, #True)      Protected ParentHasBeenDisabled = #True    EndIf    ; Install the callback procedure to ownerdraw the ListView and ComboBox gadgets:    Protected ZFR_OldCallback = SetWindowLongPtr_(WindowID(CFWindow), #GWL_WNDPROC, @ZFR_OwnerDrawCallback())    SetProp_(WindowID(CFWindow), "ZFR_OldCallback", ZFR_OldCallback)    ;    CompilerIf Defined(ApplyDarkModeToWindow, #PB_Procedure)      ApplyDarkModeToWindow(CFWindow)    CompilerEndIf    ;    StickyWindow(CFWindow, #True)    ;    ; Create the gadgets:    Protected LegendWidth   = 65    Protected FontListWidth = 200    Protected DetailsHeight = 90    Protected UsableHeight = WindowHeight(CFWindow) - Margins * 2    Protected SFont = StringGadget(#PB_Any, Margins, Margins, FontListWidth, LineHeight, "")    Protected GadgetList$ = Str(SFont) + ","    ;    ZFR_CFont = ListViewGadget(#PB_Any, Margins, Margins + LineHeight + Intergadget, FontListWidth, UsableHeight - LineHeight - Intergadget - 1, #LBS_OWNERDRAWFIXED) ; List of fonts    SendMessage_(GadgetID(ZFR_CFont), #LB_SETITEMHEIGHT, -1, DesktopScaledX(20))    GadgetList$ + Str(ZFR_CFont) + ","    ;    Protected VPos = Margins    Protected HPos = Margins + FontListWidth + Margins    Protected TVariants = TextGadget(#PB_Any, HPos, VPos + 2, LegendWidth, LineHeight, GetTextFromCatalog("Variants:"), #PB_Text_Right)    GadgetList$ + Str(TVariants) + ","    ;    HPos + LegendWidth + Intergadget    Protected GWidth = WindowWidth(CFWindow) - Margins - HPos    ;    ZFR_CBVariants = ComboBoxGadget(#PB_Any, HPos, VPos, GWidth, LineHeight, #CBS_OWNERDRAWFIXED | #CBS_HASSTRINGS) ; List of variants    GadgetList$ + Str(ZFR_CBVariants) + ","    ;    Protected HPos2 = Margins + FontListWidth + Margins    Protected CBWidth = 90    Protected CBPosLeft = HPos;2 + 40    VPos + LineHeight + 3    HPos = CBPosLeft    ;    If AvailableStyles & #PB_Font_Bold       CBBold = CheckBoxGadget(#PB_Any, HPos, VPos, CBWidth, LineHeight, GetTextFromCatalog("Bold"))      GadgetList$ + Str(CBBold) + ","      If FontStyle & #PB_Font_Bold        SetGadgetState(CBBold, #True)      EndIf      If HPos = CBPosLeft        HPos + CBWidth      Else        HPos = CBPosLeft        VPos + LineHeight - 2      EndIf    Else      FontStyle & ~(#PB_Font_Bold)    EndIf    ;    If AvailableStyles & #PB_Font_Italic      Protected CBItalic = CheckBoxGadget(#PB_Any, HPos, VPos, CBWidth, LineHeight, GetTextFromCatalog("Italic"))      GadgetList$ + Str(CBItalic) + ","      If FontStyle & #PB_Font_Italic        SetGadgetState(CBItalic, #True)      EndIf      If HPos = CBPosLeft        HPos + CBWidth      Else        HPos = CBPosLeft        VPos + LineHeight - 2      EndIf    Else      FontStyle & ~(#PB_Font_Italic)    EndIf    ;    If AvailableStyles & #PB_Font_Underline      Protected CBUnderline = CheckBoxGadget(#PB_Any, HPos, VPos, CBWidth, LineHeight, GetTextFromCatalog("Underline"))      GadgetList$ + Str(CBUnderline) + ","      If FontStyle & #PB_Font_Underline        SetGadgetState(CBUnderline, #True)      EndIf      If HPos = CBPosLeft        HPos + CBWidth      Else        HPos = CBPosLeft        VPos + LineHeight - 2      EndIf    Else      FontStyle & ~(#PB_Font_Underline)    EndIf    ;    If AvailableStyles & #PB_Font_StrikeOut      Protected CBStrikeOut = CheckBoxGadget(#PB_Any, HPos, VPos, GWidth, LineHeight, GetTextFromCatalog("StrikeOut"))      GadgetList$ + Str(CBStrikeOut) + ","      If FontStyle & #PB_Font_StrikeOut        SetGadgetState(CBStrikeOut, #True)      EndIf      If HPos = CBPosLeft        HPos + CBWidth      Else        HPos = CBPosLeft        VPos + LineHeight - 2      EndIf    Else      FontStyle & ~(#PB_Font_StrikeOut)    EndIf    ;    If HPos <> CBPosLeft      VPos + LineHeight - 2    EndIf    HPos = HPos2    VPos + 5    ;    If AvailableStyles &  #ZFR_ShowSize      Protected TSize  = TextGadget(#PB_Any, HPos, VPos + 2, LegendWidth, LineHeight, GetTextFromCatalog("Size:"), #PB_Text_Right)      GadgetList$ + Str(TSize) + ","      HPos + LegendWidth + Intergadget      Protected SSize  = SpinGadget(#PB_Any, HPos, VPos, 45, LineHeight, 1, 500, #PB_Spin_Numeric) ; Font size      SetWindowLongPtr_(GadgetID(SSize), #GWL_STYLE, GetWindowLongPtr_(GadgetID(SSize), #GWL_STYLE) | #ES_NUMBER)      GadgetList$ + Str(SSize) + ","      SetGadgetText(SSize, StrF(FontSize))      HPos + 45    EndIf    ;    If AvailableStyles & #ZFR_ChooseColor      Protected TColor = TextGadget(#PB_Any, HPos, VPos + 2, LegendWidth, LineHeight, GetTextFromCatalog("Color:"), #PB_Text_Right)      GadgetList$ + Str(TColor) + ","      HPos + LegendWidth + Intergadget      Protected CanvasColor = CanvasGadget(#PB_Any, HPos, VPos, LineHeight, LineHeight)      GadgetList$ + Str(CanvasColor) + ","      If StartDrawing(CanvasOutput(CanvasColor))        DrawingMode(#PB_2DDrawing_Default)        Box(0, 0, 300, 200, FontColor)        StopDrawing()      EndIf    Else      FontStyle & ~(#ZFR_ChooseColor)    EndIf    ;    HPos = HPos2    If AvailableStyles &  #ZFR_ShowSize Or AvailableStyles & #ZFR_ChooseColor      VPos + LineHeight + Margins + Intergadget    Else      VPos + 3    EndIf    Protected FExample = FrameGadget(#PB_Any, HPos, VPos - Margins, WindowWidth(CFWindow) - Margins - HPos, UsableHeight + 2 *Margins - LineHeight - Intergadget - VPos, GetTextFromCatalog("Sample"))    GadgetList$ + Str(FExample) + ","    Protected TExample = TextGadget(#PB_Any, HPos + Margins, VPos + Margins, WindowWidth(CFWindow) - 3 * Margins - HPos, UsableHeight - 3 - LineHeight - Intergadget - VPos, GetTextFromCatalog("CAFDemoText"), #PB_Text_Center)    ;    VPos = UsableHeight + Margins - LineHeight    ;    Protected TDetails = TextGadget(#PB_Any, Margins, VPos, WindowWidth(CFWindow) - 2 * Margins, DetailsHeight, "")    GadgetList$ + Str(TDetails) + ","    HideGadget(TDetails, #True)    ;    HPos = HPos2    Protected BCancelWidth = 75    Protected BDetailsWidth = 100    Protected BOKWidth = 60    Protected BDetails = ButtonGadget(#PB_Any, HPos, VPos, BDetailsWidth, LineHeight, GetTextFromCatalog("DetailsDwn")) ; Bouton Annuler    GadgetList$ + Str(BDetails) + ","    HPos + BDetailsWidth + Intergadget    Protected BCancel  = ButtonGadget(#PB_Any, HPos, VPos, BCancelWidth, LineHeight, GetTextFromCatalog("Cancel")) ; Bouton Annuler    GadgetList$ + Str(BCancel) + ","    Protected BOK      = ButtonGadget(#PB_Any, WindowWidth(CFWindow) - Margins - BOKWidth, VPos, BOKWidth, LineHeight, GetTextFromCatalog("OK"), #PB_Button_Default) ; Bouton OK    GadgetList$ + Str(BOK) + ","    ;    ; Fill the ListViewGadget with system fonts:    ZFR_ListFonts(CFWindow, ZFR_CFont, AvailableStyles)    ;    If CountGadgetItems(ZFR_CFont) = 0      If ParentHasBeenDisabled        DisableWindow(ParentWindow, #False)      EndIf      ProcedureReturn FontDescription$    EndIf    ;    Protected mLen = 0    For ct = 0 To CountGadgetItems(ZFR_CFont)      Protected NLen = Len(GetGadgetItemText(ZFR_CFont, ct))      If NLen > mLen And GetGadgetItemText(ZFR_CFont, ct) = Left(FontName$, NLen)        ; First adjust the scrollbar position:        SetGadgetState(ZFR_CFont, ct + 5)        ; Then, go up to the selected line:        SetGadgetState(ZFR_CFont, ct)      EndIf    Next    ;    SetGadgetText(SFont, GetGadgetText(ZFR_CFont))    ZFR_UpdateCBVariantsFromCFont(ZFR_CFont, ZFR_CBVariants)    ;    Protected Variant$ = Trim(Mid(FontName$, Len(GetGadgetText(ZFR_CFont)) + 1))    If Variant$ = ""      Variant$ = "Normal"    EndIf    ;    For ct = 0 To CountGadgetItems(ZFR_CBVariants)      If Variant$ = GetGadgetItemText(ZFR_CBVariants, ct)        SetGadgetState(ZFR_CBVariants, ct)        Break      EndIf    Next    ;    Protected PosInGadgetList = 0    ; Set the font for all gadgets:    Repeat      PosInGadgetList + 1      Gadget = Val(StringField(GadgetList$, PosInGadgetList, ","))      If IsGadget(Gadget)        SetGadgetFont(Gadget, PBBAllGadgetsFont)      EndIf    Until StringField(GadgetList$, PosInGadgetList, ",") = ""    ;    ; ---------------------------------------------------    ;    CompilerIf Defined(SetGadgetsColorsFromTheme, #PB_Procedure)      ;      ; Apply color theme to the gadgets.      ; The SetGadgetsColorsFromTheme() is defined into the Zapman 'ApplyColorThemes.pbi' library.      ; This file must be included by your program before the present file to benefit from color      ; theme support.      ;      If ListSize(InterfaceColorPresets()) > 0        GadgetList$ + Str(TExample) + ","        SetGadgetsColorsFromTheme(CFWindow, InterfaceColorPresets(), GadgetList$)      EndIf      ;    CompilerEndIf    ;    ZFR_ApplyFontToExample(ZFR_CFont, ZFR_CBVariants, SSize, CBBold, CBItalic, CBUnderline, CBStrikeOut, FontColor, TExample, TDetails, DetailsToggle, #True)    ;    Enumeration KeyboardShortCuts      #ArrowDownShortcut      #ArrowUpShortcut      #PlusShortcut      #MinusShortcut      #ZFR_Escape_Cmd      #ZFR_Enter    EndEnumeration    ;    AddKeyboardShortcut(CFWindow, #PB_Shortcut_Down,     #ArrowDownShortcut)    AddKeyboardShortcut(CFWindow, #PB_Shortcut_Up,       #ArrowUpShortcut)    AddKeyboardShortcut(CFWindow, #PB_Shortcut_Add,      #PlusShortcut)    AddKeyboardShortcut(CFWindow, #PB_Shortcut_Subtract, #MinusShortcut)    AddKeyboardShortcut(CFWindow, #PB_Shortcut_6,        #MinusShortcut)    AddKeyboardShortcut(CFWindow, #PB_Shortcut_Escape,   #ZFR_Escape_Cmd)    AddKeyboardShortcut(CFWindow, #PB_Shortcut_Return,   #ZFR_Enter)    ;    ; The window was invisible until now, because we created it with #PB_Window_Invisible.    ; We make it visible now.    HideWindow(CFWindow, #False)    ;    SetActiveGadget(SFont)    ;    ; Boucle des événements    Repeat      Event = WaitWindowEvent()      EventGadget = EventGadget()      If Event = #PB_Event_Menu        If EventMenu() = #ArrowDownShortcut Or EventMenu() = #ArrowUpShortcut          If GetActiveGadget() = SSize Or GetActiveGadget() = BSizePlus Or GetActiveGadget() = BSizeMinus            If EventMenu() = #ArrowUpShortcut              Event = #PB_Event_Gadget              EventGadget = BSizePlus            Else              Event = #PB_Event_Gadget              EventGadget = BSizeMinus            EndIf          ElseIf GetActiveGadget() = ZFR_CBVariants            BVariantState = GetGadgetState(ZFR_CBVariants)            If EventMenu() = #ArrowUpShortcut And BVariantState > 0              SetGadgetState(ZFR_CBVariants, BVariantState - 1)              ZFR_ApplyFontToExample(ZFR_CFont, ZFR_CBVariants, SSize, CBBold, CBItalic, CBUnderline, CBStrikeOut, FontColor, TExample, TDetails, DetailsToggle)            ElseIf EventMenu() = #ArrowDownShortcut And BVariantState < CountGadgetItems(ZFR_CBVariants) - 1              SetGadgetState(ZFR_CBVariants, BVariantState + 1)              ZFR_ApplyFontToExample(ZFR_CFont, ZFR_CBVariants, SSize, CBBold, CBItalic, CBUnderline, CBStrikeOut, FontColor, TExample, TDetails, DetailsToggle)            EndIf          Else            If GetActiveGadget() = SFont Or GetActiveGadget() = BDetails              SetActiveGadget(ZFR_CFont)            EndIf            Gadget = GetActiveGadget()            If Gadget = -1              Gadget = ZFR_CFont            EndIf            CFontState = GetGadgetState(Gadget)            If EventMenu() = #ArrowDownShortcut And CFontState < (CountGadgetItems(Gadget) - 1)              SetGadgetState(Gadget, CFontState + 1)            ElseIf EventMenu() = #ArrowUpShortcut And CFontState > 0              SetGadgetState(Gadget, CFontState - 1)            EndIf            ZFR_UpdateCBVariantsFromCFont(ZFR_CFont, ZFR_CBVariants)            SetGadgetText(SFont, GetGadgetText(ZFR_CFont))            ZFR_ApplyFontToExample(ZFR_CFont, ZFR_CBVariants, SSize, CBBold, CBItalic, CBUnderline, CBStrikeOut, FontColor, TExample, TDetails, DetailsToggle)          EndIf        ElseIf EventMenu() = #PlusShortcut          Event = #PB_Event_Gadget          EventGadget = #PlusShortcut        ElseIf EventMenu() = #MinusShortcut          Event = #PB_Event_Gadget          EventGadget = #MinusShortcut        ElseIf EventMenu() = #ZFR_Escape_Cmd          Event = #PB_Event_Gadget          EventGadget = BCancel        ElseIf EventMenu() = #ZFR_Enter          If GetActiveGadget() = ZFR_CBVariants            ; Select the actual line and close the gadget.            DisableGadget(ZFR_CBVariants, #True)            DisableGadget(ZFR_CBVariants, #False)            SetActiveGadget(ZFR_CBVariants)          Else            Event = #PB_Event_Gadget            EventGadget = BOk          EndIf        EndIf      EndIf      CompilerIf #PB_Compiler_OS = #PB_OS_Windows        If GetAsyncKeyState_(#VK_OEM_PLUS) & $8000          If Windowskey <> #VK_OEM_PLUS            Windowskey = #VK_OEM_PLUS            EventGadget = #PlusShortcut            Event = #PB_Event_Gadget          EndIf        ElseIf GetAsyncKeyState_(#VK_OEM_MINUS) & $8000          If Windowskey <> #VK_OEM_MINUS            Windowskey = #VK_OEM_MINUS            EventGadget = #MinusShortcut            Event = #PB_Event_Gadget          EndIf        Else          Windowskey = 0        EndIf      CompilerEndIf      Select Event        Case #PB_Event_Gadget          Select EventGadget            Case BDetails              If DetailsToggle = 0                DetailsToggle = 1                SetGadgetText(BDetails, GetTextFromCatalog("DetailsUp"))                ResizeWindow(CFWindow, #PB_Ignore, #PB_Ignore, #PB_Ignore, WindowHeight(CFWindow) + DetailsHeight)                ResizeGadget(ZFR_CFont, #PB_Ignore, #PB_Ignore, #PB_Ignore, GadgetHeight(ZFR_CFont) - LineHeight - Intergadget)                HideGadget(TDetails, #False)                ZFR_ApplyFontToExample(ZFR_CFont, ZFR_CBVariants, SSize, CBBold, CBItalic, CBUnderline, CBStrikeOut, FontColor, TExample, TDetails, DetailsToggle)                SetGadgetText(TDetails, ZFR_GetFontInfosText())                ; Keep the line visible despite the reduction in the size of the list:                ; First adjust the scrollbar position:                SetGadgetState(ZFR_CFont, GetGadgetState(ZFR_CFont) + 5)                ; Then, go up to the selected line:                SetGadgetState(ZFR_CFont, GetGadgetState(ZFR_CFont))              Else                DetailsToggle = 0                SetGadgetText(BDetails, GetTextFromCatalog("DetailsDwn"))                ResizeWindow(CFWindow, #PB_Ignore, #PB_Ignore, #PB_Ignore, WindowHeight(CFWindow) - DetailsHeight)                ResizeGadget(ZFR_CFont, #PB_Ignore, #PB_Ignore, #PB_Ignore, GadgetHeight(ZFR_CFont) + LineHeight + Intergadget)                HideGadget(TDetails, #True)              EndIf              VPos = WindowHeight(CFWindow) - Margins - LineHeight              ResizeGadget(BDetails, #PB_Ignore, VPos, #PB_Ignore, #PB_Ignore)              ResizeGadget(BCancel, #PB_Ignore, VPos, #PB_Ignore, #PB_Ignore)              ResizeGadget(BOk, #PB_Ignore, VPos, #PB_Ignore, #PB_Ignore)            Case SFont              If EventType() = #PB_EventType_Change                 FontName$ = LCase(GetGadgetText(SFont))                Found = -1                For ct = 0 To CountGadgetItems(ZFR_CFont) -1                  If LCase(Left(GetGadgetItemText(ZFR_CFont, ct), Len(FontName$))) = FontName$                    Found = ct                    ; First adjust the scrollbar position:                    SetGadgetState(ZFR_CFont, ct + 5)                    ; Then, go up to the selected line:                    SetGadgetState(ZFR_CFont, ct)                    ZFR_UpdateCBVariantsFromCFont(ZFR_CFont, ZFR_CBVariants)                    ZFR_ApplyFontToExample(ZFR_CFont, ZFR_CBVariants, SSize, CBBold, CBItalic, CBUnderline, CBStrikeOut, FontColor, TExample, TDetails, DetailsToggle)                    Break                  EndIf                Next                If Found = -1                  SetGadgetText(SFont, Left(FontName$, Len(FontName$) - 1))                  CompilerIf #PB_Compiler_OS = #PB_OS_Windows                    SendMessage_(GadgetID(SFont), #EM_SETSEL, Len(FontName$) - 1, Len(FontName$) - 1)                  CompilerEndIf                EndIf              ElseIf EventType() = #PB_EventType_Focus                CompilerIf #PB_Compiler_OS = #PB_OS_Windows                  SendMessage_(GadgetID(SFont), #EM_SETSEL, 0, -1)                CompilerEndIf              EndIf            Case ZFR_CFont, SSize, ZFR_CBVariants, CBBold, CBItalic, CBUnderline, CBStrikeOut, #PlusShortcut, #MinusShortcut              If EventGadget = #PlusShortcut                FontSize$ = StrF(ValF(GetGadgetText(SSize)) + 1)                SetGadgetText(SSize, FontSize$)              ElseIf EventGadget = #MinusShortcut                FontSize$ = StrF(ValF(GetGadgetText(SSize)) - 1)                If ValF(FontSize$) < 0 : FontSize$ = "0" : EndIf                SetGadgetText(SSize, FontSize$)              EndIf              ;              If EventGadget = ZFR_CFont                ZFR_UpdateCBVariantsFromCFont(ZFR_CFont, ZFR_CBVariants)              EndIf              ZFR_ApplyFontToExample(ZFR_CFont, ZFR_CBVariants, SSize, CBBold, CBItalic, CBUnderline, CBStrikeOut, FontColor, TExample, TDetails, DetailsToggle)              ;              SetGadgetText(SFont, GetGadgetText(ZFR_CFont))              ;            Case CanvasColor              If EventType() = #PB_EventType_LeftButtonDown                CompilerIf Defined(ZapmanColorRequester, #PB_Procedure)                  NFontColor = ZapmanColorRequester(FontColor, WindowID(CFWindow))                CompilerElse                  NFontColor = ColorRequester(FontColor, WindowID(CFWindow))                CompilerEndIf                If NFontColor <> -1                  FontColor = NFontColor                  If StartDrawing(CanvasOutput(CanvasColor))                    DrawingMode(#PB_2DDrawing_Default)                    Box(0, 0, 300, 200, FontColor)                    StopDrawing()                  EndIf                  ZFR_ApplyFontToExample(ZFR_CFont, ZFR_CBVariants, SSize, CBBold, CBItalic, CBUnderline, CBStrikeOut, FontColor, TExample, TDetails, DetailsToggle)                EndIf              EndIf            Case BCancel              GetOut = -1              Break            Case BOk              GetOut = 1              Break          EndSelect        Case #PB_Event_CloseWindow          GetOut = -1      EndSelect    Until GetOut    ;    If GetOut = 1      ZFR_RetreiveFontListElementFromGadgets(ZFR_CFont, ZFR_CBVariants)      ;      FontDescription$ = FontList()\FontName$ + ", "      If IsGadget(SSize)        FontDescription$ + GetGadgetText(SSize) + ", "      EndIf      If FontColor <> 0 And FontColor <> -1        FontDescription$ + "$" + Hex(FontColor) + ", "      EndIf      If IsGadget(CBBold) And GetGadgetState(CBBold) And IsWindowEnabled_(GadgetID(CBBold))        FontDescription$ + "Bold, "      EndIf      If IsGadget(CBItalic) And GetGadgetState(CBItalic) And IsWindowEnabled_(GadgetID(CBItalic))        FontDescription$ + "Italic, "      EndIf      If IsGadget(CBStrikeOut) And GetGadgetState(CBStrikeOut) And IsWindowEnabled_(GadgetID(CBStrikeOut))        FontDescription$ + "StrikeOut, "      EndIf      If IsGadget(CBUnderline) And GetGadgetState(CBUnderline) And IsWindowEnabled_(GadgetID(CBUnderline))        FontDescription$ + "Underline, "      EndIf      FontDescription$ = Left(FontDescription$, Len(FontDescription$) - 2)    Else      GetOut = 0      FontDescription$ = mFontDescription$    EndIf    ;    CloseWindow(CFWindow)  EndIf  ;  ClearList(FontList())  ;  If *UserChoice    *UserChoice\i = GetOut  EndIf  ;  If ParentHasBeenDisabled    DisableWindow(ActiveWindow, #False)  EndIf  ;  ; Memorize the result for the ZapmanFontColor(), ZapmanFontSize(), ZapmanFontColor() and ZapmanFontStyle() functions:  ZFR_FontDescription$ = FontDescription$  ;  ProcedureReturn FontDescription$EndProcedure;Procedure ZapmanFontRequester(Police$, FontSize, Options = 0, FontColor = 0, FontStyle = 0, ParentID = #PB_Default, XShiftOrPos = 0, YShiftOrPos = 0, ParentAnchor = #CWO_Center, WindowAnchor = #CWO_Center)  ;  ; This function is designed to be a replacement for the Purebasic FontRequester() function.  ; Its parameters are therefore compatible with the latter.  ;  ; ------------------------- RETURNED VALUE --------------------------  ;  ; • After calling this function, if the return value is non-zero, you can call  ;   ZapmanFontName(), ZapmanFontSize(), ZapmanFontColor(), And ZapmanFontStyle()  ;   instead of SelectedFontName(), SelectedFontSize(), SelectedFontColor(), and SelectedFontStyle()  ;   to get the values chose by the user.  ;  ; ------------------------------ NOTE -------------------------------  ; • Instead of calling this function, you can also call FontRequesterEx() with another  ;   and more flexible type of parameters to customize the requester.  ;  ; ------------------------ ENTRY PARAMETERS -------------------------  ;  ; • Police$ must contain the name of the police used by default in the dialog.  ;  ; • FontSize must contain the default font size used in the dialog.  ;  ; • Options allows you to customize the font requester by defining the options proposed to the user.  ;   This parameter is a numeric combination of the following flags:  ;   #PB_Font_Bold       add a 'Bold' CheckBox to the dialog  ;   #PB_Font_Italic     add an 'Italic' CheckBox to the dialog  ;   #PB_Font_StrikeOut  add a 'StrikeOut' CheckBox to the dialog  ;   #PB_Font_Underline  add an 'Underline' CheckBox to the dialog  ;   #ZFR_ChooseColor    allow to modify/choose a color for the font  ;   #ZFR_ShowSize       allow to modify/choose the size of the font  ;   #CF_NOVERTFONTS     Exclude vertical fonts from the list (font names beginning by "@")  ;   #CF_FIXEDPITCHONLY  Print only monospace fonts in the list  ;   #ZFR_NORASTERFONTS  Exclude raster fonts from the list  ;   #CF_TTONLY          Exclude non truetype from the list  ;   #CF_NOVECTORFONTS   Exclude OEM fonts from the list  ;   #CF_SCRIPTSONLY     Exclude OEM and Symbol fonts from the list  ;  ;   You can, for example, set it to #PB_Font_Bold | #PB_Font_Italic to allow usage of these styles, but prevent any  ;   other FontStyle variations.  ;  ;   You can also set this parameter to '#ZFR_FontRequester_Default' which is a combination of  ;   #PB_Font_Bold | #PB_Font_Italic | #ZFR_ShowSize | #CF_NOVERTFONTS  ;  ;   You can set this parameter to '#PB_FontRequester_Effects' which is equivalent to a combination of  ;   #PB_Font_Bold | #PB_Font_Italic | #PB_Font_StrikeOut | #PB_Font_Underline | #ZFR_ChooseColor | #ZFR_ShowSize  ;  ;   You can set this parameter to '#ZFR_FontRequester_Effects' which is a combination of  ;   #PB_FontRequester_Effects | #CF_NOVERTFONTS  ;  ;  ; • Color will be the default color printed in the dialog. If the 'Options' parameter  ;   contains the '#ZFR_ChooseColor' flag, the user will able to modify the default color.  ;  ; • FontStyle will be the default style setted when opening the dialog.  ;   It can be a combination of   ;   #PB_Font_Bold  ;   #PB_Font_Italic  ;   #PB_Font_StrikeOut  ;   #PB_Font_Underline  ;   If the 'Options' parameter contains the same flags, the user will be able to modify these settings.  ;  ;  ; • If ParentID is a valid window number, the new window will be positionned relatively to it,  ;   and then shifted by XShiftOrPos and YShiftOrPos.  ; • If ParentID = #CWO_ActiveWindowPos and GetActiveWindow() returns a valid window number,  ;   GetActiveWindow() will be considered as the parent window.  ; • If ParentID = #CWO_ActiveWindowPos and GetActiveWindow() does NOT return a valid window number,  ;   the position will be calculated relatively to the main screen.  ; • It ParentID = #CWO_AbsolutePos, XShiftOrPos and YShiftOrPos will be the absolute coordinates  ;   of the new window.  ; • If ParentID = #CWO_MonitorPos, the position will be calculated relatively to the screen where  ;   GetActiveWindow() is found or relatively to the main screen if GetActiveWindow()  ;   is not a valid window.  ;  ; • The new window will be positionned relatively to the center, top-left, top-right, bottom-left  ;   or bottom-right of the parent window (or monitor), depending on the 'ParentAnchor' parameter.  ;  ; • The anchor of the new window can be the center, top-left, top-right, bottom-left or bottom-right  ;   of the new window, depending on the 'WindowAnchor' parameter.  ;  ; • In all case, except if ParentID = #CWO_AbsolutePos, the position of the new window will be  ;   shifted regarding the 'XShiftOrPos' and 'YShiftOrPos' parameters.  ;  Protected AvailableStyles, FontDescription$  ;  If Options & #PB_FontRequester_Effects     AvailableStyles = #PB_Font_Bold | #PB_Font_Italic | #PB_Font_StrikeOut | #PB_Font_Underline | #ZFR_ChooseColor | #ZFR_ShowSize  ElseIf Options = 0    AvailableStyles = #ZFR_FontRequester_Default  Else    AvailableStyles = Options  EndIf  ;  FontDescription$ = Police$ + ", " + Str(FontSize) + ", ForeColor:" + Hex(FontColor)  FontDescription$ + ", " + GetAttributesDescriptionFromNumStyle(FontStyle)  ;  Protected UserChoice  FontDescription$ = FontRequesterEx(FontDescription$, AvailableStyles, @UserChoice, ParentID, XShiftOrPos, YShiftOrPos, ParentAnchor, WindowAnchor)  ProcedureReturn UserChoiceEndProcedure;Procedure.s ZapmanFontName(FontDescription$ = "")  ; This functions can be called with no parameter  ; in replacement of SelectedFontName() after a call  ; to ZapmanFontRequester().  If FontDescription$ = ""    FontDescription$ = ZFR_FontDescription$  EndIf  ;  Protected pp, mFontDescription$, parameter$  Protected FontName$, FontSize, FontColor, FontStyle  ;  ZFR_ExtractParametersFromFontDescription(FontDescription$)  ProcedureReturn FontName$EndProcedure;Procedure ZapmanFontSize(FontDescription$ = "")  ; This functions can be called with no parameter  ; in replacement of SelectedFontSize() after a call  ; to ZapmanFontRequester().  If FontDescription$ = ""    FontDescription$ = ZFR_FontDescription$  EndIf  ;  Protected pp, mFontDescription$, parameter$  Protected FontName$, FontSize, FontColor, FontStyle  ;  ZFR_ExtractParametersFromFontDescription(FontDescription$)  ProcedureReturn FontSizeEndProcedure;Procedure ZapmanFontColor(FontDescription$ = "")  ; This functions can be called with no parameter  ; in replacement of SelectedFontColor() after a call  ; to ZapmanFontRequester().  If FontDescription$ = ""    FontDescription$ = ZFR_FontDescription$  EndIf  ;  Protected pp, mFontDescription$, parameter$  Protected FontName$, FontSize, FontColor, FontStyle  ;  ZFR_ExtractParametersFromFontDescription(FontDescription$)  ProcedureReturn FontColorEndProcedure;Procedure ZapmanFontStyle(FontDescription$ = "")  ; This functions can be called with no parameter  ; in replacement of SelectedFontStyle() after a call  ; to ZapmanFontRequester().  If FontDescription$ = ""    FontDescription$ = ZFR_FontDescription$  EndIf  ;  Protected pp, mFontDescription$, parameter$  Protected FontName$, FontSize, FontColor, FontStyle  ;  ZFR_ExtractParametersFromFontDescription(FontDescription$)  ProcedureReturn FontStyleEndProcedure;;; ****************************************************************************;;-                                  5. DEMO;; ****************************************************************************;CompilerIf #PB_Compiler_IsMainFile  ; The following won't run when this file is used as 'Included'.  ;  If OpenWindow(0, 100, 100, 400, 180, "FontRequester Demo", #PB_Window_SystemMenu | #PB_Window_ScreenCentered)    ButtonGadget(1, 50, 20, 300, 40, "Classical FontRequester")    ButtonGadget(2, 50, 70, 300, 40, "Zapman FontRequester")    ButtonGadget(3, 50, 120, 300, 40, "FontRequesterEx")    ;    Define FontDescription$ = "segoe UI, 9, $FF0000, Italic"    ;    Repeat      Select WaitWindowEvent()        Case #PB_Event_Gadget          If EventGadget() = 1            If FontRequester("Segoe ui", 9, #PB_FontRequester_Effects, $FF0000, #PB_Font_Italic, WindowID(0))              ; Show selected font              FontDescription$ = SelectedFontName() + ", " + Str(SelectedFontSize())              If SelectedFontColor() <> 0                FontDescription$ + ", $" + Hex(SelectedFontColor())              EndIf              If SelectedFontStyle()                FontDescription$ + ", " + GetAttributesDescriptionFromNumStyle(SelectedFontStyle())              EndIf              SetGadgetText(1, FontDescription$)            EndIf          EndIf          If EventGadget() = 2            If ZapmanFontRequester("Segoe ui", 9, #PB_FontRequester_Effects, $FF0000, #PB_Font_Italic, WindowID(0), 70, 120)              ; After a call to ZapmanFontRequester(), if you want to get a font description,              ; the simpliest way is to use the global variable ZFR_FontDescription$.              ; So, you can do:              ; SetGadgetText(2, ZFR_FontDescription$)              ;              ; And if you want to load a font from what has been set with ZapmanFontRequester(),              ; you can simply do:              ; MyFont = LoadFontFromDescription(ZFR_FontDescription$)              ;              ; The following lines are here only to show that you can use the Zapman functions              ; exactly the same way as PureBasic native functions:              FontDescription$ = ZapmanFontName() + ", " + Str(ZapmanFontSize())              If ZapmanFontColor() <> -1                FontDescription$ + ", $" + Hex(ZapmanFontColor())              EndIf              If ZapmanFontName()                FontDescription$ + ", " + GetAttributesDescriptionFromNumStyle(ZapmanFontStyle())              EndIf              SetGadgetText(2, FontDescription$)              ;            EndIf          EndIf          If EventGadget() = 3            Define UserChoice = 0            FontDescription$ = FontRequesterEx(FontDescription$, #ZFR_FontRequester_Effects, @UserChoice, WindowID(0), 70, 120)            If UserChoice              ; Show selected font              SetGadgetText(3, FontDescription$)            EndIf          EndIf        Case #PB_Event_CloseWindow          Break      EndSelect    ForEver  EndIf  ;CompilerEndIf; IDE Options = PureBasic 6.20 (Windows - x64); CursorPosition = 236; FirstLine = 236; Folding = --b-v-; EnableXP